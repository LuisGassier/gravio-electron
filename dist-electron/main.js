import Tn, { app as sn, BrowserWindow as d0, ipcMain as wt, shell as uT, dialog as fT } from "electron";
import Kr from "fs";
import dT from "constants";
import es from "stream";
import h0, { promisify as hT } from "util";
import Jy from "assert";
import vt from "path";
import Kc, { exec as pT } from "child_process";
import Qy from "events";
import ts from "crypto";
import Zy from "tty";
import Yc from "os";
import Yi, { fileURLToPath as mT } from "url";
import gT from "string_decoder";
import eE from "zlib";
import vT from "http";
import $t from "node:process";
import ut from "node:path";
import { promisify as Zt, isDeepStrictEqual as xh } from "node:util";
import Je from "node:fs";
import Zn from "node:crypto";
import Th from "node:assert";
import tE from "node:os";
import "node:events";
import "node:stream";
import "https";
var zr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function rE(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ei = {}, Il = {}, _s = {}, Sh;
function Cr() {
  return Sh || (Sh = 1, _s.fromCallback = function(e) {
    return Object.defineProperty(function(...t) {
      if (typeof t[t.length - 1] == "function") e.apply(this, t);
      else
        return new Promise((r, n) => {
          t.push((i, a) => i != null ? n(i) : r(a)), e.apply(this, t);
        });
    }, "name", { value: e.name });
  }, _s.fromPromise = function(e) {
    return Object.defineProperty(function(...t) {
      const r = t[t.length - 1];
      if (typeof r != "function") return e.apply(this, t);
      t.pop(), e.apply(this, t).then((n) => r(null, n), r);
    }, "name", { value: e.name });
  }), _s;
}
var bl, Ah;
function _T() {
  if (Ah) return bl;
  Ah = 1;
  var e = dT, t = process.cwd, r = null, n = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return r || (r = t.call(process)), r;
  };
  try {
    process.cwd();
  } catch {
  }
  if (typeof process.chdir == "function") {
    var i = process.chdir;
    process.chdir = function(s) {
      r = null, i.call(process, s);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, i);
  }
  bl = a;
  function a(s) {
    e.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && o(s), s.lutimes || c(s), s.chown = d(s.chown), s.fchown = d(s.fchown), s.lchown = d(s.lchown), s.chmod = u(s.chmod), s.fchmod = u(s.fchmod), s.lchmod = u(s.lchmod), s.chownSync = f(s.chownSync), s.fchownSync = f(s.fchownSync), s.lchownSync = f(s.lchownSync), s.chmodSync = l(s.chmodSync), s.fchmodSync = l(s.fchmodSync), s.lchmodSync = l(s.lchmodSync), s.stat = p(s.stat), s.fstat = p(s.fstat), s.lstat = p(s.lstat), s.statSync = v(s.statSync), s.fstatSync = v(s.fstatSync), s.lstatSync = v(s.lstatSync), s.chmod && !s.lchmod && (s.lchmod = function(h, _, g) {
      g && process.nextTick(g);
    }, s.lchmodSync = function() {
    }), s.chown && !s.lchown && (s.lchown = function(h, _, g, y) {
      y && process.nextTick(y);
    }, s.lchownSync = function() {
    }), n === "win32" && (s.rename = typeof s.rename != "function" ? s.rename : (function(h) {
      function _(g, y, x) {
        var S = Date.now(), w = 0;
        h(g, y, function E(R) {
          if (R && (R.code === "EACCES" || R.code === "EPERM" || R.code === "EBUSY") && Date.now() - S < 6e4) {
            setTimeout(function() {
              s.stat(y, function(N, B) {
                N && N.code === "ENOENT" ? h(g, y, E) : x(R);
              });
            }, w), w < 100 && (w += 10);
            return;
          }
          x && x(R);
        });
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(_, h), _;
    })(s.rename)), s.read = typeof s.read != "function" ? s.read : (function(h) {
      function _(g, y, x, S, w, E) {
        var R;
        if (E && typeof E == "function") {
          var N = 0;
          R = function(B, F, U) {
            if (B && B.code === "EAGAIN" && N < 10)
              return N++, h.call(s, g, y, x, S, w, R);
            E.apply(this, arguments);
          };
        }
        return h.call(s, g, y, x, S, w, R);
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(_, h), _;
    })(s.read), s.readSync = typeof s.readSync != "function" ? s.readSync : /* @__PURE__ */ (function(h) {
      return function(_, g, y, x, S) {
        for (var w = 0; ; )
          try {
            return h.call(s, _, g, y, x, S);
          } catch (E) {
            if (E.code === "EAGAIN" && w < 10) {
              w++;
              continue;
            }
            throw E;
          }
      };
    })(s.readSync);
    function o(h) {
      h.lchmod = function(_, g, y) {
        h.open(
          _,
          e.O_WRONLY | e.O_SYMLINK,
          g,
          function(x, S) {
            if (x) {
              y && y(x);
              return;
            }
            h.fchmod(S, g, function(w) {
              h.close(S, function(E) {
                y && y(w || E);
              });
            });
          }
        );
      }, h.lchmodSync = function(_, g) {
        var y = h.openSync(_, e.O_WRONLY | e.O_SYMLINK, g), x = !0, S;
        try {
          S = h.fchmodSync(y, g), x = !1;
        } finally {
          if (x)
            try {
              h.closeSync(y);
            } catch {
            }
          else
            h.closeSync(y);
        }
        return S;
      };
    }
    function c(h) {
      e.hasOwnProperty("O_SYMLINK") && h.futimes ? (h.lutimes = function(_, g, y, x) {
        h.open(_, e.O_SYMLINK, function(S, w) {
          if (S) {
            x && x(S);
            return;
          }
          h.futimes(w, g, y, function(E) {
            h.close(w, function(R) {
              x && x(E || R);
            });
          });
        });
      }, h.lutimesSync = function(_, g, y) {
        var x = h.openSync(_, e.O_SYMLINK), S, w = !0;
        try {
          S = h.futimesSync(x, g, y), w = !1;
        } finally {
          if (w)
            try {
              h.closeSync(x);
            } catch {
            }
          else
            h.closeSync(x);
        }
        return S;
      }) : h.futimes && (h.lutimes = function(_, g, y, x) {
        x && process.nextTick(x);
      }, h.lutimesSync = function() {
      });
    }
    function u(h) {
      return h && function(_, g, y) {
        return h.call(s, _, g, function(x) {
          m(x) && (x = null), y && y.apply(this, arguments);
        });
      };
    }
    function l(h) {
      return h && function(_, g) {
        try {
          return h.call(s, _, g);
        } catch (y) {
          if (!m(y)) throw y;
        }
      };
    }
    function d(h) {
      return h && function(_, g, y, x) {
        return h.call(s, _, g, y, function(S) {
          m(S) && (S = null), x && x.apply(this, arguments);
        });
      };
    }
    function f(h) {
      return h && function(_, g, y) {
        try {
          return h.call(s, _, g, y);
        } catch (x) {
          if (!m(x)) throw x;
        }
      };
    }
    function p(h) {
      return h && function(_, g, y) {
        typeof g == "function" && (y = g, g = null);
        function x(S, w) {
          w && (w.uid < 0 && (w.uid += 4294967296), w.gid < 0 && (w.gid += 4294967296)), y && y.apply(this, arguments);
        }
        return g ? h.call(s, _, g, x) : h.call(s, _, x);
      };
    }
    function v(h) {
      return h && function(_, g) {
        var y = g ? h.call(s, _, g) : h.call(s, _);
        return y && (y.uid < 0 && (y.uid += 4294967296), y.gid < 0 && (y.gid += 4294967296)), y;
      };
    }
    function m(h) {
      if (!h || h.code === "ENOSYS")
        return !0;
      var _ = !process.getuid || process.getuid() !== 0;
      return !!(_ && (h.code === "EINVAL" || h.code === "EPERM"));
    }
  }
  return bl;
}
var Fl, Rh;
function yT() {
  if (Rh) return Fl;
  Rh = 1;
  var e = es.Stream;
  Fl = t;
  function t(r) {
    return {
      ReadStream: n,
      WriteStream: i
    };
    function n(a, s) {
      if (!(this instanceof n)) return new n(a, s);
      e.call(this);
      var o = this;
      this.path = a, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, s = s || {};
      for (var c = Object.keys(s), u = 0, l = c.length; u < l; u++) {
        var d = c[u];
        this[d] = s[d];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          o._read();
        });
        return;
      }
      r.open(this.path, this.flags, this.mode, function(f, p) {
        if (f) {
          o.emit("error", f), o.readable = !1;
          return;
        }
        o.fd = p, o.emit("open", p), o._read();
      });
    }
    function i(a, s) {
      if (!(this instanceof i)) return new i(a, s);
      e.call(this), this.path = a, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, s = s || {};
      for (var o = Object.keys(s), c = 0, u = o.length; c < u; c++) {
        var l = o[c];
        this[l] = s[l];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = r.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
    }
  }
  return Fl;
}
var Dl, $h;
function ET() {
  if ($h) return Dl;
  $h = 1, Dl = t;
  var e = Object.getPrototypeOf || function(r) {
    return r.__proto__;
  };
  function t(r) {
    if (r === null || typeof r != "object")
      return r;
    if (r instanceof Object)
      var n = { __proto__: e(r) };
    else
      var n = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(r).forEach(function(i) {
      Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(r, i));
    }), n;
  }
  return Dl;
}
var ys, Oh;
function Er() {
  if (Oh) return ys;
  Oh = 1;
  var e = Kr, t = _T(), r = yT(), n = ET(), i = h0, a, s;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (a = Symbol.for("graceful-fs.queue"), s = Symbol.for("graceful-fs.previous")) : (a = "___graceful-fs.queue", s = "___graceful-fs.previous");
  function o() {
  }
  function c(h, _) {
    Object.defineProperty(h, a, {
      get: function() {
        return _;
      }
    });
  }
  var u = o;
  if (i.debuglog ? u = i.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (u = function() {
    var h = i.format.apply(i, arguments);
    h = "GFS4: " + h.split(/\n/).join(`
GFS4: `), console.error(h);
  }), !e[a]) {
    var l = zr[a] || [];
    c(e, l), e.close = (function(h) {
      function _(g, y) {
        return h.call(e, g, function(x) {
          x || v(), typeof y == "function" && y.apply(this, arguments);
        });
      }
      return Object.defineProperty(_, s, {
        value: h
      }), _;
    })(e.close), e.closeSync = (function(h) {
      function _(g) {
        h.apply(e, arguments), v();
      }
      return Object.defineProperty(_, s, {
        value: h
      }), _;
    })(e.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      u(e[a]), Jy.equal(e[a].length, 0);
    });
  }
  zr[a] || c(zr, e[a]), ys = d(n(e)), process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !e.__patched && (ys = d(e), e.__patched = !0);
  function d(h) {
    t(h), h.gracefulify = d, h.createReadStream = k, h.createWriteStream = I;
    var _ = h.readFile;
    h.readFile = g;
    function g(A, L, b) {
      return typeof L == "function" && (b = L, L = null), P(A, L, b);
      function P(te, H, D, q) {
        return _(te, H, function(J) {
          J && (J.code === "EMFILE" || J.code === "ENFILE") ? f([P, [te, H, D], J, q || Date.now(), Date.now()]) : typeof D == "function" && D.apply(this, arguments);
        });
      }
    }
    var y = h.writeFile;
    h.writeFile = x;
    function x(A, L, b, P) {
      return typeof b == "function" && (P = b, b = null), te(A, L, b, P);
      function te(H, D, q, J, ne) {
        return y(H, D, q, function(ce) {
          ce && (ce.code === "EMFILE" || ce.code === "ENFILE") ? f([te, [H, D, q, J], ce, ne || Date.now(), Date.now()]) : typeof J == "function" && J.apply(this, arguments);
        });
      }
    }
    var S = h.appendFile;
    S && (h.appendFile = w);
    function w(A, L, b, P) {
      return typeof b == "function" && (P = b, b = null), te(A, L, b, P);
      function te(H, D, q, J, ne) {
        return S(H, D, q, function(ce) {
          ce && (ce.code === "EMFILE" || ce.code === "ENFILE") ? f([te, [H, D, q, J], ce, ne || Date.now(), Date.now()]) : typeof J == "function" && J.apply(this, arguments);
        });
      }
    }
    var E = h.copyFile;
    E && (h.copyFile = R);
    function R(A, L, b, P) {
      return typeof b == "function" && (P = b, b = 0), te(A, L, b, P);
      function te(H, D, q, J, ne) {
        return E(H, D, q, function(ce) {
          ce && (ce.code === "EMFILE" || ce.code === "ENFILE") ? f([te, [H, D, q, J], ce, ne || Date.now(), Date.now()]) : typeof J == "function" && J.apply(this, arguments);
        });
      }
    }
    var N = h.readdir;
    h.readdir = F;
    var B = /^v[0-5]\./;
    function F(A, L, b) {
      typeof L == "function" && (b = L, L = null);
      var P = B.test(process.version) ? function(D, q, J, ne) {
        return N(D, te(
          D,
          q,
          J,
          ne
        ));
      } : function(D, q, J, ne) {
        return N(D, q, te(
          D,
          q,
          J,
          ne
        ));
      };
      return P(A, L, b);
      function te(H, D, q, J) {
        return function(ne, ce) {
          ne && (ne.code === "EMFILE" || ne.code === "ENFILE") ? f([
            P,
            [H, D, q],
            ne,
            J || Date.now(),
            Date.now()
          ]) : (ce && ce.sort && ce.sort(), typeof q == "function" && q.call(this, ne, ce));
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var U = r(h);
      W = U.ReadStream, se = U.WriteStream;
    }
    var G = h.ReadStream;
    G && (W.prototype = Object.create(G.prototype), W.prototype.open = ae);
    var M = h.WriteStream;
    M && (se.prototype = Object.create(M.prototype), se.prototype.open = X), Object.defineProperty(h, "ReadStream", {
      get: function() {
        return W;
      },
      set: function(A) {
        W = A;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(h, "WriteStream", {
      get: function() {
        return se;
      },
      set: function(A) {
        se = A;
      },
      enumerable: !0,
      configurable: !0
    });
    var V = W;
    Object.defineProperty(h, "FileReadStream", {
      get: function() {
        return V;
      },
      set: function(A) {
        V = A;
      },
      enumerable: !0,
      configurable: !0
    });
    var ie = se;
    Object.defineProperty(h, "FileWriteStream", {
      get: function() {
        return ie;
      },
      set: function(A) {
        ie = A;
      },
      enumerable: !0,
      configurable: !0
    });
    function W(A, L) {
      return this instanceof W ? (G.apply(this, arguments), this) : W.apply(Object.create(W.prototype), arguments);
    }
    function ae() {
      var A = this;
      T(A.path, A.flags, A.mode, function(L, b) {
        L ? (A.autoClose && A.destroy(), A.emit("error", L)) : (A.fd = b, A.emit("open", b), A.read());
      });
    }
    function se(A, L) {
      return this instanceof se ? (M.apply(this, arguments), this) : se.apply(Object.create(se.prototype), arguments);
    }
    function X() {
      var A = this;
      T(A.path, A.flags, A.mode, function(L, b) {
        L ? (A.destroy(), A.emit("error", L)) : (A.fd = b, A.emit("open", b));
      });
    }
    function k(A, L) {
      return new h.ReadStream(A, L);
    }
    function I(A, L) {
      return new h.WriteStream(A, L);
    }
    var C = h.open;
    h.open = T;
    function T(A, L, b, P) {
      return typeof b == "function" && (P = b, b = null), te(A, L, b, P);
      function te(H, D, q, J, ne) {
        return C(H, D, q, function(ce, Ee) {
          ce && (ce.code === "EMFILE" || ce.code === "ENFILE") ? f([te, [H, D, q, J], ce, ne || Date.now(), Date.now()]) : typeof J == "function" && J.apply(this, arguments);
        });
      }
    }
    return h;
  }
  function f(h) {
    u("ENQUEUE", h[0].name, h[1]), e[a].push(h), m();
  }
  var p;
  function v() {
    for (var h = Date.now(), _ = 0; _ < e[a].length; ++_)
      e[a][_].length > 2 && (e[a][_][3] = h, e[a][_][4] = h);
    m();
  }
  function m() {
    if (clearTimeout(p), p = void 0, e[a].length !== 0) {
      var h = e[a].shift(), _ = h[0], g = h[1], y = h[2], x = h[3], S = h[4];
      if (x === void 0)
        u("RETRY", _.name, g), _.apply(null, g);
      else if (Date.now() - x >= 6e4) {
        u("TIMEOUT", _.name, g);
        var w = g.pop();
        typeof w == "function" && w.call(null, y);
      } else {
        var E = Date.now() - S, R = Math.max(S - x, 1), N = Math.min(R * 1.2, 100);
        E >= N ? (u("RETRY", _.name, g), _.apply(null, g.concat([x]))) : e[a].push(h);
      }
      p === void 0 && (p = setTimeout(m, 0));
    }
  }
  return ys;
}
var Nh;
function Ji() {
  return Nh || (Nh = 1, (function(e) {
    const t = Cr().fromCallback, r = Er(), n = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((i) => typeof r[i] == "function");
    Object.assign(e, r), n.forEach((i) => {
      e[i] = t(r[i]);
    }), e.exists = function(i, a) {
      return typeof a == "function" ? r.exists(i, a) : new Promise((s) => r.exists(i, s));
    }, e.read = function(i, a, s, o, c, u) {
      return typeof u == "function" ? r.read(i, a, s, o, c, u) : new Promise((l, d) => {
        r.read(i, a, s, o, c, (f, p, v) => {
          if (f) return d(f);
          l({ bytesRead: p, buffer: v });
        });
      });
    }, e.write = function(i, a, ...s) {
      return typeof s[s.length - 1] == "function" ? r.write(i, a, ...s) : new Promise((o, c) => {
        r.write(i, a, ...s, (u, l, d) => {
          if (u) return c(u);
          o({ bytesWritten: l, buffer: d });
        });
      });
    }, typeof r.writev == "function" && (e.writev = function(i, a, ...s) {
      return typeof s[s.length - 1] == "function" ? r.writev(i, a, ...s) : new Promise((o, c) => {
        r.writev(i, a, ...s, (u, l, d) => {
          if (u) return c(u);
          o({ bytesWritten: l, buffers: d });
        });
      });
    }), typeof r.realpath.native == "function" ? e.realpath.native = t(r.realpath.native) : process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  })(Il)), Il;
}
var Es = {}, kl = {}, Ph;
function wT() {
  if (Ph) return kl;
  Ph = 1;
  const e = vt;
  return kl.checkPath = function(r) {
    if (process.platform === "win32" && /[<>:"|?*]/.test(r.replace(e.parse(r).root, ""))) {
      const i = new Error(`Path contains invalid characters: ${r}`);
      throw i.code = "EINVAL", i;
    }
  }, kl;
}
var Ch;
function xT() {
  if (Ch) return Es;
  Ch = 1;
  const e = /* @__PURE__ */ Ji(), { checkPath: t } = /* @__PURE__ */ wT(), r = (n) => {
    const i = { mode: 511 };
    return typeof n == "number" ? n : { ...i, ...n }.mode;
  };
  return Es.makeDir = async (n, i) => (t(n), e.mkdir(n, {
    mode: r(i),
    recursive: !0
  })), Es.makeDirSync = (n, i) => (t(n), e.mkdirSync(n, {
    mode: r(i),
    recursive: !0
  })), Es;
}
var Ll, Ih;
function cn() {
  if (Ih) return Ll;
  Ih = 1;
  const e = Cr().fromPromise, { makeDir: t, makeDirSync: r } = /* @__PURE__ */ xT(), n = e(t);
  return Ll = {
    mkdirs: n,
    mkdirsSync: r,
    // alias
    mkdirp: n,
    mkdirpSync: r,
    ensureDir: n,
    ensureDirSync: r
  }, Ll;
}
var Ml, bh;
function _i() {
  if (bh) return Ml;
  bh = 1;
  const e = Cr().fromPromise, t = /* @__PURE__ */ Ji();
  function r(n) {
    return t.access(n).then(() => !0).catch(() => !1);
  }
  return Ml = {
    pathExists: e(r),
    pathExistsSync: t.existsSync
  }, Ml;
}
var Ul, Fh;
function nE() {
  if (Fh) return Ul;
  Fh = 1;
  const e = Er();
  function t(n, i, a, s) {
    e.open(n, "r+", (o, c) => {
      if (o) return s(o);
      e.futimes(c, i, a, (u) => {
        e.close(c, (l) => {
          s && s(u || l);
        });
      });
    });
  }
  function r(n, i, a) {
    const s = e.openSync(n, "r+");
    return e.futimesSync(s, i, a), e.closeSync(s);
  }
  return Ul = {
    utimesMillis: t,
    utimesMillisSync: r
  }, Ul;
}
var ql, Dh;
function Qi() {
  if (Dh) return ql;
  Dh = 1;
  const e = /* @__PURE__ */ Ji(), t = vt, r = h0;
  function n(f, p, v) {
    const m = v.dereference ? (h) => e.stat(h, { bigint: !0 }) : (h) => e.lstat(h, { bigint: !0 });
    return Promise.all([
      m(f),
      m(p).catch((h) => {
        if (h.code === "ENOENT") return null;
        throw h;
      })
    ]).then(([h, _]) => ({ srcStat: h, destStat: _ }));
  }
  function i(f, p, v) {
    let m;
    const h = v.dereference ? (g) => e.statSync(g, { bigint: !0 }) : (g) => e.lstatSync(g, { bigint: !0 }), _ = h(f);
    try {
      m = h(p);
    } catch (g) {
      if (g.code === "ENOENT") return { srcStat: _, destStat: null };
      throw g;
    }
    return { srcStat: _, destStat: m };
  }
  function a(f, p, v, m, h) {
    r.callbackify(n)(f, p, m, (_, g) => {
      if (_) return h(_);
      const { srcStat: y, destStat: x } = g;
      if (x) {
        if (u(y, x)) {
          const S = t.basename(f), w = t.basename(p);
          return v === "move" && S !== w && S.toLowerCase() === w.toLowerCase() ? h(null, { srcStat: y, destStat: x, isChangingCase: !0 }) : h(new Error("Source and destination must not be the same."));
        }
        if (y.isDirectory() && !x.isDirectory())
          return h(new Error(`Cannot overwrite non-directory '${p}' with directory '${f}'.`));
        if (!y.isDirectory() && x.isDirectory())
          return h(new Error(`Cannot overwrite directory '${p}' with non-directory '${f}'.`));
      }
      return y.isDirectory() && l(f, p) ? h(new Error(d(f, p, v))) : h(null, { srcStat: y, destStat: x });
    });
  }
  function s(f, p, v, m) {
    const { srcStat: h, destStat: _ } = i(f, p, m);
    if (_) {
      if (u(h, _)) {
        const g = t.basename(f), y = t.basename(p);
        if (v === "move" && g !== y && g.toLowerCase() === y.toLowerCase())
          return { srcStat: h, destStat: _, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (h.isDirectory() && !_.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${p}' with directory '${f}'.`);
      if (!h.isDirectory() && _.isDirectory())
        throw new Error(`Cannot overwrite directory '${p}' with non-directory '${f}'.`);
    }
    if (h.isDirectory() && l(f, p))
      throw new Error(d(f, p, v));
    return { srcStat: h, destStat: _ };
  }
  function o(f, p, v, m, h) {
    const _ = t.resolve(t.dirname(f)), g = t.resolve(t.dirname(v));
    if (g === _ || g === t.parse(g).root) return h();
    e.stat(g, { bigint: !0 }, (y, x) => y ? y.code === "ENOENT" ? h() : h(y) : u(p, x) ? h(new Error(d(f, v, m))) : o(f, p, g, m, h));
  }
  function c(f, p, v, m) {
    const h = t.resolve(t.dirname(f)), _ = t.resolve(t.dirname(v));
    if (_ === h || _ === t.parse(_).root) return;
    let g;
    try {
      g = e.statSync(_, { bigint: !0 });
    } catch (y) {
      if (y.code === "ENOENT") return;
      throw y;
    }
    if (u(p, g))
      throw new Error(d(f, v, m));
    return c(f, p, _, m);
  }
  function u(f, p) {
    return p.ino && p.dev && p.ino === f.ino && p.dev === f.dev;
  }
  function l(f, p) {
    const v = t.resolve(f).split(t.sep).filter((h) => h), m = t.resolve(p).split(t.sep).filter((h) => h);
    return v.reduce((h, _, g) => h && m[g] === _, !0);
  }
  function d(f, p, v) {
    return `Cannot ${v} '${f}' to a subdirectory of itself, '${p}'.`;
  }
  return ql = {
    checkPaths: a,
    checkPathsSync: s,
    checkParentPaths: o,
    checkParentPathsSync: c,
    isSrcSubdir: l,
    areIdentical: u
  }, ql;
}
var Bl, kh;
function TT() {
  if (kh) return Bl;
  kh = 1;
  const e = Er(), t = vt, r = cn().mkdirs, n = _i().pathExists, i = nE().utimesMillis, a = /* @__PURE__ */ Qi();
  function s(F, U, G, M) {
    typeof G == "function" && !M ? (M = G, G = {}) : typeof G == "function" && (G = { filter: G }), M = M || function() {
    }, G = G || {}, G.clobber = "clobber" in G ? !!G.clobber : !0, G.overwrite = "overwrite" in G ? !!G.overwrite : G.clobber, G.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0001"
    ), a.checkPaths(F, U, "copy", G, (V, ie) => {
      if (V) return M(V);
      const { srcStat: W, destStat: ae } = ie;
      a.checkParentPaths(F, W, U, "copy", (se) => se ? M(se) : G.filter ? c(o, ae, F, U, G, M) : o(ae, F, U, G, M));
    });
  }
  function o(F, U, G, M, V) {
    const ie = t.dirname(G);
    n(ie, (W, ae) => {
      if (W) return V(W);
      if (ae) return l(F, U, G, M, V);
      r(ie, (se) => se ? V(se) : l(F, U, G, M, V));
    });
  }
  function c(F, U, G, M, V, ie) {
    Promise.resolve(V.filter(G, M)).then((W) => W ? F(U, G, M, V, ie) : ie(), (W) => ie(W));
  }
  function u(F, U, G, M, V) {
    return M.filter ? c(l, F, U, G, M, V) : l(F, U, G, M, V);
  }
  function l(F, U, G, M, V) {
    (M.dereference ? e.stat : e.lstat)(U, (W, ae) => W ? V(W) : ae.isDirectory() ? x(ae, F, U, G, M, V) : ae.isFile() || ae.isCharacterDevice() || ae.isBlockDevice() ? d(ae, F, U, G, M, V) : ae.isSymbolicLink() ? N(F, U, G, M, V) : ae.isSocket() ? V(new Error(`Cannot copy a socket file: ${U}`)) : ae.isFIFO() ? V(new Error(`Cannot copy a FIFO pipe: ${U}`)) : V(new Error(`Unknown file: ${U}`)));
  }
  function d(F, U, G, M, V, ie) {
    return U ? f(F, G, M, V, ie) : p(F, G, M, V, ie);
  }
  function f(F, U, G, M, V) {
    if (M.overwrite)
      e.unlink(G, (ie) => ie ? V(ie) : p(F, U, G, M, V));
    else return M.errorOnExist ? V(new Error(`'${G}' already exists`)) : V();
  }
  function p(F, U, G, M, V) {
    e.copyFile(U, G, (ie) => ie ? V(ie) : M.preserveTimestamps ? v(F.mode, U, G, V) : g(G, F.mode, V));
  }
  function v(F, U, G, M) {
    return m(F) ? h(G, F, (V) => V ? M(V) : _(F, U, G, M)) : _(F, U, G, M);
  }
  function m(F) {
    return (F & 128) === 0;
  }
  function h(F, U, G) {
    return g(F, U | 128, G);
  }
  function _(F, U, G, M) {
    y(U, G, (V) => V ? M(V) : g(G, F, M));
  }
  function g(F, U, G) {
    return e.chmod(F, U, G);
  }
  function y(F, U, G) {
    e.stat(F, (M, V) => M ? G(M) : i(U, V.atime, V.mtime, G));
  }
  function x(F, U, G, M, V, ie) {
    return U ? w(G, M, V, ie) : S(F.mode, G, M, V, ie);
  }
  function S(F, U, G, M, V) {
    e.mkdir(G, (ie) => {
      if (ie) return V(ie);
      w(U, G, M, (W) => W ? V(W) : g(G, F, V));
    });
  }
  function w(F, U, G, M) {
    e.readdir(F, (V, ie) => V ? M(V) : E(ie, F, U, G, M));
  }
  function E(F, U, G, M, V) {
    const ie = F.pop();
    return ie ? R(F, ie, U, G, M, V) : V();
  }
  function R(F, U, G, M, V, ie) {
    const W = t.join(G, U), ae = t.join(M, U);
    a.checkPaths(W, ae, "copy", V, (se, X) => {
      if (se) return ie(se);
      const { destStat: k } = X;
      u(k, W, ae, V, (I) => I ? ie(I) : E(F, G, M, V, ie));
    });
  }
  function N(F, U, G, M, V) {
    e.readlink(U, (ie, W) => {
      if (ie) return V(ie);
      if (M.dereference && (W = t.resolve(process.cwd(), W)), F)
        e.readlink(G, (ae, se) => ae ? ae.code === "EINVAL" || ae.code === "UNKNOWN" ? e.symlink(W, G, V) : V(ae) : (M.dereference && (se = t.resolve(process.cwd(), se)), a.isSrcSubdir(W, se) ? V(new Error(`Cannot copy '${W}' to a subdirectory of itself, '${se}'.`)) : F.isDirectory() && a.isSrcSubdir(se, W) ? V(new Error(`Cannot overwrite '${se}' with '${W}'.`)) : B(W, G, V)));
      else
        return e.symlink(W, G, V);
    });
  }
  function B(F, U, G) {
    e.unlink(U, (M) => M ? G(M) : e.symlink(F, U, G));
  }
  return Bl = s, Bl;
}
var jl, Lh;
function ST() {
  if (Lh) return jl;
  Lh = 1;
  const e = Er(), t = vt, r = cn().mkdirsSync, n = nE().utimesMillisSync, i = /* @__PURE__ */ Qi();
  function a(E, R, N) {
    typeof N == "function" && (N = { filter: N }), N = N || {}, N.clobber = "clobber" in N ? !!N.clobber : !0, N.overwrite = "overwrite" in N ? !!N.overwrite : N.clobber, N.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0002"
    );
    const { srcStat: B, destStat: F } = i.checkPathsSync(E, R, "copy", N);
    return i.checkParentPathsSync(E, B, R, "copy"), s(F, E, R, N);
  }
  function s(E, R, N, B) {
    if (B.filter && !B.filter(R, N)) return;
    const F = t.dirname(N);
    return e.existsSync(F) || r(F), c(E, R, N, B);
  }
  function o(E, R, N, B) {
    if (!(B.filter && !B.filter(R, N)))
      return c(E, R, N, B);
  }
  function c(E, R, N, B) {
    const U = (B.dereference ? e.statSync : e.lstatSync)(R);
    if (U.isDirectory()) return _(U, E, R, N, B);
    if (U.isFile() || U.isCharacterDevice() || U.isBlockDevice()) return u(U, E, R, N, B);
    if (U.isSymbolicLink()) return S(E, R, N, B);
    throw U.isSocket() ? new Error(`Cannot copy a socket file: ${R}`) : U.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${R}`) : new Error(`Unknown file: ${R}`);
  }
  function u(E, R, N, B, F) {
    return R ? l(E, N, B, F) : d(E, N, B, F);
  }
  function l(E, R, N, B) {
    if (B.overwrite)
      return e.unlinkSync(N), d(E, R, N, B);
    if (B.errorOnExist)
      throw new Error(`'${N}' already exists`);
  }
  function d(E, R, N, B) {
    return e.copyFileSync(R, N), B.preserveTimestamps && f(E.mode, R, N), m(N, E.mode);
  }
  function f(E, R, N) {
    return p(E) && v(N, E), h(R, N);
  }
  function p(E) {
    return (E & 128) === 0;
  }
  function v(E, R) {
    return m(E, R | 128);
  }
  function m(E, R) {
    return e.chmodSync(E, R);
  }
  function h(E, R) {
    const N = e.statSync(E);
    return n(R, N.atime, N.mtime);
  }
  function _(E, R, N, B, F) {
    return R ? y(N, B, F) : g(E.mode, N, B, F);
  }
  function g(E, R, N, B) {
    return e.mkdirSync(N), y(R, N, B), m(N, E);
  }
  function y(E, R, N) {
    e.readdirSync(E).forEach((B) => x(B, E, R, N));
  }
  function x(E, R, N, B) {
    const F = t.join(R, E), U = t.join(N, E), { destStat: G } = i.checkPathsSync(F, U, "copy", B);
    return o(G, F, U, B);
  }
  function S(E, R, N, B) {
    let F = e.readlinkSync(R);
    if (B.dereference && (F = t.resolve(process.cwd(), F)), E) {
      let U;
      try {
        U = e.readlinkSync(N);
      } catch (G) {
        if (G.code === "EINVAL" || G.code === "UNKNOWN") return e.symlinkSync(F, N);
        throw G;
      }
      if (B.dereference && (U = t.resolve(process.cwd(), U)), i.isSrcSubdir(F, U))
        throw new Error(`Cannot copy '${F}' to a subdirectory of itself, '${U}'.`);
      if (e.statSync(N).isDirectory() && i.isSrcSubdir(U, F))
        throw new Error(`Cannot overwrite '${U}' with '${F}'.`);
      return w(F, N);
    } else
      return e.symlinkSync(F, N);
  }
  function w(E, R) {
    return e.unlinkSync(R), e.symlinkSync(E, R);
  }
  return jl = a, jl;
}
var Vl, Mh;
function p0() {
  if (Mh) return Vl;
  Mh = 1;
  const e = Cr().fromCallback;
  return Vl = {
    copy: e(/* @__PURE__ */ TT()),
    copySync: /* @__PURE__ */ ST()
  }, Vl;
}
var Hl, Uh;
function AT() {
  if (Uh) return Hl;
  Uh = 1;
  const e = Er(), t = vt, r = Jy, n = process.platform === "win32";
  function i(v) {
    [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ].forEach((h) => {
      v[h] = v[h] || e[h], h = h + "Sync", v[h] = v[h] || e[h];
    }), v.maxBusyTries = v.maxBusyTries || 3;
  }
  function a(v, m, h) {
    let _ = 0;
    typeof m == "function" && (h = m, m = {}), r(v, "rimraf: missing path"), r.strictEqual(typeof v, "string", "rimraf: path should be a string"), r.strictEqual(typeof h, "function", "rimraf: callback function required"), r(m, "rimraf: invalid options argument provided"), r.strictEqual(typeof m, "object", "rimraf: options should be object"), i(m), s(v, m, function g(y) {
      if (y) {
        if ((y.code === "EBUSY" || y.code === "ENOTEMPTY" || y.code === "EPERM") && _ < m.maxBusyTries) {
          _++;
          const x = _ * 100;
          return setTimeout(() => s(v, m, g), x);
        }
        y.code === "ENOENT" && (y = null);
      }
      h(y);
    });
  }
  function s(v, m, h) {
    r(v), r(m), r(typeof h == "function"), m.lstat(v, (_, g) => {
      if (_ && _.code === "ENOENT")
        return h(null);
      if (_ && _.code === "EPERM" && n)
        return o(v, m, _, h);
      if (g && g.isDirectory())
        return u(v, m, _, h);
      m.unlink(v, (y) => {
        if (y) {
          if (y.code === "ENOENT")
            return h(null);
          if (y.code === "EPERM")
            return n ? o(v, m, y, h) : u(v, m, y, h);
          if (y.code === "EISDIR")
            return u(v, m, y, h);
        }
        return h(y);
      });
    });
  }
  function o(v, m, h, _) {
    r(v), r(m), r(typeof _ == "function"), m.chmod(v, 438, (g) => {
      g ? _(g.code === "ENOENT" ? null : h) : m.stat(v, (y, x) => {
        y ? _(y.code === "ENOENT" ? null : h) : x.isDirectory() ? u(v, m, h, _) : m.unlink(v, _);
      });
    });
  }
  function c(v, m, h) {
    let _;
    r(v), r(m);
    try {
      m.chmodSync(v, 438);
    } catch (g) {
      if (g.code === "ENOENT")
        return;
      throw h;
    }
    try {
      _ = m.statSync(v);
    } catch (g) {
      if (g.code === "ENOENT")
        return;
      throw h;
    }
    _.isDirectory() ? f(v, m, h) : m.unlinkSync(v);
  }
  function u(v, m, h, _) {
    r(v), r(m), r(typeof _ == "function"), m.rmdir(v, (g) => {
      g && (g.code === "ENOTEMPTY" || g.code === "EEXIST" || g.code === "EPERM") ? l(v, m, _) : g && g.code === "ENOTDIR" ? _(h) : _(g);
    });
  }
  function l(v, m, h) {
    r(v), r(m), r(typeof h == "function"), m.readdir(v, (_, g) => {
      if (_) return h(_);
      let y = g.length, x;
      if (y === 0) return m.rmdir(v, h);
      g.forEach((S) => {
        a(t.join(v, S), m, (w) => {
          if (!x) {
            if (w) return h(x = w);
            --y === 0 && m.rmdir(v, h);
          }
        });
      });
    });
  }
  function d(v, m) {
    let h;
    m = m || {}, i(m), r(v, "rimraf: missing path"), r.strictEqual(typeof v, "string", "rimraf: path should be a string"), r(m, "rimraf: missing options"), r.strictEqual(typeof m, "object", "rimraf: options should be object");
    try {
      h = m.lstatSync(v);
    } catch (_) {
      if (_.code === "ENOENT")
        return;
      _.code === "EPERM" && n && c(v, m, _);
    }
    try {
      h && h.isDirectory() ? f(v, m, null) : m.unlinkSync(v);
    } catch (_) {
      if (_.code === "ENOENT")
        return;
      if (_.code === "EPERM")
        return n ? c(v, m, _) : f(v, m, _);
      if (_.code !== "EISDIR")
        throw _;
      f(v, m, _);
    }
  }
  function f(v, m, h) {
    r(v), r(m);
    try {
      m.rmdirSync(v);
    } catch (_) {
      if (_.code === "ENOTDIR")
        throw h;
      if (_.code === "ENOTEMPTY" || _.code === "EEXIST" || _.code === "EPERM")
        p(v, m);
      else if (_.code !== "ENOENT")
        throw _;
    }
  }
  function p(v, m) {
    if (r(v), r(m), m.readdirSync(v).forEach((h) => d(t.join(v, h), m)), n) {
      const h = Date.now();
      do
        try {
          return m.rmdirSync(v, m);
        } catch {
        }
      while (Date.now() - h < 500);
    } else
      return m.rmdirSync(v, m);
  }
  return Hl = a, a.sync = d, Hl;
}
var Gl, qh;
function Jc() {
  if (qh) return Gl;
  qh = 1;
  const e = Er(), t = Cr().fromCallback, r = /* @__PURE__ */ AT();
  function n(a, s) {
    if (e.rm) return e.rm(a, { recursive: !0, force: !0 }, s);
    r(a, s);
  }
  function i(a) {
    if (e.rmSync) return e.rmSync(a, { recursive: !0, force: !0 });
    r.sync(a);
  }
  return Gl = {
    remove: t(n),
    removeSync: i
  }, Gl;
}
var zl, Bh;
function RT() {
  if (Bh) return zl;
  Bh = 1;
  const e = Cr().fromPromise, t = /* @__PURE__ */ Ji(), r = vt, n = /* @__PURE__ */ cn(), i = /* @__PURE__ */ Jc(), a = e(async function(c) {
    let u;
    try {
      u = await t.readdir(c);
    } catch {
      return n.mkdirs(c);
    }
    return Promise.all(u.map((l) => i.remove(r.join(c, l))));
  });
  function s(o) {
    let c;
    try {
      c = t.readdirSync(o);
    } catch {
      return n.mkdirsSync(o);
    }
    c.forEach((u) => {
      u = r.join(o, u), i.removeSync(u);
    });
  }
  return zl = {
    emptyDirSync: s,
    emptydirSync: s,
    emptyDir: a,
    emptydir: a
  }, zl;
}
var Wl, jh;
function $T() {
  if (jh) return Wl;
  jh = 1;
  const e = Cr().fromCallback, t = vt, r = Er(), n = /* @__PURE__ */ cn();
  function i(s, o) {
    function c() {
      r.writeFile(s, "", (u) => {
        if (u) return o(u);
        o();
      });
    }
    r.stat(s, (u, l) => {
      if (!u && l.isFile()) return o();
      const d = t.dirname(s);
      r.stat(d, (f, p) => {
        if (f)
          return f.code === "ENOENT" ? n.mkdirs(d, (v) => {
            if (v) return o(v);
            c();
          }) : o(f);
        p.isDirectory() ? c() : r.readdir(d, (v) => {
          if (v) return o(v);
        });
      });
    });
  }
  function a(s) {
    let o;
    try {
      o = r.statSync(s);
    } catch {
    }
    if (o && o.isFile()) return;
    const c = t.dirname(s);
    try {
      r.statSync(c).isDirectory() || r.readdirSync(c);
    } catch (u) {
      if (u && u.code === "ENOENT") n.mkdirsSync(c);
      else throw u;
    }
    r.writeFileSync(s, "");
  }
  return Wl = {
    createFile: e(i),
    createFileSync: a
  }, Wl;
}
var Xl, Vh;
function OT() {
  if (Vh) return Xl;
  Vh = 1;
  const e = Cr().fromCallback, t = vt, r = Er(), n = /* @__PURE__ */ cn(), i = _i().pathExists, { areIdentical: a } = /* @__PURE__ */ Qi();
  function s(c, u, l) {
    function d(f, p) {
      r.link(f, p, (v) => {
        if (v) return l(v);
        l(null);
      });
    }
    r.lstat(u, (f, p) => {
      r.lstat(c, (v, m) => {
        if (v)
          return v.message = v.message.replace("lstat", "ensureLink"), l(v);
        if (p && a(m, p)) return l(null);
        const h = t.dirname(u);
        i(h, (_, g) => {
          if (_) return l(_);
          if (g) return d(c, u);
          n.mkdirs(h, (y) => {
            if (y) return l(y);
            d(c, u);
          });
        });
      });
    });
  }
  function o(c, u) {
    let l;
    try {
      l = r.lstatSync(u);
    } catch {
    }
    try {
      const p = r.lstatSync(c);
      if (l && a(p, l)) return;
    } catch (p) {
      throw p.message = p.message.replace("lstat", "ensureLink"), p;
    }
    const d = t.dirname(u);
    return r.existsSync(d) || n.mkdirsSync(d), r.linkSync(c, u);
  }
  return Xl = {
    createLink: e(s),
    createLinkSync: o
  }, Xl;
}
var Kl, Hh;
function NT() {
  if (Hh) return Kl;
  Hh = 1;
  const e = vt, t = Er(), r = _i().pathExists;
  function n(a, s, o) {
    if (e.isAbsolute(a))
      return t.lstat(a, (c) => c ? (c.message = c.message.replace("lstat", "ensureSymlink"), o(c)) : o(null, {
        toCwd: a,
        toDst: a
      }));
    {
      const c = e.dirname(s), u = e.join(c, a);
      return r(u, (l, d) => l ? o(l) : d ? o(null, {
        toCwd: u,
        toDst: a
      }) : t.lstat(a, (f) => f ? (f.message = f.message.replace("lstat", "ensureSymlink"), o(f)) : o(null, {
        toCwd: a,
        toDst: e.relative(c, a)
      })));
    }
  }
  function i(a, s) {
    let o;
    if (e.isAbsolute(a)) {
      if (o = t.existsSync(a), !o) throw new Error("absolute srcpath does not exist");
      return {
        toCwd: a,
        toDst: a
      };
    } else {
      const c = e.dirname(s), u = e.join(c, a);
      if (o = t.existsSync(u), o)
        return {
          toCwd: u,
          toDst: a
        };
      if (o = t.existsSync(a), !o) throw new Error("relative srcpath does not exist");
      return {
        toCwd: a,
        toDst: e.relative(c, a)
      };
    }
  }
  return Kl = {
    symlinkPaths: n,
    symlinkPathsSync: i
  }, Kl;
}
var Yl, Gh;
function PT() {
  if (Gh) return Yl;
  Gh = 1;
  const e = Er();
  function t(n, i, a) {
    if (a = typeof i == "function" ? i : a, i = typeof i == "function" ? !1 : i, i) return a(null, i);
    e.lstat(n, (s, o) => {
      if (s) return a(null, "file");
      i = o && o.isDirectory() ? "dir" : "file", a(null, i);
    });
  }
  function r(n, i) {
    let a;
    if (i) return i;
    try {
      a = e.lstatSync(n);
    } catch {
      return "file";
    }
    return a && a.isDirectory() ? "dir" : "file";
  }
  return Yl = {
    symlinkType: t,
    symlinkTypeSync: r
  }, Yl;
}
var Jl, zh;
function CT() {
  if (zh) return Jl;
  zh = 1;
  const e = Cr().fromCallback, t = vt, r = /* @__PURE__ */ Ji(), n = /* @__PURE__ */ cn(), i = n.mkdirs, a = n.mkdirsSync, s = /* @__PURE__ */ NT(), o = s.symlinkPaths, c = s.symlinkPathsSync, u = /* @__PURE__ */ PT(), l = u.symlinkType, d = u.symlinkTypeSync, f = _i().pathExists, { areIdentical: p } = /* @__PURE__ */ Qi();
  function v(_, g, y, x) {
    x = typeof y == "function" ? y : x, y = typeof y == "function" ? !1 : y, r.lstat(g, (S, w) => {
      !S && w.isSymbolicLink() ? Promise.all([
        r.stat(_),
        r.stat(g)
      ]).then(([E, R]) => {
        if (p(E, R)) return x(null);
        m(_, g, y, x);
      }) : m(_, g, y, x);
    });
  }
  function m(_, g, y, x) {
    o(_, g, (S, w) => {
      if (S) return x(S);
      _ = w.toDst, l(w.toCwd, y, (E, R) => {
        if (E) return x(E);
        const N = t.dirname(g);
        f(N, (B, F) => {
          if (B) return x(B);
          if (F) return r.symlink(_, g, R, x);
          i(N, (U) => {
            if (U) return x(U);
            r.symlink(_, g, R, x);
          });
        });
      });
    });
  }
  function h(_, g, y) {
    let x;
    try {
      x = r.lstatSync(g);
    } catch {
    }
    if (x && x.isSymbolicLink()) {
      const R = r.statSync(_), N = r.statSync(g);
      if (p(R, N)) return;
    }
    const S = c(_, g);
    _ = S.toDst, y = d(S.toCwd, y);
    const w = t.dirname(g);
    return r.existsSync(w) || a(w), r.symlinkSync(_, g, y);
  }
  return Jl = {
    createSymlink: e(v),
    createSymlinkSync: h
  }, Jl;
}
var Ql, Wh;
function IT() {
  if (Wh) return Ql;
  Wh = 1;
  const { createFile: e, createFileSync: t } = /* @__PURE__ */ $T(), { createLink: r, createLinkSync: n } = /* @__PURE__ */ OT(), { createSymlink: i, createSymlinkSync: a } = /* @__PURE__ */ CT();
  return Ql = {
    // file
    createFile: e,
    createFileSync: t,
    ensureFile: e,
    ensureFileSync: t,
    // link
    createLink: r,
    createLinkSync: n,
    ensureLink: r,
    ensureLinkSync: n,
    // symlink
    createSymlink: i,
    createSymlinkSync: a,
    ensureSymlink: i,
    ensureSymlinkSync: a
  }, Ql;
}
var Zl, Xh;
function m0() {
  if (Xh) return Zl;
  Xh = 1;
  function e(r, { EOL: n = `
`, finalEOL: i = !0, replacer: a = null, spaces: s } = {}) {
    const o = i ? n : "";
    return JSON.stringify(r, a, s).replace(/\n/g, n) + o;
  }
  function t(r) {
    return Buffer.isBuffer(r) && (r = r.toString("utf8")), r.replace(/^\uFEFF/, "");
  }
  return Zl = { stringify: e, stripBom: t }, Zl;
}
var eu, Kh;
function bT() {
  if (Kh) return eu;
  Kh = 1;
  let e;
  try {
    e = Er();
  } catch {
    e = Kr;
  }
  const t = Cr(), { stringify: r, stripBom: n } = m0();
  async function i(l, d = {}) {
    typeof d == "string" && (d = { encoding: d });
    const f = d.fs || e, p = "throws" in d ? d.throws : !0;
    let v = await t.fromCallback(f.readFile)(l, d);
    v = n(v);
    let m;
    try {
      m = JSON.parse(v, d ? d.reviver : null);
    } catch (h) {
      if (p)
        throw h.message = `${l}: ${h.message}`, h;
      return null;
    }
    return m;
  }
  const a = t.fromPromise(i);
  function s(l, d = {}) {
    typeof d == "string" && (d = { encoding: d });
    const f = d.fs || e, p = "throws" in d ? d.throws : !0;
    try {
      let v = f.readFileSync(l, d);
      return v = n(v), JSON.parse(v, d.reviver);
    } catch (v) {
      if (p)
        throw v.message = `${l}: ${v.message}`, v;
      return null;
    }
  }
  async function o(l, d, f = {}) {
    const p = f.fs || e, v = r(d, f);
    await t.fromCallback(p.writeFile)(l, v, f);
  }
  const c = t.fromPromise(o);
  function u(l, d, f = {}) {
    const p = f.fs || e, v = r(d, f);
    return p.writeFileSync(l, v, f);
  }
  return eu = {
    readFile: a,
    readFileSync: s,
    writeFile: c,
    writeFileSync: u
  }, eu;
}
var tu, Yh;
function FT() {
  if (Yh) return tu;
  Yh = 1;
  const e = bT();
  return tu = {
    // jsonfile exports
    readJson: e.readFile,
    readJsonSync: e.readFileSync,
    writeJson: e.writeFile,
    writeJsonSync: e.writeFileSync
  }, tu;
}
var ru, Jh;
function g0() {
  if (Jh) return ru;
  Jh = 1;
  const e = Cr().fromCallback, t = Er(), r = vt, n = /* @__PURE__ */ cn(), i = _i().pathExists;
  function a(o, c, u, l) {
    typeof u == "function" && (l = u, u = "utf8");
    const d = r.dirname(o);
    i(d, (f, p) => {
      if (f) return l(f);
      if (p) return t.writeFile(o, c, u, l);
      n.mkdirs(d, (v) => {
        if (v) return l(v);
        t.writeFile(o, c, u, l);
      });
    });
  }
  function s(o, ...c) {
    const u = r.dirname(o);
    if (t.existsSync(u))
      return t.writeFileSync(o, ...c);
    n.mkdirsSync(u), t.writeFileSync(o, ...c);
  }
  return ru = {
    outputFile: e(a),
    outputFileSync: s
  }, ru;
}
var nu, Qh;
function DT() {
  if (Qh) return nu;
  Qh = 1;
  const { stringify: e } = m0(), { outputFile: t } = /* @__PURE__ */ g0();
  async function r(n, i, a = {}) {
    const s = e(i, a);
    await t(n, s, a);
  }
  return nu = r, nu;
}
var iu, Zh;
function kT() {
  if (Zh) return iu;
  Zh = 1;
  const { stringify: e } = m0(), { outputFileSync: t } = /* @__PURE__ */ g0();
  function r(n, i, a) {
    const s = e(i, a);
    t(n, s, a);
  }
  return iu = r, iu;
}
var au, ep;
function LT() {
  if (ep) return au;
  ep = 1;
  const e = Cr().fromPromise, t = /* @__PURE__ */ FT();
  return t.outputJson = e(/* @__PURE__ */ DT()), t.outputJsonSync = /* @__PURE__ */ kT(), t.outputJSON = t.outputJson, t.outputJSONSync = t.outputJsonSync, t.writeJSON = t.writeJson, t.writeJSONSync = t.writeJsonSync, t.readJSON = t.readJson, t.readJSONSync = t.readJsonSync, au = t, au;
}
var su, tp;
function MT() {
  if (tp) return su;
  tp = 1;
  const e = Er(), t = vt, r = p0().copy, n = Jc().remove, i = cn().mkdirp, a = _i().pathExists, s = /* @__PURE__ */ Qi();
  function o(f, p, v, m) {
    typeof v == "function" && (m = v, v = {}), v = v || {};
    const h = v.overwrite || v.clobber || !1;
    s.checkPaths(f, p, "move", v, (_, g) => {
      if (_) return m(_);
      const { srcStat: y, isChangingCase: x = !1 } = g;
      s.checkParentPaths(f, y, p, "move", (S) => {
        if (S) return m(S);
        if (c(p)) return u(f, p, h, x, m);
        i(t.dirname(p), (w) => w ? m(w) : u(f, p, h, x, m));
      });
    });
  }
  function c(f) {
    const p = t.dirname(f);
    return t.parse(p).root === p;
  }
  function u(f, p, v, m, h) {
    if (m) return l(f, p, v, h);
    if (v)
      return n(p, (_) => _ ? h(_) : l(f, p, v, h));
    a(p, (_, g) => _ ? h(_) : g ? h(new Error("dest already exists.")) : l(f, p, v, h));
  }
  function l(f, p, v, m) {
    e.rename(f, p, (h) => h ? h.code !== "EXDEV" ? m(h) : d(f, p, v, m) : m());
  }
  function d(f, p, v, m) {
    r(f, p, {
      overwrite: v,
      errorOnExist: !0
    }, (_) => _ ? m(_) : n(f, m));
  }
  return su = o, su;
}
var ou, rp;
function UT() {
  if (rp) return ou;
  rp = 1;
  const e = Er(), t = vt, r = p0().copySync, n = Jc().removeSync, i = cn().mkdirpSync, a = /* @__PURE__ */ Qi();
  function s(d, f, p) {
    p = p || {};
    const v = p.overwrite || p.clobber || !1, { srcStat: m, isChangingCase: h = !1 } = a.checkPathsSync(d, f, "move", p);
    return a.checkParentPathsSync(d, m, f, "move"), o(f) || i(t.dirname(f)), c(d, f, v, h);
  }
  function o(d) {
    const f = t.dirname(d);
    return t.parse(f).root === f;
  }
  function c(d, f, p, v) {
    if (v) return u(d, f, p);
    if (p)
      return n(f), u(d, f, p);
    if (e.existsSync(f)) throw new Error("dest already exists.");
    return u(d, f, p);
  }
  function u(d, f, p) {
    try {
      e.renameSync(d, f);
    } catch (v) {
      if (v.code !== "EXDEV") throw v;
      return l(d, f, p);
    }
  }
  function l(d, f, p) {
    return r(d, f, {
      overwrite: p,
      errorOnExist: !0
    }), n(d);
  }
  return ou = s, ou;
}
var cu, np;
function qT() {
  if (np) return cu;
  np = 1;
  const e = Cr().fromCallback;
  return cu = {
    move: e(/* @__PURE__ */ MT()),
    moveSync: /* @__PURE__ */ UT()
  }, cu;
}
var lu, ip;
function zn() {
  return ip || (ip = 1, lu = {
    // Export promiseified graceful-fs:
    .../* @__PURE__ */ Ji(),
    // Export extra methods:
    .../* @__PURE__ */ p0(),
    .../* @__PURE__ */ RT(),
    .../* @__PURE__ */ IT(),
    .../* @__PURE__ */ LT(),
    .../* @__PURE__ */ cn(),
    .../* @__PURE__ */ qT(),
    .../* @__PURE__ */ g0(),
    .../* @__PURE__ */ _i(),
    .../* @__PURE__ */ Jc()
  }), lu;
}
var fa = {}, ti = {}, uu = {}, ri = {}, ap;
function v0() {
  if (ap) return ri;
  ap = 1, Object.defineProperty(ri, "__esModule", { value: !0 }), ri.CancellationError = ri.CancellationToken = void 0;
  const e = Qy;
  let t = class extends e.EventEmitter {
    get cancelled() {
      return this._cancelled || this._parent != null && this._parent.cancelled;
    }
    set parent(i) {
      this.removeParentCancelHandler(), this._parent = i, this.parentCancelHandler = () => this.cancel(), this._parent.onCancel(this.parentCancelHandler);
    }
    // babel cannot compile ... correctly for super calls
    constructor(i) {
      super(), this.parentCancelHandler = null, this._parent = null, this._cancelled = !1, i != null && (this.parent = i);
    }
    cancel() {
      this._cancelled = !0, this.emit("cancel");
    }
    onCancel(i) {
      this.cancelled ? i() : this.once("cancel", i);
    }
    createPromise(i) {
      if (this.cancelled)
        return Promise.reject(new r());
      const a = () => {
        if (s != null)
          try {
            this.removeListener("cancel", s), s = null;
          } catch {
          }
      };
      let s = null;
      return new Promise((o, c) => {
        let u = null;
        if (s = () => {
          try {
            u != null && (u(), u = null);
          } finally {
            c(new r());
          }
        }, this.cancelled) {
          s();
          return;
        }
        this.onCancel(s), i(o, c, (l) => {
          u = l;
        });
      }).then((o) => (a(), o)).catch((o) => {
        throw a(), o;
      });
    }
    removeParentCancelHandler() {
      const i = this._parent;
      i != null && this.parentCancelHandler != null && (i.removeListener("cancel", this.parentCancelHandler), this.parentCancelHandler = null);
    }
    dispose() {
      try {
        this.removeParentCancelHandler();
      } finally {
        this.removeAllListeners(), this._parent = null;
      }
    }
  };
  ri.CancellationToken = t;
  class r extends Error {
    constructor() {
      super("cancelled");
    }
  }
  return ri.CancellationError = r, ri;
}
var ws = {}, sp;
function Qc() {
  if (sp) return ws;
  sp = 1, Object.defineProperty(ws, "__esModule", { value: !0 }), ws.newError = e;
  function e(t, r) {
    const n = new Error(t);
    return n.code = r, n;
  }
  return ws;
}
var er = {}, xs = { exports: {} }, Ts = { exports: {} }, fu, op;
function BT() {
  if (op) return fu;
  op = 1;
  var e = 1e3, t = e * 60, r = t * 60, n = r * 24, i = n * 7, a = n * 365.25;
  fu = function(l, d) {
    d = d || {};
    var f = typeof l;
    if (f === "string" && l.length > 0)
      return s(l);
    if (f === "number" && isFinite(l))
      return d.long ? c(l) : o(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(l)
    );
  };
  function s(l) {
    if (l = String(l), !(l.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (d) {
        var f = parseFloat(d[1]), p = (d[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return f * a;
          case "weeks":
          case "week":
          case "w":
            return f * i;
          case "days":
          case "day":
          case "d":
            return f * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return f * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return f * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return f * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return f;
          default:
            return;
        }
      }
    }
  }
  function o(l) {
    var d = Math.abs(l);
    return d >= n ? Math.round(l / n) + "d" : d >= r ? Math.round(l / r) + "h" : d >= t ? Math.round(l / t) + "m" : d >= e ? Math.round(l / e) + "s" : l + "ms";
  }
  function c(l) {
    var d = Math.abs(l);
    return d >= n ? u(l, d, n, "day") : d >= r ? u(l, d, r, "hour") : d >= t ? u(l, d, t, "minute") : d >= e ? u(l, d, e, "second") : l + " ms";
  }
  function u(l, d, f, p) {
    var v = d >= f * 1.5;
    return Math.round(l / f) + " " + p + (v ? "s" : "");
  }
  return fu;
}
var du, cp;
function iE() {
  if (cp) return du;
  cp = 1;
  function e(t) {
    n.debug = n, n.default = n, n.coerce = u, n.disable = o, n.enable = a, n.enabled = c, n.humanize = BT(), n.destroy = l, Object.keys(t).forEach((d) => {
      n[d] = t[d];
    }), n.names = [], n.skips = [], n.formatters = {};
    function r(d) {
      let f = 0;
      for (let p = 0; p < d.length; p++)
        f = (f << 5) - f + d.charCodeAt(p), f |= 0;
      return n.colors[Math.abs(f) % n.colors.length];
    }
    n.selectColor = r;
    function n(d) {
      let f, p = null, v, m;
      function h(..._) {
        if (!h.enabled)
          return;
        const g = h, y = Number(/* @__PURE__ */ new Date()), x = y - (f || y);
        g.diff = x, g.prev = f, g.curr = y, f = y, _[0] = n.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
        let S = 0;
        _[0] = _[0].replace(/%([a-zA-Z%])/g, (E, R) => {
          if (E === "%%")
            return "%";
          S++;
          const N = n.formatters[R];
          if (typeof N == "function") {
            const B = _[S];
            E = N.call(g, B), _.splice(S, 1), S--;
          }
          return E;
        }), n.formatArgs.call(g, _), (g.log || n.log).apply(g, _);
      }
      return h.namespace = d, h.useColors = n.useColors(), h.color = n.selectColor(d), h.extend = i, h.destroy = n.destroy, Object.defineProperty(h, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => p !== null ? p : (v !== n.namespaces && (v = n.namespaces, m = n.enabled(d)), m),
        set: (_) => {
          p = _;
        }
      }), typeof n.init == "function" && n.init(h), h;
    }
    function i(d, f) {
      const p = n(this.namespace + (typeof f > "u" ? ":" : f) + d);
      return p.log = this.log, p;
    }
    function a(d) {
      n.save(d), n.namespaces = d, n.names = [], n.skips = [];
      const f = (typeof d == "string" ? d : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const p of f)
        p[0] === "-" ? n.skips.push(p.slice(1)) : n.names.push(p);
    }
    function s(d, f) {
      let p = 0, v = 0, m = -1, h = 0;
      for (; p < d.length; )
        if (v < f.length && (f[v] === d[p] || f[v] === "*"))
          f[v] === "*" ? (m = v, h = p, v++) : (p++, v++);
        else if (m !== -1)
          v = m + 1, h++, p = h;
        else
          return !1;
      for (; v < f.length && f[v] === "*"; )
        v++;
      return v === f.length;
    }
    function o() {
      const d = [
        ...n.names,
        ...n.skips.map((f) => "-" + f)
      ].join(",");
      return n.enable(""), d;
    }
    function c(d) {
      for (const f of n.skips)
        if (s(d, f))
          return !1;
      for (const f of n.names)
        if (s(d, f))
          return !0;
      return !1;
    }
    function u(d) {
      return d instanceof Error ? d.stack || d.message : d;
    }
    function l() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return n.enable(n.load()), n;
  }
  return du = e, du;
}
var lp;
function jT() {
  return lp || (lp = 1, (function(e, t) {
    t.formatArgs = n, t.save = i, t.load = a, t.useColors = r, t.storage = s(), t.destroy = /* @__PURE__ */ (() => {
      let c = !1;
      return () => {
        c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let c;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (c = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(c[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(c) {
      if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const u = "color: " + this.color;
      c.splice(1, 0, u, "color: inherit");
      let l = 0, d = 0;
      c[0].replace(/%[a-zA-Z%]/g, (f) => {
        f !== "%%" && (l++, f === "%c" && (d = l));
      }), c.splice(d, 0, u);
    }
    t.log = console.debug || console.log || (() => {
    });
    function i(c) {
      try {
        c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function a() {
      let c;
      try {
        c = t.storage.getItem("debug") || t.storage.getItem("DEBUG");
      } catch {
      }
      return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
    }
    function s() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = iE()(t);
    const { formatters: o } = e.exports;
    o.j = function(c) {
      try {
        return JSON.stringify(c);
      } catch (u) {
        return "[UnexpectedJSONParseError]: " + u.message;
      }
    };
  })(Ts, Ts.exports)), Ts.exports;
}
var Ss = { exports: {} }, hu, up;
function VT() {
  return up || (up = 1, hu = (e, t = process.argv) => {
    const r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
    return n !== -1 && (i === -1 || n < i);
  }), hu;
}
var pu, fp;
function HT() {
  if (fp) return pu;
  fp = 1;
  const e = Yc, t = Zy, r = VT(), { env: n } = process;
  let i;
  r("no-color") || r("no-colors") || r("color=false") || r("color=never") ? i = 0 : (r("color") || r("colors") || r("color=true") || r("color=always")) && (i = 1), "FORCE_COLOR" in n && (n.FORCE_COLOR === "true" ? i = 1 : n.FORCE_COLOR === "false" ? i = 0 : i = n.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(n.FORCE_COLOR, 10), 3));
  function a(c) {
    return c === 0 ? !1 : {
      level: c,
      hasBasic: !0,
      has256: c >= 2,
      has16m: c >= 3
    };
  }
  function s(c, u) {
    if (i === 0)
      return 0;
    if (r("color=16m") || r("color=full") || r("color=truecolor"))
      return 3;
    if (r("color=256"))
      return 2;
    if (c && !u && i === void 0)
      return 0;
    const l = i || 0;
    if (n.TERM === "dumb")
      return l;
    if (process.platform === "win32") {
      const d = e.release().split(".");
      return Number(d[0]) >= 10 && Number(d[2]) >= 10586 ? Number(d[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in n)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((d) => d in n) || n.CI_NAME === "codeship" ? 1 : l;
    if ("TEAMCITY_VERSION" in n)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(n.TEAMCITY_VERSION) ? 1 : 0;
    if (n.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in n) {
      const d = parseInt((n.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (n.TERM_PROGRAM) {
        case "iTerm.app":
          return d >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(n.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(n.TERM) || "COLORTERM" in n ? 1 : l;
  }
  function o(c) {
    const u = s(c, c && c.isTTY);
    return a(u);
  }
  return pu = {
    supportsColor: o,
    stdout: a(s(!0, t.isatty(1))),
    stderr: a(s(!0, t.isatty(2)))
  }, pu;
}
var dp;
function GT() {
  return dp || (dp = 1, (function(e, t) {
    const r = Zy, n = h0;
    t.init = l, t.log = o, t.formatArgs = a, t.save = c, t.load = u, t.useColors = i, t.destroy = n.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), t.colors = [6, 2, 3, 4, 5, 1];
    try {
      const f = HT();
      f && (f.stderr || f).level >= 2 && (t.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    t.inspectOpts = Object.keys(process.env).filter((f) => /^debug_/i.test(f)).reduce((f, p) => {
      const v = p.substring(6).toLowerCase().replace(/_([a-z])/g, (h, _) => _.toUpperCase());
      let m = process.env[p];
      return /^(yes|on|true|enabled)$/i.test(m) ? m = !0 : /^(no|off|false|disabled)$/i.test(m) ? m = !1 : m === "null" ? m = null : m = Number(m), f[v] = m, f;
    }, {});
    function i() {
      return "colors" in t.inspectOpts ? !!t.inspectOpts.colors : r.isatty(process.stderr.fd);
    }
    function a(f) {
      const { namespace: p, useColors: v } = this;
      if (v) {
        const m = this.color, h = "\x1B[3" + (m < 8 ? m : "8;5;" + m), _ = `  ${h};1m${p} \x1B[0m`;
        f[0] = _ + f[0].split(`
`).join(`
` + _), f.push(h + "m+" + e.exports.humanize(this.diff) + "\x1B[0m");
      } else
        f[0] = s() + p + " " + f[0];
    }
    function s() {
      return t.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function o(...f) {
      return process.stderr.write(n.formatWithOptions(t.inspectOpts, ...f) + `
`);
    }
    function c(f) {
      f ? process.env.DEBUG = f : delete process.env.DEBUG;
    }
    function u() {
      return process.env.DEBUG;
    }
    function l(f) {
      f.inspectOpts = {};
      const p = Object.keys(t.inspectOpts);
      for (let v = 0; v < p.length; v++)
        f.inspectOpts[p[v]] = t.inspectOpts[p[v]];
    }
    e.exports = iE()(t);
    const { formatters: d } = e.exports;
    d.o = function(f) {
      return this.inspectOpts.colors = this.useColors, n.inspect(f, this.inspectOpts).split(`
`).map((p) => p.trim()).join(" ");
    }, d.O = function(f) {
      return this.inspectOpts.colors = this.useColors, n.inspect(f, this.inspectOpts);
    };
  })(Ss, Ss.exports)), Ss.exports;
}
var hp;
function zT() {
  return hp || (hp = 1, typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? xs.exports = jT() : xs.exports = GT()), xs.exports;
}
var da = {}, pp;
function aE() {
  if (pp) return da;
  pp = 1, Object.defineProperty(da, "__esModule", { value: !0 }), da.ProgressCallbackTransform = void 0;
  const e = es;
  let t = class extends e.Transform {
    constructor(n, i, a) {
      super(), this.total = n, this.cancellationToken = i, this.onProgress = a, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.nextUpdate = this.start + 1e3;
    }
    _transform(n, i, a) {
      if (this.cancellationToken.cancelled) {
        a(new Error("cancelled"), null);
        return;
      }
      this.transferred += n.length, this.delta += n.length;
      const s = Date.now();
      s >= this.nextUpdate && this.transferred !== this.total && (this.nextUpdate = s + 1e3, this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.total * 100,
        bytesPerSecond: Math.round(this.transferred / ((s - this.start) / 1e3))
      }), this.delta = 0), a(null, n);
    }
    _flush(n) {
      if (this.cancellationToken.cancelled) {
        n(new Error("cancelled"));
        return;
      }
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.total,
        percent: 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      }), this.delta = 0, n(null);
    }
  };
  return da.ProgressCallbackTransform = t, da;
}
var mp;
function WT() {
  if (mp) return er;
  mp = 1, Object.defineProperty(er, "__esModule", { value: !0 }), er.DigestTransform = er.HttpExecutor = er.HttpError = void 0, er.createHttpError = u, er.parseJson = f, er.configureRequestOptionsFromUrl = v, er.configureRequestUrl = m, er.safeGetHeader = g, er.configureRequestOptions = x, er.safeStringifyJson = S;
  const e = ts, t = zT(), r = Kr, n = es, i = Yi, a = v0(), s = Qc(), o = aE(), c = (0, t.default)("electron-builder");
  function u(w, E = null) {
    return new d(w.statusCode || -1, `${w.statusCode} ${w.statusMessage}` + (E == null ? "" : `
` + JSON.stringify(E, null, "  ")) + `
Headers: ` + S(w.headers), E);
  }
  const l = /* @__PURE__ */ new Map([
    [429, "Too many requests"],
    [400, "Bad request"],
    [403, "Forbidden"],
    [404, "Not found"],
    [405, "Method not allowed"],
    [406, "Not acceptable"],
    [408, "Request timeout"],
    [413, "Request entity too large"],
    [500, "Internal server error"],
    [502, "Bad gateway"],
    [503, "Service unavailable"],
    [504, "Gateway timeout"],
    [505, "HTTP version not supported"]
  ]);
  class d extends Error {
    constructor(E, R = `HTTP error: ${l.get(E) || E}`, N = null) {
      super(R), this.statusCode = E, this.description = N, this.name = "HttpError", this.code = `HTTP_ERROR_${E}`;
    }
    isServerError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
  }
  er.HttpError = d;
  function f(w) {
    return w.then((E) => E == null || E.length === 0 ? null : JSON.parse(E));
  }
  class p {
    constructor() {
      this.maxRedirects = 10;
    }
    request(E, R = new a.CancellationToken(), N) {
      x(E);
      const B = N == null ? void 0 : JSON.stringify(N), F = B ? Buffer.from(B) : void 0;
      if (F != null) {
        c(B);
        const { headers: U, ...G } = E;
        E = {
          method: "post",
          headers: {
            "Content-Type": "application/json",
            "Content-Length": F.length,
            ...U
          },
          ...G
        };
      }
      return this.doApiRequest(E, R, (U) => U.end(F));
    }
    doApiRequest(E, R, N, B = 0) {
      return c.enabled && c(`Request: ${S(E)}`), R.createPromise((F, U, G) => {
        const M = this.createRequest(E, (V) => {
          try {
            this.handleResponse(V, E, R, F, U, B, N);
          } catch (ie) {
            U(ie);
          }
        });
        this.addErrorAndTimeoutHandlers(M, U, E.timeout), this.addRedirectHandlers(M, E, U, B, (V) => {
          this.doApiRequest(V, R, N, B).then(F).catch(U);
        }), N(M, U), G(() => M.abort());
      });
    }
    // noinspection JSUnusedLocalSymbols
    // eslint-disable-next-line
    addRedirectHandlers(E, R, N, B, F) {
    }
    addErrorAndTimeoutHandlers(E, R, N = 60 * 1e3) {
      this.addTimeOutHandler(E, R, N), E.on("error", R), E.on("aborted", () => {
        R(new Error("Request has been aborted by the server"));
      });
    }
    handleResponse(E, R, N, B, F, U, G) {
      var M;
      if (c.enabled && c(`Response: ${E.statusCode} ${E.statusMessage}, request options: ${S(R)}`), E.statusCode === 404) {
        F(u(E, `method: ${R.method || "GET"} url: ${R.protocol || "https:"}//${R.hostname}${R.port ? `:${R.port}` : ""}${R.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
        return;
      } else if (E.statusCode === 204) {
        B();
        return;
      }
      const V = (M = E.statusCode) !== null && M !== void 0 ? M : 0, ie = V >= 300 && V < 400, W = g(E, "location");
      if (ie && W != null) {
        if (U > this.maxRedirects) {
          F(this.createMaxRedirectError());
          return;
        }
        this.doApiRequest(p.prepareRedirectUrlOptions(W, R), N, G, U).then(B).catch(F);
        return;
      }
      E.setEncoding("utf8");
      let ae = "";
      E.on("error", F), E.on("data", (se) => ae += se), E.on("end", () => {
        try {
          if (E.statusCode != null && E.statusCode >= 400) {
            const se = g(E, "content-type"), X = se != null && (Array.isArray(se) ? se.find((k) => k.includes("json")) != null : se.includes("json"));
            F(u(E, `method: ${R.method || "GET"} url: ${R.protocol || "https:"}//${R.hostname}${R.port ? `:${R.port}` : ""}${R.path}

          Data:
          ${X ? JSON.stringify(JSON.parse(ae)) : ae}
          `));
          } else
            B(ae.length === 0 ? null : ae);
        } catch (se) {
          F(se);
        }
      });
    }
    async downloadToBuffer(E, R) {
      return await R.cancellationToken.createPromise((N, B, F) => {
        const U = [], G = {
          headers: R.headers || void 0,
          // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
          redirect: "manual"
        };
        m(E, G), x(G), this.doDownload(G, {
          destination: null,
          options: R,
          onCancel: F,
          callback: (M) => {
            M == null ? N(Buffer.concat(U)) : B(M);
          },
          responseHandler: (M, V) => {
            let ie = 0;
            M.on("data", (W) => {
              if (ie += W.length, ie > 524288e3) {
                V(new Error("Maximum allowed size is 500 MB"));
                return;
              }
              U.push(W);
            }), M.on("end", () => {
              V(null);
            });
          }
        }, 0);
      });
    }
    doDownload(E, R, N) {
      const B = this.createRequest(E, (F) => {
        if (F.statusCode >= 400) {
          R.callback(new Error(`Cannot download "${E.protocol || "https:"}//${E.hostname}${E.path}", status ${F.statusCode}: ${F.statusMessage}`));
          return;
        }
        F.on("error", R.callback);
        const U = g(F, "location");
        if (U != null) {
          N < this.maxRedirects ? this.doDownload(p.prepareRedirectUrlOptions(U, E), R, N++) : R.callback(this.createMaxRedirectError());
          return;
        }
        R.responseHandler == null ? y(R, F) : R.responseHandler(F, R.callback);
      });
      this.addErrorAndTimeoutHandlers(B, R.callback, E.timeout), this.addRedirectHandlers(B, E, R.callback, N, (F) => {
        this.doDownload(F, R, N++);
      }), B.end();
    }
    createMaxRedirectError() {
      return new Error(`Too many redirects (> ${this.maxRedirects})`);
    }
    addTimeOutHandler(E, R, N) {
      E.on("socket", (B) => {
        B.setTimeout(N, () => {
          E.abort(), R(new Error("Request timed out"));
        });
      });
    }
    static prepareRedirectUrlOptions(E, R) {
      const N = v(E, { ...R }), B = N.headers;
      if (B?.authorization) {
        const F = new i.URL(E);
        (F.hostname.endsWith(".amazonaws.com") || F.searchParams.has("X-Amz-Credential")) && delete B.authorization;
      }
      return N;
    }
    static retryOnServerError(E, R = 3) {
      for (let N = 0; ; N++)
        try {
          return E();
        } catch (B) {
          if (N < R && (B instanceof d && B.isServerError() || B.code === "EPIPE"))
            continue;
          throw B;
        }
    }
  }
  er.HttpExecutor = p;
  function v(w, E) {
    const R = x(E);
    return m(new i.URL(w), R), R;
  }
  function m(w, E) {
    E.protocol = w.protocol, E.hostname = w.hostname, w.port ? E.port = w.port : E.port && delete E.port, E.path = w.pathname + w.search;
  }
  class h extends n.Transform {
    // noinspection JSUnusedGlobalSymbols
    get actual() {
      return this._actual;
    }
    constructor(E, R = "sha512", N = "base64") {
      super(), this.expected = E, this.algorithm = R, this.encoding = N, this._actual = null, this.isValidateOnEnd = !0, this.digester = (0, e.createHash)(R);
    }
    // noinspection JSUnusedGlobalSymbols
    _transform(E, R, N) {
      this.digester.update(E), N(null, E);
    }
    // noinspection JSUnusedGlobalSymbols
    _flush(E) {
      if (this._actual = this.digester.digest(this.encoding), this.isValidateOnEnd)
        try {
          this.validate();
        } catch (R) {
          E(R);
          return;
        }
      E(null);
    }
    validate() {
      if (this._actual == null)
        throw (0, s.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
      if (this._actual !== this.expected)
        throw (0, s.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
      return null;
    }
  }
  er.DigestTransform = h;
  function _(w, E, R) {
    return w != null && E != null && w !== E ? (R(new Error(`checksum mismatch: expected ${E} but got ${w} (X-Checksum-Sha2 header)`)), !1) : !0;
  }
  function g(w, E) {
    const R = w.headers[E];
    return R == null ? null : Array.isArray(R) ? R.length === 0 ? null : R[R.length - 1] : R;
  }
  function y(w, E) {
    if (!_(g(E, "X-Checksum-Sha2"), w.options.sha2, w.callback))
      return;
    const R = [];
    if (w.options.onProgress != null) {
      const U = g(E, "content-length");
      U != null && R.push(new o.ProgressCallbackTransform(parseInt(U, 10), w.options.cancellationToken, w.options.onProgress));
    }
    const N = w.options.sha512;
    N != null ? R.push(new h(N, "sha512", N.length === 128 && !N.includes("+") && !N.includes("Z") && !N.includes("=") ? "hex" : "base64")) : w.options.sha2 != null && R.push(new h(w.options.sha2, "sha256", "hex"));
    const B = (0, r.createWriteStream)(w.destination);
    R.push(B);
    let F = E;
    for (const U of R)
      U.on("error", (G) => {
        B.close(), w.options.cancellationToken.cancelled || w.callback(G);
      }), F = F.pipe(U);
    B.on("finish", () => {
      B.close(w.callback);
    });
  }
  function x(w, E, R) {
    R != null && (w.method = R), w.headers = { ...w.headers };
    const N = w.headers;
    return E != null && (N.authorization = E.startsWith("Basic") || E.startsWith("Bearer") ? E : `token ${E}`), N["User-Agent"] == null && (N["User-Agent"] = "electron-builder"), (R == null || R === "GET" || N["Cache-Control"] == null) && (N["Cache-Control"] = "no-cache"), w.protocol == null && process.versions.electron != null && (w.protocol = "https:"), w;
  }
  function S(w, E) {
    return JSON.stringify(w, (R, N) => R.endsWith("Authorization") || R.endsWith("authorization") || R.endsWith("Password") || R.endsWith("PASSWORD") || R.endsWith("Token") || R.includes("password") || R.includes("token") || E != null && E.has(R) ? "<stripped sensitive data>" : N, 2);
  }
  return er;
}
var ha = {}, gp;
function XT() {
  if (gp) return ha;
  gp = 1, Object.defineProperty(ha, "__esModule", { value: !0 }), ha.MemoLazy = void 0;
  let e = class {
    constructor(n, i) {
      this.selector = n, this.creator = i, this.selected = void 0, this._value = void 0;
    }
    get hasValue() {
      return this._value !== void 0;
    }
    get value() {
      const n = this.selector();
      if (this._value !== void 0 && t(this.selected, n))
        return this._value;
      this.selected = n;
      const i = this.creator(n);
      return this.value = i, i;
    }
    set value(n) {
      this._value = n;
    }
  };
  ha.MemoLazy = e;
  function t(r, n) {
    if (typeof r == "object" && r !== null && (typeof n == "object" && n !== null)) {
      const s = Object.keys(r), o = Object.keys(n);
      return s.length === o.length && s.every((c) => t(r[c], n[c]));
    }
    return r === n;
  }
  return ha;
}
var pa = {}, vp;
function KT() {
  if (vp) return pa;
  vp = 1, Object.defineProperty(pa, "__esModule", { value: !0 }), pa.githubUrl = e, pa.getS3LikeProviderBaseUrl = t;
  function e(a, s = "github.com") {
    return `${a.protocol || "https"}://${a.host || s}`;
  }
  function t(a) {
    const s = a.provider;
    if (s === "s3")
      return r(a);
    if (s === "spaces")
      return i(a);
    throw new Error(`Not supported provider: ${s}`);
  }
  function r(a) {
    let s;
    if (a.accelerate == !0)
      s = `https://${a.bucket}.s3-accelerate.amazonaws.com`;
    else if (a.endpoint != null)
      s = `${a.endpoint}/${a.bucket}`;
    else if (a.bucket.includes(".")) {
      if (a.region == null)
        throw new Error(`Bucket name "${a.bucket}" includes a dot, but S3 region is missing`);
      a.region === "us-east-1" ? s = `https://s3.amazonaws.com/${a.bucket}` : s = `https://s3-${a.region}.amazonaws.com/${a.bucket}`;
    } else a.region === "cn-north-1" ? s = `https://${a.bucket}.s3.${a.region}.amazonaws.com.cn` : s = `https://${a.bucket}.s3.amazonaws.com`;
    return n(s, a.path);
  }
  function n(a, s) {
    return s != null && s.length > 0 && (s.startsWith("/") || (a += "/"), a += s), a;
  }
  function i(a) {
    if (a.name == null)
      throw new Error("name is missing");
    if (a.region == null)
      throw new Error("region is missing");
    return n(`https://${a.name}.${a.region}.digitaloceanspaces.com`, a.path);
  }
  return pa;
}
var As = {}, _p;
function YT() {
  if (_p) return As;
  _p = 1, Object.defineProperty(As, "__esModule", { value: !0 }), As.retry = t;
  const e = v0();
  async function t(r, n, i, a = 0, s = 0, o) {
    var c;
    const u = new e.CancellationToken();
    try {
      return await r();
    } catch (l) {
      if ((!((c = o?.(l)) !== null && c !== void 0) || c) && n > 0 && !u.cancelled)
        return await new Promise((d) => setTimeout(d, i + a * s)), await t(r, n - 1, i, a, s + 1, o);
      throw l;
    }
  }
  return As;
}
var Rs = {}, yp;
function JT() {
  if (yp) return Rs;
  yp = 1, Object.defineProperty(Rs, "__esModule", { value: !0 }), Rs.parseDn = e;
  function e(t) {
    let r = !1, n = null, i = "", a = 0;
    t = t.trim();
    const s = /* @__PURE__ */ new Map();
    for (let o = 0; o <= t.length; o++) {
      if (o === t.length) {
        n !== null && s.set(n, i);
        break;
      }
      const c = t[o];
      if (r) {
        if (c === '"') {
          r = !1;
          continue;
        }
      } else {
        if (c === '"') {
          r = !0;
          continue;
        }
        if (c === "\\") {
          o++;
          const u = parseInt(t.slice(o, o + 2), 16);
          Number.isNaN(u) ? i += t[o] : (o++, i += String.fromCharCode(u));
          continue;
        }
        if (n === null && c === "=") {
          n = i, i = "";
          continue;
        }
        if (c === "," || c === ";" || c === "+") {
          n !== null && s.set(n, i), n = null, i = "";
          continue;
        }
      }
      if (c === " " && !r) {
        if (i.length === 0)
          continue;
        if (o > a) {
          let u = o;
          for (; t[u] === " "; )
            u++;
          a = u;
        }
        if (a >= t.length || t[a] === "," || t[a] === ";" || n === null && t[a] === "=" || n !== null && t[a] === "+") {
          o = a - 1;
          continue;
        }
      }
      i += c;
    }
    return s;
  }
  return Rs;
}
var ni = {}, Ep;
function QT() {
  if (Ep) return ni;
  Ep = 1, Object.defineProperty(ni, "__esModule", { value: !0 }), ni.nil = ni.UUID = void 0;
  const e = ts, t = Qc(), r = "options.name must be either a string or a Buffer", n = (0, e.randomBytes)(16);
  n[0] = n[0] | 1;
  const i = {}, a = [];
  for (let d = 0; d < 256; d++) {
    const f = (d + 256).toString(16).substr(1);
    i[f] = d, a[d] = f;
  }
  class s {
    constructor(f) {
      this.ascii = null, this.binary = null;
      const p = s.check(f);
      if (!p)
        throw new Error("not a UUID");
      this.version = p.version, p.format === "ascii" ? this.ascii = f : this.binary = f;
    }
    static v5(f, p) {
      return u(f, "sha1", 80, p);
    }
    toString() {
      return this.ascii == null && (this.ascii = l(this.binary)), this.ascii;
    }
    inspect() {
      return `UUID v${this.version} ${this.toString()}`;
    }
    static check(f, p = 0) {
      if (typeof f == "string")
        return f = f.toLowerCase(), /^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(f) ? f === "00000000-0000-0000-0000-000000000000" ? { version: void 0, variant: "nil", format: "ascii" } : {
          version: (i[f[14] + f[15]] & 240) >> 4,
          variant: o((i[f[19] + f[20]] & 224) >> 5),
          format: "ascii"
        } : !1;
      if (Buffer.isBuffer(f)) {
        if (f.length < p + 16)
          return !1;
        let v = 0;
        for (; v < 16 && f[p + v] === 0; v++)
          ;
        return v === 16 ? { version: void 0, variant: "nil", format: "binary" } : {
          version: (f[p + 6] & 240) >> 4,
          variant: o((f[p + 8] & 224) >> 5),
          format: "binary"
        };
      }
      throw (0, t.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
    }
    // read stringified uuid into a Buffer
    static parse(f) {
      const p = Buffer.allocUnsafe(16);
      let v = 0;
      for (let m = 0; m < 16; m++)
        p[m] = i[f[v++] + f[v++]], (m === 3 || m === 5 || m === 7 || m === 9) && (v += 1);
      return p;
    }
  }
  ni.UUID = s, s.OID = s.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
  function o(d) {
    switch (d) {
      case 0:
      case 1:
      case 3:
        return "ncs";
      case 4:
      case 5:
        return "rfc4122";
      case 6:
        return "microsoft";
      default:
        return "future";
    }
  }
  var c;
  (function(d) {
    d[d.ASCII = 0] = "ASCII", d[d.BINARY = 1] = "BINARY", d[d.OBJECT = 2] = "OBJECT";
  })(c || (c = {}));
  function u(d, f, p, v, m = c.ASCII) {
    const h = (0, e.createHash)(f);
    if (typeof d != "string" && !Buffer.isBuffer(d))
      throw (0, t.newError)(r, "ERR_INVALID_UUID_NAME");
    h.update(v), h.update(d);
    const g = h.digest();
    let y;
    switch (m) {
      case c.BINARY:
        g[6] = g[6] & 15 | p, g[8] = g[8] & 63 | 128, y = g;
        break;
      case c.OBJECT:
        g[6] = g[6] & 15 | p, g[8] = g[8] & 63 | 128, y = new s(g);
        break;
      default:
        y = a[g[0]] + a[g[1]] + a[g[2]] + a[g[3]] + "-" + a[g[4]] + a[g[5]] + "-" + a[g[6] & 15 | p] + a[g[7]] + "-" + a[g[8] & 63 | 128] + a[g[9]] + "-" + a[g[10]] + a[g[11]] + a[g[12]] + a[g[13]] + a[g[14]] + a[g[15]];
        break;
    }
    return y;
  }
  function l(d) {
    return a[d[0]] + a[d[1]] + a[d[2]] + a[d[3]] + "-" + a[d[4]] + a[d[5]] + "-" + a[d[6]] + a[d[7]] + "-" + a[d[8]] + a[d[9]] + "-" + a[d[10]] + a[d[11]] + a[d[12]] + a[d[13]] + a[d[14]] + a[d[15]];
  }
  return ni.nil = new s("00000000-0000-0000-0000-000000000000"), ni;
}
var $i = {}, mu = {}, wp;
function ZT() {
  return wp || (wp = 1, (function(e) {
    (function(t) {
      t.parser = function(b, P) {
        return new n(b, P);
      }, t.SAXParser = n, t.SAXStream = l, t.createStream = u, t.MAX_BUFFER_LENGTH = 64 * 1024;
      var r = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      t.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function n(b, P) {
        if (!(this instanceof n))
          return new n(b, P);
        var te = this;
        a(te), te.q = te.c = "", te.bufferCheckPosition = t.MAX_BUFFER_LENGTH, te.opt = P || {}, te.opt.lowercase = te.opt.lowercase || te.opt.lowercasetags, te.looseCase = te.opt.lowercase ? "toLowerCase" : "toUpperCase", te.tags = [], te.closed = te.closedRoot = te.sawRoot = !1, te.tag = te.error = null, te.strict = !!b, te.noscript = !!(b || te.opt.noscript), te.state = N.BEGIN, te.strictEntities = te.opt.strictEntities, te.ENTITIES = te.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), te.attribList = [], te.opt.xmlns && (te.ns = Object.create(m)), te.opt.unquotedAttributeValues === void 0 && (te.opt.unquotedAttributeValues = !b), te.trackPosition = te.opt.position !== !1, te.trackPosition && (te.position = te.line = te.column = 0), F(te, "onready");
      }
      Object.create || (Object.create = function(b) {
        function P() {
        }
        P.prototype = b;
        var te = new P();
        return te;
      }), Object.keys || (Object.keys = function(b) {
        var P = [];
        for (var te in b) b.hasOwnProperty(te) && P.push(te);
        return P;
      });
      function i(b) {
        for (var P = Math.max(t.MAX_BUFFER_LENGTH, 10), te = 0, H = 0, D = r.length; H < D; H++) {
          var q = b[r[H]].length;
          if (q > P)
            switch (r[H]) {
              case "textNode":
                G(b);
                break;
              case "cdata":
                U(b, "oncdata", b.cdata), b.cdata = "";
                break;
              case "script":
                U(b, "onscript", b.script), b.script = "";
                break;
              default:
                V(b, "Max buffer length exceeded: " + r[H]);
            }
          te = Math.max(te, q);
        }
        var J = t.MAX_BUFFER_LENGTH - te;
        b.bufferCheckPosition = J + b.position;
      }
      function a(b) {
        for (var P = 0, te = r.length; P < te; P++)
          b[r[P]] = "";
      }
      function s(b) {
        G(b), b.cdata !== "" && (U(b, "oncdata", b.cdata), b.cdata = ""), b.script !== "" && (U(b, "onscript", b.script), b.script = "");
      }
      n.prototype = {
        end: function() {
          ie(this);
        },
        write: L,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          s(this);
        }
      };
      var o;
      try {
        o = require("stream").Stream;
      } catch {
        o = function() {
        };
      }
      o || (o = function() {
      });
      var c = t.EVENTS.filter(function(b) {
        return b !== "error" && b !== "end";
      });
      function u(b, P) {
        return new l(b, P);
      }
      function l(b, P) {
        if (!(this instanceof l))
          return new l(b, P);
        o.apply(this), this._parser = new n(b, P), this.writable = !0, this.readable = !0;
        var te = this;
        this._parser.onend = function() {
          te.emit("end");
        }, this._parser.onerror = function(H) {
          te.emit("error", H), te._parser.error = null;
        }, this._decoder = null, c.forEach(function(H) {
          Object.defineProperty(te, "on" + H, {
            get: function() {
              return te._parser["on" + H];
            },
            set: function(D) {
              if (!D)
                return te.removeAllListeners(H), te._parser["on" + H] = D, D;
              te.on(H, D);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      l.prototype = Object.create(o.prototype, {
        constructor: {
          value: l
        }
      }), l.prototype.write = function(b) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(b)) {
          if (!this._decoder) {
            var P = gT.StringDecoder;
            this._decoder = new P("utf8");
          }
          b = this._decoder.write(b);
        }
        return this._parser.write(b.toString()), this.emit("data", b), !0;
      }, l.prototype.end = function(b) {
        return b && b.length && this.write(b), this._parser.end(), !0;
      }, l.prototype.on = function(b, P) {
        var te = this;
        return !te._parser["on" + b] && c.indexOf(b) !== -1 && (te._parser["on" + b] = function() {
          var H = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          H.splice(0, 0, b), te.emit.apply(te, H);
        }), o.prototype.on.call(te, b, P);
      };
      var d = "[CDATA[", f = "DOCTYPE", p = "http://www.w3.org/XML/1998/namespace", v = "http://www.w3.org/2000/xmlns/", m = { xml: p, xmlns: v }, h = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, _ = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, g = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function x(b) {
        return b === " " || b === `
` || b === "\r" || b === "	";
      }
      function S(b) {
        return b === '"' || b === "'";
      }
      function w(b) {
        return b === ">" || x(b);
      }
      function E(b, P) {
        return b.test(P);
      }
      function R(b, P) {
        return !E(b, P);
      }
      var N = 0;
      t.STATE = {
        BEGIN: N++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: N++,
        // leading whitespace
        TEXT: N++,
        // general stuff
        TEXT_ENTITY: N++,
        // &amp and such.
        OPEN_WAKA: N++,
        // <
        SGML_DECL: N++,
        // <!BLARG
        SGML_DECL_QUOTED: N++,
        // <!BLARG foo "bar
        DOCTYPE: N++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: N++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: N++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: N++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: N++,
        // <!-
        COMMENT: N++,
        // <!--
        COMMENT_ENDING: N++,
        // <!-- blah -
        COMMENT_ENDED: N++,
        // <!-- blah --
        CDATA: N++,
        // <![CDATA[ something
        CDATA_ENDING: N++,
        // ]
        CDATA_ENDING_2: N++,
        // ]]
        PROC_INST: N++,
        // <?hi
        PROC_INST_BODY: N++,
        // <?hi there
        PROC_INST_ENDING: N++,
        // <?hi "there" ?
        OPEN_TAG: N++,
        // <strong
        OPEN_TAG_SLASH: N++,
        // <strong /
        ATTRIB: N++,
        // <a
        ATTRIB_NAME: N++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: N++,
        // <a foo _
        ATTRIB_VALUE: N++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: N++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: N++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: N++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: N++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: N++,
        // <foo bar=&quot
        CLOSE_TAG: N++,
        // </a
        CLOSE_TAG_SAW_WHITE: N++,
        // </a   >
        SCRIPT: N++,
        // <script> ...
        SCRIPT_ENDING: N++
        // <script> ... <
      }, t.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, t.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(t.ENTITIES).forEach(function(b) {
        var P = t.ENTITIES[b], te = typeof P == "number" ? String.fromCharCode(P) : P;
        t.ENTITIES[b] = te;
      });
      for (var B in t.STATE)
        t.STATE[t.STATE[B]] = B;
      N = t.STATE;
      function F(b, P, te) {
        b[P] && b[P](te);
      }
      function U(b, P, te) {
        b.textNode && G(b), F(b, P, te);
      }
      function G(b) {
        b.textNode = M(b.opt, b.textNode), b.textNode && F(b, "ontext", b.textNode), b.textNode = "";
      }
      function M(b, P) {
        return b.trim && (P = P.trim()), b.normalize && (P = P.replace(/\s+/g, " ")), P;
      }
      function V(b, P) {
        return G(b), b.trackPosition && (P += `
Line: ` + b.line + `
Column: ` + b.column + `
Char: ` + b.c), P = new Error(P), b.error = P, F(b, "onerror", P), b;
      }
      function ie(b) {
        return b.sawRoot && !b.closedRoot && W(b, "Unclosed root tag"), b.state !== N.BEGIN && b.state !== N.BEGIN_WHITESPACE && b.state !== N.TEXT && V(b, "Unexpected end"), G(b), b.c = "", b.closed = !0, F(b, "onend"), n.call(b, b.strict, b.opt), b;
      }
      function W(b, P) {
        if (typeof b != "object" || !(b instanceof n))
          throw new Error("bad call to strictFail");
        b.strict && V(b, P);
      }
      function ae(b) {
        b.strict || (b.tagName = b.tagName[b.looseCase]());
        var P = b.tags[b.tags.length - 1] || b, te = b.tag = { name: b.tagName, attributes: {} };
        b.opt.xmlns && (te.ns = P.ns), b.attribList.length = 0, U(b, "onopentagstart", te);
      }
      function se(b, P) {
        var te = b.indexOf(":"), H = te < 0 ? ["", b] : b.split(":"), D = H[0], q = H[1];
        return P && b === "xmlns" && (D = "xmlns", q = ""), { prefix: D, local: q };
      }
      function X(b) {
        if (b.strict || (b.attribName = b.attribName[b.looseCase]()), b.attribList.indexOf(b.attribName) !== -1 || b.tag.attributes.hasOwnProperty(b.attribName)) {
          b.attribName = b.attribValue = "";
          return;
        }
        if (b.opt.xmlns) {
          var P = se(b.attribName, !0), te = P.prefix, H = P.local;
          if (te === "xmlns")
            if (H === "xml" && b.attribValue !== p)
              W(
                b,
                "xml: prefix must be bound to " + p + `
Actual: ` + b.attribValue
              );
            else if (H === "xmlns" && b.attribValue !== v)
              W(
                b,
                "xmlns: prefix must be bound to " + v + `
Actual: ` + b.attribValue
              );
            else {
              var D = b.tag, q = b.tags[b.tags.length - 1] || b;
              D.ns === q.ns && (D.ns = Object.create(q.ns)), D.ns[H] = b.attribValue;
            }
          b.attribList.push([b.attribName, b.attribValue]);
        } else
          b.tag.attributes[b.attribName] = b.attribValue, U(b, "onattribute", {
            name: b.attribName,
            value: b.attribValue
          });
        b.attribName = b.attribValue = "";
      }
      function k(b, P) {
        if (b.opt.xmlns) {
          var te = b.tag, H = se(b.tagName);
          te.prefix = H.prefix, te.local = H.local, te.uri = te.ns[H.prefix] || "", te.prefix && !te.uri && (W(
            b,
            "Unbound namespace prefix: " + JSON.stringify(b.tagName)
          ), te.uri = H.prefix);
          var D = b.tags[b.tags.length - 1] || b;
          te.ns && D.ns !== te.ns && Object.keys(te.ns).forEach(function(O) {
            U(b, "onopennamespace", {
              prefix: O,
              uri: te.ns[O]
            });
          });
          for (var q = 0, J = b.attribList.length; q < J; q++) {
            var ne = b.attribList[q], ce = ne[0], Ee = ne[1], ge = se(ce, !0), Ge = ge.prefix, ze = ge.local, Xe = Ge === "" ? "" : te.ns[Ge] || "", He = {
              name: ce,
              value: Ee,
              prefix: Ge,
              local: ze,
              uri: Xe
            };
            Ge && Ge !== "xmlns" && !Xe && (W(
              b,
              "Unbound namespace prefix: " + JSON.stringify(Ge)
            ), He.uri = Ge), b.tag.attributes[ce] = He, U(b, "onattribute", He);
          }
          b.attribList.length = 0;
        }
        b.tag.isSelfClosing = !!P, b.sawRoot = !0, b.tags.push(b.tag), U(b, "onopentag", b.tag), P || (!b.noscript && b.tagName.toLowerCase() === "script" ? b.state = N.SCRIPT : b.state = N.TEXT, b.tag = null, b.tagName = ""), b.attribName = b.attribValue = "", b.attribList.length = 0;
      }
      function I(b) {
        if (!b.tagName) {
          W(b, "Weird empty close tag."), b.textNode += "</>", b.state = N.TEXT;
          return;
        }
        if (b.script) {
          if (b.tagName !== "script") {
            b.script += "</" + b.tagName + ">", b.tagName = "", b.state = N.SCRIPT;
            return;
          }
          U(b, "onscript", b.script), b.script = "";
        }
        var P = b.tags.length, te = b.tagName;
        b.strict || (te = te[b.looseCase]());
        for (var H = te; P--; ) {
          var D = b.tags[P];
          if (D.name !== H)
            W(b, "Unexpected close tag");
          else
            break;
        }
        if (P < 0) {
          W(b, "Unmatched closing tag: " + b.tagName), b.textNode += "</" + b.tagName + ">", b.state = N.TEXT;
          return;
        }
        b.tagName = te;
        for (var q = b.tags.length; q-- > P; ) {
          var J = b.tag = b.tags.pop();
          b.tagName = b.tag.name, U(b, "onclosetag", b.tagName);
          var ne = {};
          for (var ce in J.ns)
            ne[ce] = J.ns[ce];
          var Ee = b.tags[b.tags.length - 1] || b;
          b.opt.xmlns && J.ns !== Ee.ns && Object.keys(J.ns).forEach(function(ge) {
            var Ge = J.ns[ge];
            U(b, "onclosenamespace", { prefix: ge, uri: Ge });
          });
        }
        P === 0 && (b.closedRoot = !0), b.tagName = b.attribValue = b.attribName = "", b.attribList.length = 0, b.state = N.TEXT;
      }
      function C(b) {
        var P = b.entity, te = P.toLowerCase(), H, D = "";
        return b.ENTITIES[P] ? b.ENTITIES[P] : b.ENTITIES[te] ? b.ENTITIES[te] : (P = te, P.charAt(0) === "#" && (P.charAt(1) === "x" ? (P = P.slice(2), H = parseInt(P, 16), D = H.toString(16)) : (P = P.slice(1), H = parseInt(P, 10), D = H.toString(10))), P = P.replace(/^0+/, ""), isNaN(H) || D.toLowerCase() !== P || H < 0 || H > 1114111 ? (W(b, "Invalid character entity"), "&" + b.entity + ";") : String.fromCodePoint(H));
      }
      function T(b, P) {
        P === "<" ? (b.state = N.OPEN_WAKA, b.startTagPosition = b.position) : x(P) || (W(b, "Non-whitespace before first tag."), b.textNode = P, b.state = N.TEXT);
      }
      function A(b, P) {
        var te = "";
        return P < b.length && (te = b.charAt(P)), te;
      }
      function L(b) {
        var P = this;
        if (this.error)
          throw this.error;
        if (P.closed)
          return V(
            P,
            "Cannot write after close. Assign an onready handler."
          );
        if (b === null)
          return ie(P);
        typeof b == "object" && (b = b.toString());
        for (var te = 0, H = ""; H = A(b, te++), P.c = H, !!H; )
          switch (P.trackPosition && (P.position++, H === `
` ? (P.line++, P.column = 0) : P.column++), P.state) {
            case N.BEGIN:
              if (P.state = N.BEGIN_WHITESPACE, H === "\uFEFF")
                continue;
              T(P, H);
              continue;
            case N.BEGIN_WHITESPACE:
              T(P, H);
              continue;
            case N.TEXT:
              if (P.sawRoot && !P.closedRoot) {
                for (var q = te - 1; H && H !== "<" && H !== "&"; )
                  H = A(b, te++), H && P.trackPosition && (P.position++, H === `
` ? (P.line++, P.column = 0) : P.column++);
                P.textNode += b.substring(q, te - 1);
              }
              H === "<" && !(P.sawRoot && P.closedRoot && !P.strict) ? (P.state = N.OPEN_WAKA, P.startTagPosition = P.position) : (!x(H) && (!P.sawRoot || P.closedRoot) && W(P, "Text data outside of root node."), H === "&" ? P.state = N.TEXT_ENTITY : P.textNode += H);
              continue;
            case N.SCRIPT:
              H === "<" ? P.state = N.SCRIPT_ENDING : P.script += H;
              continue;
            case N.SCRIPT_ENDING:
              H === "/" ? P.state = N.CLOSE_TAG : (P.script += "<" + H, P.state = N.SCRIPT);
              continue;
            case N.OPEN_WAKA:
              if (H === "!")
                P.state = N.SGML_DECL, P.sgmlDecl = "";
              else if (!x(H)) if (E(h, H))
                P.state = N.OPEN_TAG, P.tagName = H;
              else if (H === "/")
                P.state = N.CLOSE_TAG, P.tagName = "";
              else if (H === "?")
                P.state = N.PROC_INST, P.procInstName = P.procInstBody = "";
              else {
                if (W(P, "Unencoded <"), P.startTagPosition + 1 < P.position) {
                  var D = P.position - P.startTagPosition;
                  H = new Array(D).join(" ") + H;
                }
                P.textNode += "<" + H, P.state = N.TEXT;
              }
              continue;
            case N.SGML_DECL:
              if (P.sgmlDecl + H === "--") {
                P.state = N.COMMENT, P.comment = "", P.sgmlDecl = "";
                continue;
              }
              P.doctype && P.doctype !== !0 && P.sgmlDecl ? (P.state = N.DOCTYPE_DTD, P.doctype += "<!" + P.sgmlDecl + H, P.sgmlDecl = "") : (P.sgmlDecl + H).toUpperCase() === d ? (U(P, "onopencdata"), P.state = N.CDATA, P.sgmlDecl = "", P.cdata = "") : (P.sgmlDecl + H).toUpperCase() === f ? (P.state = N.DOCTYPE, (P.doctype || P.sawRoot) && W(
                P,
                "Inappropriately located doctype declaration"
              ), P.doctype = "", P.sgmlDecl = "") : H === ">" ? (U(P, "onsgmldeclaration", P.sgmlDecl), P.sgmlDecl = "", P.state = N.TEXT) : (S(H) && (P.state = N.SGML_DECL_QUOTED), P.sgmlDecl += H);
              continue;
            case N.SGML_DECL_QUOTED:
              H === P.q && (P.state = N.SGML_DECL, P.q = ""), P.sgmlDecl += H;
              continue;
            case N.DOCTYPE:
              H === ">" ? (P.state = N.TEXT, U(P, "ondoctype", P.doctype), P.doctype = !0) : (P.doctype += H, H === "[" ? P.state = N.DOCTYPE_DTD : S(H) && (P.state = N.DOCTYPE_QUOTED, P.q = H));
              continue;
            case N.DOCTYPE_QUOTED:
              P.doctype += H, H === P.q && (P.q = "", P.state = N.DOCTYPE);
              continue;
            case N.DOCTYPE_DTD:
              H === "]" ? (P.doctype += H, P.state = N.DOCTYPE) : H === "<" ? (P.state = N.OPEN_WAKA, P.startTagPosition = P.position) : S(H) ? (P.doctype += H, P.state = N.DOCTYPE_DTD_QUOTED, P.q = H) : P.doctype += H;
              continue;
            case N.DOCTYPE_DTD_QUOTED:
              P.doctype += H, H === P.q && (P.state = N.DOCTYPE_DTD, P.q = "");
              continue;
            case N.COMMENT:
              H === "-" ? P.state = N.COMMENT_ENDING : P.comment += H;
              continue;
            case N.COMMENT_ENDING:
              H === "-" ? (P.state = N.COMMENT_ENDED, P.comment = M(P.opt, P.comment), P.comment && U(P, "oncomment", P.comment), P.comment = "") : (P.comment += "-" + H, P.state = N.COMMENT);
              continue;
            case N.COMMENT_ENDED:
              H !== ">" ? (W(P, "Malformed comment"), P.comment += "--" + H, P.state = N.COMMENT) : P.doctype && P.doctype !== !0 ? P.state = N.DOCTYPE_DTD : P.state = N.TEXT;
              continue;
            case N.CDATA:
              for (var q = te - 1; H && H !== "]"; )
                H = A(b, te++), H && P.trackPosition && (P.position++, H === `
` ? (P.line++, P.column = 0) : P.column++);
              P.cdata += b.substring(q, te - 1), H === "]" && (P.state = N.CDATA_ENDING);
              continue;
            case N.CDATA_ENDING:
              H === "]" ? P.state = N.CDATA_ENDING_2 : (P.cdata += "]" + H, P.state = N.CDATA);
              continue;
            case N.CDATA_ENDING_2:
              H === ">" ? (P.cdata && U(P, "oncdata", P.cdata), U(P, "onclosecdata"), P.cdata = "", P.state = N.TEXT) : H === "]" ? P.cdata += "]" : (P.cdata += "]]" + H, P.state = N.CDATA);
              continue;
            case N.PROC_INST:
              H === "?" ? P.state = N.PROC_INST_ENDING : x(H) ? P.state = N.PROC_INST_BODY : P.procInstName += H;
              continue;
            case N.PROC_INST_BODY:
              if (!P.procInstBody && x(H))
                continue;
              H === "?" ? P.state = N.PROC_INST_ENDING : P.procInstBody += H;
              continue;
            case N.PROC_INST_ENDING:
              H === ">" ? (U(P, "onprocessinginstruction", {
                name: P.procInstName,
                body: P.procInstBody
              }), P.procInstName = P.procInstBody = "", P.state = N.TEXT) : (P.procInstBody += "?" + H, P.state = N.PROC_INST_BODY);
              continue;
            case N.OPEN_TAG:
              E(_, H) ? P.tagName += H : (ae(P), H === ">" ? k(P) : H === "/" ? P.state = N.OPEN_TAG_SLASH : (x(H) || W(P, "Invalid character in tag name"), P.state = N.ATTRIB));
              continue;
            case N.OPEN_TAG_SLASH:
              H === ">" ? (k(P, !0), I(P)) : (W(
                P,
                "Forward-slash in opening tag not followed by >"
              ), P.state = N.ATTRIB);
              continue;
            case N.ATTRIB:
              if (x(H))
                continue;
              H === ">" ? k(P) : H === "/" ? P.state = N.OPEN_TAG_SLASH : E(h, H) ? (P.attribName = H, P.attribValue = "", P.state = N.ATTRIB_NAME) : W(P, "Invalid attribute name");
              continue;
            case N.ATTRIB_NAME:
              H === "=" ? P.state = N.ATTRIB_VALUE : H === ">" ? (W(P, "Attribute without value"), P.attribValue = P.attribName, X(P), k(P)) : x(H) ? P.state = N.ATTRIB_NAME_SAW_WHITE : E(_, H) ? P.attribName += H : W(P, "Invalid attribute name");
              continue;
            case N.ATTRIB_NAME_SAW_WHITE:
              if (H === "=")
                P.state = N.ATTRIB_VALUE;
              else {
                if (x(H))
                  continue;
                W(P, "Attribute without value"), P.tag.attributes[P.attribName] = "", P.attribValue = "", U(P, "onattribute", {
                  name: P.attribName,
                  value: ""
                }), P.attribName = "", H === ">" ? k(P) : E(h, H) ? (P.attribName = H, P.state = N.ATTRIB_NAME) : (W(P, "Invalid attribute name"), P.state = N.ATTRIB);
              }
              continue;
            case N.ATTRIB_VALUE:
              if (x(H))
                continue;
              S(H) ? (P.q = H, P.state = N.ATTRIB_VALUE_QUOTED) : (P.opt.unquotedAttributeValues || V(P, "Unquoted attribute value"), P.state = N.ATTRIB_VALUE_UNQUOTED, P.attribValue = H);
              continue;
            case N.ATTRIB_VALUE_QUOTED:
              if (H !== P.q) {
                H === "&" ? P.state = N.ATTRIB_VALUE_ENTITY_Q : P.attribValue += H;
                continue;
              }
              X(P), P.q = "", P.state = N.ATTRIB_VALUE_CLOSED;
              continue;
            case N.ATTRIB_VALUE_CLOSED:
              x(H) ? P.state = N.ATTRIB : H === ">" ? k(P) : H === "/" ? P.state = N.OPEN_TAG_SLASH : E(h, H) ? (W(P, "No whitespace between attributes"), P.attribName = H, P.attribValue = "", P.state = N.ATTRIB_NAME) : W(P, "Invalid attribute name");
              continue;
            case N.ATTRIB_VALUE_UNQUOTED:
              if (!w(H)) {
                H === "&" ? P.state = N.ATTRIB_VALUE_ENTITY_U : P.attribValue += H;
                continue;
              }
              X(P), H === ">" ? k(P) : P.state = N.ATTRIB;
              continue;
            case N.CLOSE_TAG:
              if (P.tagName)
                H === ">" ? I(P) : E(_, H) ? P.tagName += H : P.script ? (P.script += "</" + P.tagName, P.tagName = "", P.state = N.SCRIPT) : (x(H) || W(P, "Invalid tagname in closing tag"), P.state = N.CLOSE_TAG_SAW_WHITE);
              else {
                if (x(H))
                  continue;
                R(h, H) ? P.script ? (P.script += "</" + H, P.state = N.SCRIPT) : W(P, "Invalid tagname in closing tag.") : P.tagName = H;
              }
              continue;
            case N.CLOSE_TAG_SAW_WHITE:
              if (x(H))
                continue;
              H === ">" ? I(P) : W(P, "Invalid characters in closing tag");
              continue;
            case N.TEXT_ENTITY:
            case N.ATTRIB_VALUE_ENTITY_Q:
            case N.ATTRIB_VALUE_ENTITY_U:
              var J, ne;
              switch (P.state) {
                case N.TEXT_ENTITY:
                  J = N.TEXT, ne = "textNode";
                  break;
                case N.ATTRIB_VALUE_ENTITY_Q:
                  J = N.ATTRIB_VALUE_QUOTED, ne = "attribValue";
                  break;
                case N.ATTRIB_VALUE_ENTITY_U:
                  J = N.ATTRIB_VALUE_UNQUOTED, ne = "attribValue";
                  break;
              }
              if (H === ";") {
                var ce = C(P);
                P.opt.unparsedEntities && !Object.values(t.XML_ENTITIES).includes(ce) ? (P.entity = "", P.state = J, P.write(ce)) : (P[ne] += ce, P.entity = "", P.state = J);
              } else E(P.entity.length ? y : g, H) ? P.entity += H : (W(P, "Invalid character in entity name"), P[ne] += "&" + P.entity + H, P.entity = "", P.state = J);
              continue;
            default:
              throw new Error(P, "Unknown state: " + P.state);
          }
        return P.position >= P.bufferCheckPosition && i(P), P;
      }
      String.fromCodePoint || (function() {
        var b = String.fromCharCode, P = Math.floor, te = function() {
          var H = 16384, D = [], q, J, ne = -1, ce = arguments.length;
          if (!ce)
            return "";
          for (var Ee = ""; ++ne < ce; ) {
            var ge = Number(arguments[ne]);
            if (!isFinite(ge) || // `NaN`, `+Infinity`, or `-Infinity`
            ge < 0 || // not a valid Unicode code point
            ge > 1114111 || // not a valid Unicode code point
            P(ge) !== ge)
              throw RangeError("Invalid code point: " + ge);
            ge <= 65535 ? D.push(ge) : (ge -= 65536, q = (ge >> 10) + 55296, J = ge % 1024 + 56320, D.push(q, J)), (ne + 1 === ce || D.length > H) && (Ee += b.apply(null, D), D.length = 0);
          }
          return Ee;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: te,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = te;
      })();
    })(e);
  })(mu)), mu;
}
var xp;
function eS() {
  if (xp) return $i;
  xp = 1, Object.defineProperty($i, "__esModule", { value: !0 }), $i.XElement = void 0, $i.parseXml = s;
  const e = ZT(), t = Qc();
  class r {
    constructor(c) {
      if (this.name = c, this.value = "", this.attributes = null, this.isCData = !1, this.elements = null, !c)
        throw (0, t.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
      if (!i(c))
        throw (0, t.newError)(`Invalid element name: ${c}`, "ERR_XML_ELEMENT_INVALID_NAME");
    }
    attribute(c) {
      const u = this.attributes === null ? null : this.attributes[c];
      if (u == null)
        throw (0, t.newError)(`No attribute "${c}"`, "ERR_XML_MISSED_ATTRIBUTE");
      return u;
    }
    removeAttribute(c) {
      this.attributes !== null && delete this.attributes[c];
    }
    element(c, u = !1, l = null) {
      const d = this.elementOrNull(c, u);
      if (d === null)
        throw (0, t.newError)(l || `No element "${c}"`, "ERR_XML_MISSED_ELEMENT");
      return d;
    }
    elementOrNull(c, u = !1) {
      if (this.elements === null)
        return null;
      for (const l of this.elements)
        if (a(l, c, u))
          return l;
      return null;
    }
    getElements(c, u = !1) {
      return this.elements === null ? [] : this.elements.filter((l) => a(l, c, u));
    }
    elementValueOrEmpty(c, u = !1) {
      const l = this.elementOrNull(c, u);
      return l === null ? "" : l.value;
    }
  }
  $i.XElement = r;
  const n = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
  function i(o) {
    return n.test(o);
  }
  function a(o, c, u) {
    const l = o.name;
    return l === c || u === !0 && l.length === c.length && l.toLowerCase() === c.toLowerCase();
  }
  function s(o) {
    let c = null;
    const u = e.parser(!0, {}), l = [];
    return u.onopentag = (d) => {
      const f = new r(d.name);
      if (f.attributes = d.attributes, c === null)
        c = f;
      else {
        const p = l[l.length - 1];
        p.elements == null && (p.elements = []), p.elements.push(f);
      }
      l.push(f);
    }, u.onclosetag = () => {
      l.pop();
    }, u.ontext = (d) => {
      l.length > 0 && (l[l.length - 1].value = d);
    }, u.oncdata = (d) => {
      const f = l[l.length - 1];
      f.value = d, f.isCData = !0;
    }, u.onerror = (d) => {
      throw d;
    }, u.write(o), c;
  }
  return $i;
}
var Tp;
function Jt() {
  return Tp || (Tp = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CURRENT_APP_PACKAGE_FILE_NAME = e.CURRENT_APP_INSTALLER_FILE_NAME = e.XElement = e.parseXml = e.UUID = e.parseDn = e.retry = e.githubUrl = e.getS3LikeProviderBaseUrl = e.ProgressCallbackTransform = e.MemoLazy = e.safeStringifyJson = e.safeGetHeader = e.parseJson = e.HttpExecutor = e.HttpError = e.DigestTransform = e.createHttpError = e.configureRequestUrl = e.configureRequestOptionsFromUrl = e.configureRequestOptions = e.newError = e.CancellationToken = e.CancellationError = void 0, e.asArray = d;
    var t = v0();
    Object.defineProperty(e, "CancellationError", { enumerable: !0, get: function() {
      return t.CancellationError;
    } }), Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
      return t.CancellationToken;
    } });
    var r = Qc();
    Object.defineProperty(e, "newError", { enumerable: !0, get: function() {
      return r.newError;
    } });
    var n = WT();
    Object.defineProperty(e, "configureRequestOptions", { enumerable: !0, get: function() {
      return n.configureRequestOptions;
    } }), Object.defineProperty(e, "configureRequestOptionsFromUrl", { enumerable: !0, get: function() {
      return n.configureRequestOptionsFromUrl;
    } }), Object.defineProperty(e, "configureRequestUrl", { enumerable: !0, get: function() {
      return n.configureRequestUrl;
    } }), Object.defineProperty(e, "createHttpError", { enumerable: !0, get: function() {
      return n.createHttpError;
    } }), Object.defineProperty(e, "DigestTransform", { enumerable: !0, get: function() {
      return n.DigestTransform;
    } }), Object.defineProperty(e, "HttpError", { enumerable: !0, get: function() {
      return n.HttpError;
    } }), Object.defineProperty(e, "HttpExecutor", { enumerable: !0, get: function() {
      return n.HttpExecutor;
    } }), Object.defineProperty(e, "parseJson", { enumerable: !0, get: function() {
      return n.parseJson;
    } }), Object.defineProperty(e, "safeGetHeader", { enumerable: !0, get: function() {
      return n.safeGetHeader;
    } }), Object.defineProperty(e, "safeStringifyJson", { enumerable: !0, get: function() {
      return n.safeStringifyJson;
    } });
    var i = XT();
    Object.defineProperty(e, "MemoLazy", { enumerable: !0, get: function() {
      return i.MemoLazy;
    } });
    var a = aE();
    Object.defineProperty(e, "ProgressCallbackTransform", { enumerable: !0, get: function() {
      return a.ProgressCallbackTransform;
    } });
    var s = KT();
    Object.defineProperty(e, "getS3LikeProviderBaseUrl", { enumerable: !0, get: function() {
      return s.getS3LikeProviderBaseUrl;
    } }), Object.defineProperty(e, "githubUrl", { enumerable: !0, get: function() {
      return s.githubUrl;
    } });
    var o = YT();
    Object.defineProperty(e, "retry", { enumerable: !0, get: function() {
      return o.retry;
    } });
    var c = JT();
    Object.defineProperty(e, "parseDn", { enumerable: !0, get: function() {
      return c.parseDn;
    } });
    var u = QT();
    Object.defineProperty(e, "UUID", { enumerable: !0, get: function() {
      return u.UUID;
    } });
    var l = eS();
    Object.defineProperty(e, "parseXml", { enumerable: !0, get: function() {
      return l.parseXml;
    } }), Object.defineProperty(e, "XElement", { enumerable: !0, get: function() {
      return l.XElement;
    } }), e.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe", e.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
    function d(f) {
      return f == null ? [] : Array.isArray(f) ? f : [f];
    }
  })(uu)), uu;
}
var tr = {}, $s = {}, Pn = {}, Sp;
function rs() {
  if (Sp) return Pn;
  Sp = 1;
  function e(s) {
    return typeof s > "u" || s === null;
  }
  function t(s) {
    return typeof s == "object" && s !== null;
  }
  function r(s) {
    return Array.isArray(s) ? s : e(s) ? [] : [s];
  }
  function n(s, o) {
    var c, u, l, d;
    if (o)
      for (d = Object.keys(o), c = 0, u = d.length; c < u; c += 1)
        l = d[c], s[l] = o[l];
    return s;
  }
  function i(s, o) {
    var c = "", u;
    for (u = 0; u < o; u += 1)
      c += s;
    return c;
  }
  function a(s) {
    return s === 0 && Number.NEGATIVE_INFINITY === 1 / s;
  }
  return Pn.isNothing = e, Pn.isObject = t, Pn.toArray = r, Pn.repeat = i, Pn.isNegativeZero = a, Pn.extend = n, Pn;
}
var gu, Ap;
function ns() {
  if (Ap) return gu;
  Ap = 1;
  function e(r, n) {
    var i = "", a = r.reason || "(unknown reason)";
    return r.mark ? (r.mark.name && (i += 'in "' + r.mark.name + '" '), i += "(" + (r.mark.line + 1) + ":" + (r.mark.column + 1) + ")", !n && r.mark.snippet && (i += `

` + r.mark.snippet), a + " " + i) : a;
  }
  function t(r, n) {
    Error.call(this), this.name = "YAMLException", this.reason = r, this.mark = n, this.message = e(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t.prototype.toString = function(n) {
    return this.name + ": " + e(this, n);
  }, gu = t, gu;
}
var vu, Rp;
function tS() {
  if (Rp) return vu;
  Rp = 1;
  var e = rs();
  function t(i, a, s, o, c) {
    var u = "", l = "", d = Math.floor(c / 2) - 1;
    return o - a > d && (u = " ... ", a = o - d + u.length), s - o > d && (l = " ...", s = o + d - l.length), {
      str: u + i.slice(a, s).replace(/\t/g, "") + l,
      pos: o - a + u.length
      // relative position
    };
  }
  function r(i, a) {
    return e.repeat(" ", a - i.length) + i;
  }
  function n(i, a) {
    if (a = Object.create(a || null), !i.buffer) return null;
    a.maxLength || (a.maxLength = 79), typeof a.indent != "number" && (a.indent = 1), typeof a.linesBefore != "number" && (a.linesBefore = 3), typeof a.linesAfter != "number" && (a.linesAfter = 2);
    for (var s = /\r?\n|\r|\0/g, o = [0], c = [], u, l = -1; u = s.exec(i.buffer); )
      c.push(u.index), o.push(u.index + u[0].length), i.position <= u.index && l < 0 && (l = o.length - 2);
    l < 0 && (l = o.length - 1);
    var d = "", f, p, v = Math.min(i.line + a.linesAfter, c.length).toString().length, m = a.maxLength - (a.indent + v + 3);
    for (f = 1; f <= a.linesBefore && !(l - f < 0); f++)
      p = t(
        i.buffer,
        o[l - f],
        c[l - f],
        i.position - (o[l] - o[l - f]),
        m
      ), d = e.repeat(" ", a.indent) + r((i.line - f + 1).toString(), v) + " | " + p.str + `
` + d;
    for (p = t(i.buffer, o[l], c[l], i.position, m), d += e.repeat(" ", a.indent) + r((i.line + 1).toString(), v) + " | " + p.str + `
`, d += e.repeat("-", a.indent + v + 3 + p.pos) + `^
`, f = 1; f <= a.linesAfter && !(l + f >= c.length); f++)
      p = t(
        i.buffer,
        o[l + f],
        c[l + f],
        i.position - (o[l] - o[l + f]),
        m
      ), d += e.repeat(" ", a.indent) + r((i.line + f + 1).toString(), v) + " | " + p.str + `
`;
    return d.replace(/\n$/, "");
  }
  return vu = n, vu;
}
var _u, $p;
function hr() {
  if ($p) return _u;
  $p = 1;
  var e = ns(), t = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], r = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function n(a) {
    var s = {};
    return a !== null && Object.keys(a).forEach(function(o) {
      a[o].forEach(function(c) {
        s[String(c)] = o;
      });
    }), s;
  }
  function i(a, s) {
    if (s = s || {}, Object.keys(s).forEach(function(o) {
      if (t.indexOf(o) === -1)
        throw new e('Unknown option "' + o + '" is met in definition of "' + a + '" YAML type.');
    }), this.options = s, this.tag = a, this.kind = s.kind || null, this.resolve = s.resolve || function() {
      return !0;
    }, this.construct = s.construct || function(o) {
      return o;
    }, this.instanceOf = s.instanceOf || null, this.predicate = s.predicate || null, this.represent = s.represent || null, this.representName = s.representName || null, this.defaultStyle = s.defaultStyle || null, this.multi = s.multi || !1, this.styleAliases = n(s.styleAliases || null), r.indexOf(this.kind) === -1)
      throw new e('Unknown kind "' + this.kind + '" is specified for "' + a + '" YAML type.');
  }
  return _u = i, _u;
}
var yu, Op;
function sE() {
  if (Op) return yu;
  Op = 1;
  var e = ns(), t = hr();
  function r(a, s) {
    var o = [];
    return a[s].forEach(function(c) {
      var u = o.length;
      o.forEach(function(l, d) {
        l.tag === c.tag && l.kind === c.kind && l.multi === c.multi && (u = d);
      }), o[u] = c;
    }), o;
  }
  function n() {
    var a = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, s, o;
    function c(u) {
      u.multi ? (a.multi[u.kind].push(u), a.multi.fallback.push(u)) : a[u.kind][u.tag] = a.fallback[u.tag] = u;
    }
    for (s = 0, o = arguments.length; s < o; s += 1)
      arguments[s].forEach(c);
    return a;
  }
  function i(a) {
    return this.extend(a);
  }
  return i.prototype.extend = function(s) {
    var o = [], c = [];
    if (s instanceof t)
      c.push(s);
    else if (Array.isArray(s))
      c = c.concat(s);
    else if (s && (Array.isArray(s.implicit) || Array.isArray(s.explicit)))
      s.implicit && (o = o.concat(s.implicit)), s.explicit && (c = c.concat(s.explicit));
    else
      throw new e("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    o.forEach(function(l) {
      if (!(l instanceof t))
        throw new e("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (l.loadKind && l.loadKind !== "scalar")
        throw new e("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (l.multi)
        throw new e("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), c.forEach(function(l) {
      if (!(l instanceof t))
        throw new e("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var u = Object.create(i.prototype);
    return u.implicit = (this.implicit || []).concat(o), u.explicit = (this.explicit || []).concat(c), u.compiledImplicit = r(u, "implicit"), u.compiledExplicit = r(u, "explicit"), u.compiledTypeMap = n(u.compiledImplicit, u.compiledExplicit), u;
  }, yu = i, yu;
}
var Eu, Np;
function oE() {
  if (Np) return Eu;
  Np = 1;
  var e = hr();
  return Eu = new e("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(t) {
      return t !== null ? t : "";
    }
  }), Eu;
}
var wu, Pp;
function cE() {
  if (Pp) return wu;
  Pp = 1;
  var e = hr();
  return wu = new e("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(t) {
      return t !== null ? t : [];
    }
  }), wu;
}
var xu, Cp;
function lE() {
  if (Cp) return xu;
  Cp = 1;
  var e = hr();
  return xu = new e("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(t) {
      return t !== null ? t : {};
    }
  }), xu;
}
var Tu, Ip;
function uE() {
  if (Ip) return Tu;
  Ip = 1;
  var e = sE();
  return Tu = new e({
    explicit: [
      oE(),
      cE(),
      lE()
    ]
  }), Tu;
}
var Su, bp;
function fE() {
  if (bp) return Su;
  bp = 1;
  var e = hr();
  function t(i) {
    if (i === null) return !0;
    var a = i.length;
    return a === 1 && i === "~" || a === 4 && (i === "null" || i === "Null" || i === "NULL");
  }
  function r() {
    return null;
  }
  function n(i) {
    return i === null;
  }
  return Su = new e("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: t,
    construct: r,
    predicate: n,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  }), Su;
}
var Au, Fp;
function dE() {
  if (Fp) return Au;
  Fp = 1;
  var e = hr();
  function t(i) {
    if (i === null) return !1;
    var a = i.length;
    return a === 4 && (i === "true" || i === "True" || i === "TRUE") || a === 5 && (i === "false" || i === "False" || i === "FALSE");
  }
  function r(i) {
    return i === "true" || i === "True" || i === "TRUE";
  }
  function n(i) {
    return Object.prototype.toString.call(i) === "[object Boolean]";
  }
  return Au = new e("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: t,
    construct: r,
    predicate: n,
    represent: {
      lowercase: function(i) {
        return i ? "true" : "false";
      },
      uppercase: function(i) {
        return i ? "TRUE" : "FALSE";
      },
      camelcase: function(i) {
        return i ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), Au;
}
var Ru, Dp;
function hE() {
  if (Dp) return Ru;
  Dp = 1;
  var e = rs(), t = hr();
  function r(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function n(c) {
    return 48 <= c && c <= 55;
  }
  function i(c) {
    return 48 <= c && c <= 57;
  }
  function a(c) {
    if (c === null) return !1;
    var u = c.length, l = 0, d = !1, f;
    if (!u) return !1;
    if (f = c[l], (f === "-" || f === "+") && (f = c[++l]), f === "0") {
      if (l + 1 === u) return !0;
      if (f = c[++l], f === "b") {
        for (l++; l < u; l++)
          if (f = c[l], f !== "_") {
            if (f !== "0" && f !== "1") return !1;
            d = !0;
          }
        return d && f !== "_";
      }
      if (f === "x") {
        for (l++; l < u; l++)
          if (f = c[l], f !== "_") {
            if (!r(c.charCodeAt(l))) return !1;
            d = !0;
          }
        return d && f !== "_";
      }
      if (f === "o") {
        for (l++; l < u; l++)
          if (f = c[l], f !== "_") {
            if (!n(c.charCodeAt(l))) return !1;
            d = !0;
          }
        return d && f !== "_";
      }
    }
    if (f === "_") return !1;
    for (; l < u; l++)
      if (f = c[l], f !== "_") {
        if (!i(c.charCodeAt(l)))
          return !1;
        d = !0;
      }
    return !(!d || f === "_");
  }
  function s(c) {
    var u = c, l = 1, d;
    if (u.indexOf("_") !== -1 && (u = u.replace(/_/g, "")), d = u[0], (d === "-" || d === "+") && (d === "-" && (l = -1), u = u.slice(1), d = u[0]), u === "0") return 0;
    if (d === "0") {
      if (u[1] === "b") return l * parseInt(u.slice(2), 2);
      if (u[1] === "x") return l * parseInt(u.slice(2), 16);
      if (u[1] === "o") return l * parseInt(u.slice(2), 8);
    }
    return l * parseInt(u, 10);
  }
  function o(c) {
    return Object.prototype.toString.call(c) === "[object Number]" && c % 1 === 0 && !e.isNegativeZero(c);
  }
  return Ru = new t("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: a,
    construct: s,
    predicate: o,
    represent: {
      binary: function(c) {
        return c >= 0 ? "0b" + c.toString(2) : "-0b" + c.toString(2).slice(1);
      },
      octal: function(c) {
        return c >= 0 ? "0o" + c.toString(8) : "-0o" + c.toString(8).slice(1);
      },
      decimal: function(c) {
        return c.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(c) {
        return c >= 0 ? "0x" + c.toString(16).toUpperCase() : "-0x" + c.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), Ru;
}
var $u, kp;
function pE() {
  if (kp) return $u;
  kp = 1;
  var e = rs(), t = hr(), r = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function n(c) {
    return !(c === null || !r.test(c) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    c[c.length - 1] === "_");
  }
  function i(c) {
    var u, l;
    return u = c.replace(/_/g, "").toLowerCase(), l = u[0] === "-" ? -1 : 1, "+-".indexOf(u[0]) >= 0 && (u = u.slice(1)), u === ".inf" ? l === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : u === ".nan" ? NaN : l * parseFloat(u, 10);
  }
  var a = /^[-+]?[0-9]+e/;
  function s(c, u) {
    var l;
    if (isNaN(c))
      switch (u) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === c)
      switch (u) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === c)
      switch (u) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (e.isNegativeZero(c))
      return "-0.0";
    return l = c.toString(10), a.test(l) ? l.replace("e", ".e") : l;
  }
  function o(c) {
    return Object.prototype.toString.call(c) === "[object Number]" && (c % 1 !== 0 || e.isNegativeZero(c));
  }
  return $u = new t("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: n,
    construct: i,
    predicate: o,
    represent: s,
    defaultStyle: "lowercase"
  }), $u;
}
var Ou, Lp;
function mE() {
  return Lp || (Lp = 1, Ou = uE().extend({
    implicit: [
      fE(),
      dE(),
      hE(),
      pE()
    ]
  })), Ou;
}
var Nu, Mp;
function gE() {
  return Mp || (Mp = 1, Nu = mE()), Nu;
}
var Pu, Up;
function vE() {
  if (Up) return Pu;
  Up = 1;
  var e = hr(), t = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), r = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function n(s) {
    return s === null ? !1 : t.exec(s) !== null || r.exec(s) !== null;
  }
  function i(s) {
    var o, c, u, l, d, f, p, v = 0, m = null, h, _, g;
    if (o = t.exec(s), o === null && (o = r.exec(s)), o === null) throw new Error("Date resolve error");
    if (c = +o[1], u = +o[2] - 1, l = +o[3], !o[4])
      return new Date(Date.UTC(c, u, l));
    if (d = +o[4], f = +o[5], p = +o[6], o[7]) {
      for (v = o[7].slice(0, 3); v.length < 3; )
        v += "0";
      v = +v;
    }
    return o[9] && (h = +o[10], _ = +(o[11] || 0), m = (h * 60 + _) * 6e4, o[9] === "-" && (m = -m)), g = new Date(Date.UTC(c, u, l, d, f, p, v)), m && g.setTime(g.getTime() - m), g;
  }
  function a(s) {
    return s.toISOString();
  }
  return Pu = new e("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: n,
    construct: i,
    instanceOf: Date,
    represent: a
  }), Pu;
}
var Cu, qp;
function _E() {
  if (qp) return Cu;
  qp = 1;
  var e = hr();
  function t(r) {
    return r === "<<" || r === null;
  }
  return Cu = new e("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: t
  }), Cu;
}
var Iu, Bp;
function yE() {
  if (Bp) return Iu;
  Bp = 1;
  var e = hr(), t = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function r(s) {
    if (s === null) return !1;
    var o, c, u = 0, l = s.length, d = t;
    for (c = 0; c < l; c++)
      if (o = d.indexOf(s.charAt(c)), !(o > 64)) {
        if (o < 0) return !1;
        u += 6;
      }
    return u % 8 === 0;
  }
  function n(s) {
    var o, c, u = s.replace(/[\r\n=]/g, ""), l = u.length, d = t, f = 0, p = [];
    for (o = 0; o < l; o++)
      o % 4 === 0 && o && (p.push(f >> 16 & 255), p.push(f >> 8 & 255), p.push(f & 255)), f = f << 6 | d.indexOf(u.charAt(o));
    return c = l % 4 * 6, c === 0 ? (p.push(f >> 16 & 255), p.push(f >> 8 & 255), p.push(f & 255)) : c === 18 ? (p.push(f >> 10 & 255), p.push(f >> 2 & 255)) : c === 12 && p.push(f >> 4 & 255), new Uint8Array(p);
  }
  function i(s) {
    var o = "", c = 0, u, l, d = s.length, f = t;
    for (u = 0; u < d; u++)
      u % 3 === 0 && u && (o += f[c >> 18 & 63], o += f[c >> 12 & 63], o += f[c >> 6 & 63], o += f[c & 63]), c = (c << 8) + s[u];
    return l = d % 3, l === 0 ? (o += f[c >> 18 & 63], o += f[c >> 12 & 63], o += f[c >> 6 & 63], o += f[c & 63]) : l === 2 ? (o += f[c >> 10 & 63], o += f[c >> 4 & 63], o += f[c << 2 & 63], o += f[64]) : l === 1 && (o += f[c >> 2 & 63], o += f[c << 4 & 63], o += f[64], o += f[64]), o;
  }
  function a(s) {
    return Object.prototype.toString.call(s) === "[object Uint8Array]";
  }
  return Iu = new e("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: r,
    construct: n,
    predicate: a,
    represent: i
  }), Iu;
}
var bu, jp;
function EE() {
  if (jp) return bu;
  jp = 1;
  var e = hr(), t = Object.prototype.hasOwnProperty, r = Object.prototype.toString;
  function n(a) {
    if (a === null) return !0;
    var s = [], o, c, u, l, d, f = a;
    for (o = 0, c = f.length; o < c; o += 1) {
      if (u = f[o], d = !1, r.call(u) !== "[object Object]") return !1;
      for (l in u)
        if (t.call(u, l))
          if (!d) d = !0;
          else return !1;
      if (!d) return !1;
      if (s.indexOf(l) === -1) s.push(l);
      else return !1;
    }
    return !0;
  }
  function i(a) {
    return a !== null ? a : [];
  }
  return bu = new e("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: n,
    construct: i
  }), bu;
}
var Fu, Vp;
function wE() {
  if (Vp) return Fu;
  Vp = 1;
  var e = hr(), t = Object.prototype.toString;
  function r(i) {
    if (i === null) return !0;
    var a, s, o, c, u, l = i;
    for (u = new Array(l.length), a = 0, s = l.length; a < s; a += 1) {
      if (o = l[a], t.call(o) !== "[object Object]" || (c = Object.keys(o), c.length !== 1)) return !1;
      u[a] = [c[0], o[c[0]]];
    }
    return !0;
  }
  function n(i) {
    if (i === null) return [];
    var a, s, o, c, u, l = i;
    for (u = new Array(l.length), a = 0, s = l.length; a < s; a += 1)
      o = l[a], c = Object.keys(o), u[a] = [c[0], o[c[0]]];
    return u;
  }
  return Fu = new e("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: r,
    construct: n
  }), Fu;
}
var Du, Hp;
function xE() {
  if (Hp) return Du;
  Hp = 1;
  var e = hr(), t = Object.prototype.hasOwnProperty;
  function r(i) {
    if (i === null) return !0;
    var a, s = i;
    for (a in s)
      if (t.call(s, a) && s[a] !== null)
        return !1;
    return !0;
  }
  function n(i) {
    return i !== null ? i : {};
  }
  return Du = new e("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: r,
    construct: n
  }), Du;
}
var ku, Gp;
function _0() {
  return Gp || (Gp = 1, ku = gE().extend({
    implicit: [
      vE(),
      _E()
    ],
    explicit: [
      yE(),
      EE(),
      wE(),
      xE()
    ]
  })), ku;
}
var zp;
function rS() {
  if (zp) return $s;
  zp = 1;
  var e = rs(), t = ns(), r = tS(), n = _0(), i = Object.prototype.hasOwnProperty, a = 1, s = 2, o = 3, c = 4, u = 1, l = 2, d = 3, f = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, p = /[\x85\u2028\u2029]/, v = /[,\[\]\{\}]/, m = /^(?:!|!!|![a-z\-]+!)$/i, h = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _(O) {
    return Object.prototype.toString.call(O);
  }
  function g(O) {
    return O === 10 || O === 13;
  }
  function y(O) {
    return O === 9 || O === 32;
  }
  function x(O) {
    return O === 9 || O === 32 || O === 10 || O === 13;
  }
  function S(O) {
    return O === 44 || O === 91 || O === 93 || O === 123 || O === 125;
  }
  function w(O) {
    var le;
    return 48 <= O && O <= 57 ? O - 48 : (le = O | 32, 97 <= le && le <= 102 ? le - 97 + 10 : -1);
  }
  function E(O) {
    return O === 120 ? 2 : O === 117 ? 4 : O === 85 ? 8 : 0;
  }
  function R(O) {
    return 48 <= O && O <= 57 ? O - 48 : -1;
  }
  function N(O) {
    return O === 48 ? "\0" : O === 97 ? "\x07" : O === 98 ? "\b" : O === 116 || O === 9 ? "	" : O === 110 ? `
` : O === 118 ? "\v" : O === 102 ? "\f" : O === 114 ? "\r" : O === 101 ? "\x1B" : O === 32 ? " " : O === 34 ? '"' : O === 47 ? "/" : O === 92 ? "\\" : O === 78 ? "" : O === 95 ? "" : O === 76 ? "\u2028" : O === 80 ? "\u2029" : "";
  }
  function B(O) {
    return O <= 65535 ? String.fromCharCode(O) : String.fromCharCode(
      (O - 65536 >> 10) + 55296,
      (O - 65536 & 1023) + 56320
    );
  }
  function F(O, le, me) {
    le === "__proto__" ? Object.defineProperty(O, le, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: me
    }) : O[le] = me;
  }
  for (var U = new Array(256), G = new Array(256), M = 0; M < 256; M++)
    U[M] = N(M) ? 1 : 0, G[M] = N(M);
  function V(O, le) {
    this.input = O, this.filename = le.filename || null, this.schema = le.schema || n, this.onWarning = le.onWarning || null, this.legacy = le.legacy || !1, this.json = le.json || !1, this.listener = le.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = O.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function ie(O, le) {
    var me = {
      name: O.filename,
      buffer: O.input.slice(0, -1),
      // omit trailing \0
      position: O.position,
      line: O.line,
      column: O.position - O.lineStart
    };
    return me.snippet = r(me), new t(le, me);
  }
  function W(O, le) {
    throw ie(O, le);
  }
  function ae(O, le) {
    O.onWarning && O.onWarning.call(null, ie(O, le));
  }
  var se = {
    YAML: function(le, me, Ne) {
      var _e, $e, Ae;
      le.version !== null && W(le, "duplication of %YAML directive"), Ne.length !== 1 && W(le, "YAML directive accepts exactly one argument"), _e = /^([0-9]+)\.([0-9]+)$/.exec(Ne[0]), _e === null && W(le, "ill-formed argument of the YAML directive"), $e = parseInt(_e[1], 10), Ae = parseInt(_e[2], 10), $e !== 1 && W(le, "unacceptable YAML version of the document"), le.version = Ne[0], le.checkLineBreaks = Ae < 2, Ae !== 1 && Ae !== 2 && ae(le, "unsupported YAML version of the document");
    },
    TAG: function(le, me, Ne) {
      var _e, $e;
      Ne.length !== 2 && W(le, "TAG directive accepts exactly two arguments"), _e = Ne[0], $e = Ne[1], m.test(_e) || W(le, "ill-formed tag handle (first argument) of the TAG directive"), i.call(le.tagMap, _e) && W(le, 'there is a previously declared suffix for "' + _e + '" tag handle'), h.test($e) || W(le, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        $e = decodeURIComponent($e);
      } catch {
        W(le, "tag prefix is malformed: " + $e);
      }
      le.tagMap[_e] = $e;
    }
  };
  function X(O, le, me, Ne) {
    var _e, $e, Ae, De;
    if (le < me) {
      if (De = O.input.slice(le, me), Ne)
        for (_e = 0, $e = De.length; _e < $e; _e += 1)
          Ae = De.charCodeAt(_e), Ae === 9 || 32 <= Ae && Ae <= 1114111 || W(O, "expected valid JSON character");
      else f.test(De) && W(O, "the stream contains non-printable characters");
      O.result += De;
    }
  }
  function k(O, le, me, Ne) {
    var _e, $e, Ae, De;
    for (e.isObject(me) || W(O, "cannot merge mappings; the provided source object is unacceptable"), _e = Object.keys(me), Ae = 0, De = _e.length; Ae < De; Ae += 1)
      $e = _e[Ae], i.call(le, $e) || (F(le, $e, me[$e]), Ne[$e] = !0);
  }
  function I(O, le, me, Ne, _e, $e, Ae, De, Me) {
    var it, at;
    if (Array.isArray(_e))
      for (_e = Array.prototype.slice.call(_e), it = 0, at = _e.length; it < at; it += 1)
        Array.isArray(_e[it]) && W(O, "nested arrays are not supported inside keys"), typeof _e == "object" && _(_e[it]) === "[object Object]" && (_e[it] = "[object Object]");
    if (typeof _e == "object" && _(_e) === "[object Object]" && (_e = "[object Object]"), _e = String(_e), le === null && (le = {}), Ne === "tag:yaml.org,2002:merge")
      if (Array.isArray($e))
        for (it = 0, at = $e.length; it < at; it += 1)
          k(O, le, $e[it], me);
      else
        k(O, le, $e, me);
    else
      !O.json && !i.call(me, _e) && i.call(le, _e) && (O.line = Ae || O.line, O.lineStart = De || O.lineStart, O.position = Me || O.position, W(O, "duplicated mapping key")), F(le, _e, $e), delete me[_e];
    return le;
  }
  function C(O) {
    var le;
    le = O.input.charCodeAt(O.position), le === 10 ? O.position++ : le === 13 ? (O.position++, O.input.charCodeAt(O.position) === 10 && O.position++) : W(O, "a line break is expected"), O.line += 1, O.lineStart = O.position, O.firstTabInLine = -1;
  }
  function T(O, le, me) {
    for (var Ne = 0, _e = O.input.charCodeAt(O.position); _e !== 0; ) {
      for (; y(_e); )
        _e === 9 && O.firstTabInLine === -1 && (O.firstTabInLine = O.position), _e = O.input.charCodeAt(++O.position);
      if (le && _e === 35)
        do
          _e = O.input.charCodeAt(++O.position);
        while (_e !== 10 && _e !== 13 && _e !== 0);
      if (g(_e))
        for (C(O), _e = O.input.charCodeAt(O.position), Ne++, O.lineIndent = 0; _e === 32; )
          O.lineIndent++, _e = O.input.charCodeAt(++O.position);
      else
        break;
    }
    return me !== -1 && Ne !== 0 && O.lineIndent < me && ae(O, "deficient indentation"), Ne;
  }
  function A(O) {
    var le = O.position, me;
    return me = O.input.charCodeAt(le), !!((me === 45 || me === 46) && me === O.input.charCodeAt(le + 1) && me === O.input.charCodeAt(le + 2) && (le += 3, me = O.input.charCodeAt(le), me === 0 || x(me)));
  }
  function L(O, le) {
    le === 1 ? O.result += " " : le > 1 && (O.result += e.repeat(`
`, le - 1));
  }
  function b(O, le, me) {
    var Ne, _e, $e, Ae, De, Me, it, at, je = O.kind, z = O.result, he;
    if (he = O.input.charCodeAt(O.position), x(he) || S(he) || he === 35 || he === 38 || he === 42 || he === 33 || he === 124 || he === 62 || he === 39 || he === 34 || he === 37 || he === 64 || he === 96 || (he === 63 || he === 45) && (_e = O.input.charCodeAt(O.position + 1), x(_e) || me && S(_e)))
      return !1;
    for (O.kind = "scalar", O.result = "", $e = Ae = O.position, De = !1; he !== 0; ) {
      if (he === 58) {
        if (_e = O.input.charCodeAt(O.position + 1), x(_e) || me && S(_e))
          break;
      } else if (he === 35) {
        if (Ne = O.input.charCodeAt(O.position - 1), x(Ne))
          break;
      } else {
        if (O.position === O.lineStart && A(O) || me && S(he))
          break;
        if (g(he))
          if (Me = O.line, it = O.lineStart, at = O.lineIndent, T(O, !1, -1), O.lineIndent >= le) {
            De = !0, he = O.input.charCodeAt(O.position);
            continue;
          } else {
            O.position = Ae, O.line = Me, O.lineStart = it, O.lineIndent = at;
            break;
          }
      }
      De && (X(O, $e, Ae, !1), L(O, O.line - Me), $e = Ae = O.position, De = !1), y(he) || (Ae = O.position + 1), he = O.input.charCodeAt(++O.position);
    }
    return X(O, $e, Ae, !1), O.result ? !0 : (O.kind = je, O.result = z, !1);
  }
  function P(O, le) {
    var me, Ne, _e;
    if (me = O.input.charCodeAt(O.position), me !== 39)
      return !1;
    for (O.kind = "scalar", O.result = "", O.position++, Ne = _e = O.position; (me = O.input.charCodeAt(O.position)) !== 0; )
      if (me === 39)
        if (X(O, Ne, O.position, !0), me = O.input.charCodeAt(++O.position), me === 39)
          Ne = O.position, O.position++, _e = O.position;
        else
          return !0;
      else g(me) ? (X(O, Ne, _e, !0), L(O, T(O, !1, le)), Ne = _e = O.position) : O.position === O.lineStart && A(O) ? W(O, "unexpected end of the document within a single quoted scalar") : (O.position++, _e = O.position);
    W(O, "unexpected end of the stream within a single quoted scalar");
  }
  function te(O, le) {
    var me, Ne, _e, $e, Ae, De;
    if (De = O.input.charCodeAt(O.position), De !== 34)
      return !1;
    for (O.kind = "scalar", O.result = "", O.position++, me = Ne = O.position; (De = O.input.charCodeAt(O.position)) !== 0; ) {
      if (De === 34)
        return X(O, me, O.position, !0), O.position++, !0;
      if (De === 92) {
        if (X(O, me, O.position, !0), De = O.input.charCodeAt(++O.position), g(De))
          T(O, !1, le);
        else if (De < 256 && U[De])
          O.result += G[De], O.position++;
        else if ((Ae = E(De)) > 0) {
          for (_e = Ae, $e = 0; _e > 0; _e--)
            De = O.input.charCodeAt(++O.position), (Ae = w(De)) >= 0 ? $e = ($e << 4) + Ae : W(O, "expected hexadecimal character");
          O.result += B($e), O.position++;
        } else
          W(O, "unknown escape sequence");
        me = Ne = O.position;
      } else g(De) ? (X(O, me, Ne, !0), L(O, T(O, !1, le)), me = Ne = O.position) : O.position === O.lineStart && A(O) ? W(O, "unexpected end of the document within a double quoted scalar") : (O.position++, Ne = O.position);
    }
    W(O, "unexpected end of the stream within a double quoted scalar");
  }
  function H(O, le) {
    var me = !0, Ne, _e, $e, Ae = O.tag, De, Me = O.anchor, it, at, je, z, he, we = /* @__PURE__ */ Object.create(null), xe, Te, ke, Pe;
    if (Pe = O.input.charCodeAt(O.position), Pe === 91)
      at = 93, he = !1, De = [];
    else if (Pe === 123)
      at = 125, he = !0, De = {};
    else
      return !1;
    for (O.anchor !== null && (O.anchorMap[O.anchor] = De), Pe = O.input.charCodeAt(++O.position); Pe !== 0; ) {
      if (T(O, !0, le), Pe = O.input.charCodeAt(O.position), Pe === at)
        return O.position++, O.tag = Ae, O.anchor = Me, O.kind = he ? "mapping" : "sequence", O.result = De, !0;
      me ? Pe === 44 && W(O, "expected the node content, but found ','") : W(O, "missed comma between flow collection entries"), Te = xe = ke = null, je = z = !1, Pe === 63 && (it = O.input.charCodeAt(O.position + 1), x(it) && (je = z = !0, O.position++, T(O, !0, le))), Ne = O.line, _e = O.lineStart, $e = O.position, ge(O, le, a, !1, !0), Te = O.tag, xe = O.result, T(O, !0, le), Pe = O.input.charCodeAt(O.position), (z || O.line === Ne) && Pe === 58 && (je = !0, Pe = O.input.charCodeAt(++O.position), T(O, !0, le), ge(O, le, a, !1, !0), ke = O.result), he ? I(O, De, we, Te, xe, ke, Ne, _e, $e) : je ? De.push(I(O, null, we, Te, xe, ke, Ne, _e, $e)) : De.push(xe), T(O, !0, le), Pe = O.input.charCodeAt(O.position), Pe === 44 ? (me = !0, Pe = O.input.charCodeAt(++O.position)) : me = !1;
    }
    W(O, "unexpected end of the stream within a flow collection");
  }
  function D(O, le) {
    var me, Ne, _e = u, $e = !1, Ae = !1, De = le, Me = 0, it = !1, at, je;
    if (je = O.input.charCodeAt(O.position), je === 124)
      Ne = !1;
    else if (je === 62)
      Ne = !0;
    else
      return !1;
    for (O.kind = "scalar", O.result = ""; je !== 0; )
      if (je = O.input.charCodeAt(++O.position), je === 43 || je === 45)
        u === _e ? _e = je === 43 ? d : l : W(O, "repeat of a chomping mode identifier");
      else if ((at = R(je)) >= 0)
        at === 0 ? W(O, "bad explicit indentation width of a block scalar; it cannot be less than one") : Ae ? W(O, "repeat of an indentation width identifier") : (De = le + at - 1, Ae = !0);
      else
        break;
    if (y(je)) {
      do
        je = O.input.charCodeAt(++O.position);
      while (y(je));
      if (je === 35)
        do
          je = O.input.charCodeAt(++O.position);
        while (!g(je) && je !== 0);
    }
    for (; je !== 0; ) {
      for (C(O), O.lineIndent = 0, je = O.input.charCodeAt(O.position); (!Ae || O.lineIndent < De) && je === 32; )
        O.lineIndent++, je = O.input.charCodeAt(++O.position);
      if (!Ae && O.lineIndent > De && (De = O.lineIndent), g(je)) {
        Me++;
        continue;
      }
      if (O.lineIndent < De) {
        _e === d ? O.result += e.repeat(`
`, $e ? 1 + Me : Me) : _e === u && $e && (O.result += `
`);
        break;
      }
      for (Ne ? y(je) ? (it = !0, O.result += e.repeat(`
`, $e ? 1 + Me : Me)) : it ? (it = !1, O.result += e.repeat(`
`, Me + 1)) : Me === 0 ? $e && (O.result += " ") : O.result += e.repeat(`
`, Me) : O.result += e.repeat(`
`, $e ? 1 + Me : Me), $e = !0, Ae = !0, Me = 0, me = O.position; !g(je) && je !== 0; )
        je = O.input.charCodeAt(++O.position);
      X(O, me, O.position, !1);
    }
    return !0;
  }
  function q(O, le) {
    var me, Ne = O.tag, _e = O.anchor, $e = [], Ae, De = !1, Me;
    if (O.firstTabInLine !== -1) return !1;
    for (O.anchor !== null && (O.anchorMap[O.anchor] = $e), Me = O.input.charCodeAt(O.position); Me !== 0 && (O.firstTabInLine !== -1 && (O.position = O.firstTabInLine, W(O, "tab characters must not be used in indentation")), !(Me !== 45 || (Ae = O.input.charCodeAt(O.position + 1), !x(Ae)))); ) {
      if (De = !0, O.position++, T(O, !0, -1) && O.lineIndent <= le) {
        $e.push(null), Me = O.input.charCodeAt(O.position);
        continue;
      }
      if (me = O.line, ge(O, le, o, !1, !0), $e.push(O.result), T(O, !0, -1), Me = O.input.charCodeAt(O.position), (O.line === me || O.lineIndent > le) && Me !== 0)
        W(O, "bad indentation of a sequence entry");
      else if (O.lineIndent < le)
        break;
    }
    return De ? (O.tag = Ne, O.anchor = _e, O.kind = "sequence", O.result = $e, !0) : !1;
  }
  function J(O, le, me) {
    var Ne, _e, $e, Ae, De, Me, it = O.tag, at = O.anchor, je = {}, z = /* @__PURE__ */ Object.create(null), he = null, we = null, xe = null, Te = !1, ke = !1, Pe;
    if (O.firstTabInLine !== -1) return !1;
    for (O.anchor !== null && (O.anchorMap[O.anchor] = je), Pe = O.input.charCodeAt(O.position); Pe !== 0; ) {
      if (!Te && O.firstTabInLine !== -1 && (O.position = O.firstTabInLine, W(O, "tab characters must not be used in indentation")), Ne = O.input.charCodeAt(O.position + 1), $e = O.line, (Pe === 63 || Pe === 58) && x(Ne))
        Pe === 63 ? (Te && (I(O, je, z, he, we, null, Ae, De, Me), he = we = xe = null), ke = !0, Te = !0, _e = !0) : Te ? (Te = !1, _e = !0) : W(O, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), O.position += 1, Pe = Ne;
      else {
        if (Ae = O.line, De = O.lineStart, Me = O.position, !ge(O, me, s, !1, !0))
          break;
        if (O.line === $e) {
          for (Pe = O.input.charCodeAt(O.position); y(Pe); )
            Pe = O.input.charCodeAt(++O.position);
          if (Pe === 58)
            Pe = O.input.charCodeAt(++O.position), x(Pe) || W(O, "a whitespace character is expected after the key-value separator within a block mapping"), Te && (I(O, je, z, he, we, null, Ae, De, Me), he = we = xe = null), ke = !0, Te = !1, _e = !1, he = O.tag, we = O.result;
          else if (ke)
            W(O, "can not read an implicit mapping pair; a colon is missed");
          else
            return O.tag = it, O.anchor = at, !0;
        } else if (ke)
          W(O, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return O.tag = it, O.anchor = at, !0;
      }
      if ((O.line === $e || O.lineIndent > le) && (Te && (Ae = O.line, De = O.lineStart, Me = O.position), ge(O, le, c, !0, _e) && (Te ? we = O.result : xe = O.result), Te || (I(O, je, z, he, we, xe, Ae, De, Me), he = we = xe = null), T(O, !0, -1), Pe = O.input.charCodeAt(O.position)), (O.line === $e || O.lineIndent > le) && Pe !== 0)
        W(O, "bad indentation of a mapping entry");
      else if (O.lineIndent < le)
        break;
    }
    return Te && I(O, je, z, he, we, null, Ae, De, Me), ke && (O.tag = it, O.anchor = at, O.kind = "mapping", O.result = je), ke;
  }
  function ne(O) {
    var le, me = !1, Ne = !1, _e, $e, Ae;
    if (Ae = O.input.charCodeAt(O.position), Ae !== 33) return !1;
    if (O.tag !== null && W(O, "duplication of a tag property"), Ae = O.input.charCodeAt(++O.position), Ae === 60 ? (me = !0, Ae = O.input.charCodeAt(++O.position)) : Ae === 33 ? (Ne = !0, _e = "!!", Ae = O.input.charCodeAt(++O.position)) : _e = "!", le = O.position, me) {
      do
        Ae = O.input.charCodeAt(++O.position);
      while (Ae !== 0 && Ae !== 62);
      O.position < O.length ? ($e = O.input.slice(le, O.position), Ae = O.input.charCodeAt(++O.position)) : W(O, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; Ae !== 0 && !x(Ae); )
        Ae === 33 && (Ne ? W(O, "tag suffix cannot contain exclamation marks") : (_e = O.input.slice(le - 1, O.position + 1), m.test(_e) || W(O, "named tag handle cannot contain such characters"), Ne = !0, le = O.position + 1)), Ae = O.input.charCodeAt(++O.position);
      $e = O.input.slice(le, O.position), v.test($e) && W(O, "tag suffix cannot contain flow indicator characters");
    }
    $e && !h.test($e) && W(O, "tag name cannot contain such characters: " + $e);
    try {
      $e = decodeURIComponent($e);
    } catch {
      W(O, "tag name is malformed: " + $e);
    }
    return me ? O.tag = $e : i.call(O.tagMap, _e) ? O.tag = O.tagMap[_e] + $e : _e === "!" ? O.tag = "!" + $e : _e === "!!" ? O.tag = "tag:yaml.org,2002:" + $e : W(O, 'undeclared tag handle "' + _e + '"'), !0;
  }
  function ce(O) {
    var le, me;
    if (me = O.input.charCodeAt(O.position), me !== 38) return !1;
    for (O.anchor !== null && W(O, "duplication of an anchor property"), me = O.input.charCodeAt(++O.position), le = O.position; me !== 0 && !x(me) && !S(me); )
      me = O.input.charCodeAt(++O.position);
    return O.position === le && W(O, "name of an anchor node must contain at least one character"), O.anchor = O.input.slice(le, O.position), !0;
  }
  function Ee(O) {
    var le, me, Ne;
    if (Ne = O.input.charCodeAt(O.position), Ne !== 42) return !1;
    for (Ne = O.input.charCodeAt(++O.position), le = O.position; Ne !== 0 && !x(Ne) && !S(Ne); )
      Ne = O.input.charCodeAt(++O.position);
    return O.position === le && W(O, "name of an alias node must contain at least one character"), me = O.input.slice(le, O.position), i.call(O.anchorMap, me) || W(O, 'unidentified alias "' + me + '"'), O.result = O.anchorMap[me], T(O, !0, -1), !0;
  }
  function ge(O, le, me, Ne, _e) {
    var $e, Ae, De, Me = 1, it = !1, at = !1, je, z, he, we, xe, Te;
    if (O.listener !== null && O.listener("open", O), O.tag = null, O.anchor = null, O.kind = null, O.result = null, $e = Ae = De = c === me || o === me, Ne && T(O, !0, -1) && (it = !0, O.lineIndent > le ? Me = 1 : O.lineIndent === le ? Me = 0 : O.lineIndent < le && (Me = -1)), Me === 1)
      for (; ne(O) || ce(O); )
        T(O, !0, -1) ? (it = !0, De = $e, O.lineIndent > le ? Me = 1 : O.lineIndent === le ? Me = 0 : O.lineIndent < le && (Me = -1)) : De = !1;
    if (De && (De = it || _e), (Me === 1 || c === me) && (a === me || s === me ? xe = le : xe = le + 1, Te = O.position - O.lineStart, Me === 1 ? De && (q(O, Te) || J(O, Te, xe)) || H(O, xe) ? at = !0 : (Ae && D(O, xe) || P(O, xe) || te(O, xe) ? at = !0 : Ee(O) ? (at = !0, (O.tag !== null || O.anchor !== null) && W(O, "alias node should not have any properties")) : b(O, xe, a === me) && (at = !0, O.tag === null && (O.tag = "?")), O.anchor !== null && (O.anchorMap[O.anchor] = O.result)) : Me === 0 && (at = De && q(O, Te))), O.tag === null)
      O.anchor !== null && (O.anchorMap[O.anchor] = O.result);
    else if (O.tag === "?") {
      for (O.result !== null && O.kind !== "scalar" && W(O, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + O.kind + '"'), je = 0, z = O.implicitTypes.length; je < z; je += 1)
        if (we = O.implicitTypes[je], we.resolve(O.result)) {
          O.result = we.construct(O.result), O.tag = we.tag, O.anchor !== null && (O.anchorMap[O.anchor] = O.result);
          break;
        }
    } else if (O.tag !== "!") {
      if (i.call(O.typeMap[O.kind || "fallback"], O.tag))
        we = O.typeMap[O.kind || "fallback"][O.tag];
      else
        for (we = null, he = O.typeMap.multi[O.kind || "fallback"], je = 0, z = he.length; je < z; je += 1)
          if (O.tag.slice(0, he[je].tag.length) === he[je].tag) {
            we = he[je];
            break;
          }
      we || W(O, "unknown tag !<" + O.tag + ">"), O.result !== null && we.kind !== O.kind && W(O, "unacceptable node kind for !<" + O.tag + '> tag; it should be "' + we.kind + '", not "' + O.kind + '"'), we.resolve(O.result, O.tag) ? (O.result = we.construct(O.result, O.tag), O.anchor !== null && (O.anchorMap[O.anchor] = O.result)) : W(O, "cannot resolve a node with !<" + O.tag + "> explicit tag");
    }
    return O.listener !== null && O.listener("close", O), O.tag !== null || O.anchor !== null || at;
  }
  function Ge(O) {
    var le = O.position, me, Ne, _e, $e = !1, Ae;
    for (O.version = null, O.checkLineBreaks = O.legacy, O.tagMap = /* @__PURE__ */ Object.create(null), O.anchorMap = /* @__PURE__ */ Object.create(null); (Ae = O.input.charCodeAt(O.position)) !== 0 && (T(O, !0, -1), Ae = O.input.charCodeAt(O.position), !(O.lineIndent > 0 || Ae !== 37)); ) {
      for ($e = !0, Ae = O.input.charCodeAt(++O.position), me = O.position; Ae !== 0 && !x(Ae); )
        Ae = O.input.charCodeAt(++O.position);
      for (Ne = O.input.slice(me, O.position), _e = [], Ne.length < 1 && W(O, "directive name must not be less than one character in length"); Ae !== 0; ) {
        for (; y(Ae); )
          Ae = O.input.charCodeAt(++O.position);
        if (Ae === 35) {
          do
            Ae = O.input.charCodeAt(++O.position);
          while (Ae !== 0 && !g(Ae));
          break;
        }
        if (g(Ae)) break;
        for (me = O.position; Ae !== 0 && !x(Ae); )
          Ae = O.input.charCodeAt(++O.position);
        _e.push(O.input.slice(me, O.position));
      }
      Ae !== 0 && C(O), i.call(se, Ne) ? se[Ne](O, Ne, _e) : ae(O, 'unknown document directive "' + Ne + '"');
    }
    if (T(O, !0, -1), O.lineIndent === 0 && O.input.charCodeAt(O.position) === 45 && O.input.charCodeAt(O.position + 1) === 45 && O.input.charCodeAt(O.position + 2) === 45 ? (O.position += 3, T(O, !0, -1)) : $e && W(O, "directives end mark is expected"), ge(O, O.lineIndent - 1, c, !1, !0), T(O, !0, -1), O.checkLineBreaks && p.test(O.input.slice(le, O.position)) && ae(O, "non-ASCII line breaks are interpreted as content"), O.documents.push(O.result), O.position === O.lineStart && A(O)) {
      O.input.charCodeAt(O.position) === 46 && (O.position += 3, T(O, !0, -1));
      return;
    }
    if (O.position < O.length - 1)
      W(O, "end of the stream or a document separator is expected");
    else
      return;
  }
  function ze(O, le) {
    O = String(O), le = le || {}, O.length !== 0 && (O.charCodeAt(O.length - 1) !== 10 && O.charCodeAt(O.length - 1) !== 13 && (O += `
`), O.charCodeAt(0) === 65279 && (O = O.slice(1)));
    var me = new V(O, le), Ne = O.indexOf("\0");
    for (Ne !== -1 && (me.position = Ne, W(me, "null byte is not allowed in input")), me.input += "\0"; me.input.charCodeAt(me.position) === 32; )
      me.lineIndent += 1, me.position += 1;
    for (; me.position < me.length - 1; )
      Ge(me);
    return me.documents;
  }
  function Xe(O, le, me) {
    le !== null && typeof le == "object" && typeof me > "u" && (me = le, le = null);
    var Ne = ze(O, me);
    if (typeof le != "function")
      return Ne;
    for (var _e = 0, $e = Ne.length; _e < $e; _e += 1)
      le(Ne[_e]);
  }
  function He(O, le) {
    var me = ze(O, le);
    if (me.length !== 0) {
      if (me.length === 1)
        return me[0];
      throw new t("expected a single document in the stream, but found more");
    }
  }
  return $s.loadAll = Xe, $s.load = He, $s;
}
var Lu = {}, Wp;
function nS() {
  if (Wp) return Lu;
  Wp = 1;
  var e = rs(), t = ns(), r = _0(), n = Object.prototype.toString, i = Object.prototype.hasOwnProperty, a = 65279, s = 9, o = 10, c = 13, u = 32, l = 33, d = 34, f = 35, p = 37, v = 38, m = 39, h = 42, _ = 44, g = 45, y = 58, x = 61, S = 62, w = 63, E = 64, R = 91, N = 93, B = 96, F = 123, U = 124, G = 125, M = {};
  M[0] = "\\0", M[7] = "\\a", M[8] = "\\b", M[9] = "\\t", M[10] = "\\n", M[11] = "\\v", M[12] = "\\f", M[13] = "\\r", M[27] = "\\e", M[34] = '\\"', M[92] = "\\\\", M[133] = "\\N", M[160] = "\\_", M[8232] = "\\L", M[8233] = "\\P";
  var V = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], ie = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function W(z, he) {
    var we, xe, Te, ke, Pe, Ue, Ve;
    if (he === null) return {};
    for (we = {}, xe = Object.keys(he), Te = 0, ke = xe.length; Te < ke; Te += 1)
      Pe = xe[Te], Ue = String(he[Pe]), Pe.slice(0, 2) === "!!" && (Pe = "tag:yaml.org,2002:" + Pe.slice(2)), Ve = z.compiledTypeMap.fallback[Pe], Ve && i.call(Ve.styleAliases, Ue) && (Ue = Ve.styleAliases[Ue]), we[Pe] = Ue;
    return we;
  }
  function ae(z) {
    var he, we, xe;
    if (he = z.toString(16).toUpperCase(), z <= 255)
      we = "x", xe = 2;
    else if (z <= 65535)
      we = "u", xe = 4;
    else if (z <= 4294967295)
      we = "U", xe = 8;
    else
      throw new t("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + we + e.repeat("0", xe - he.length) + he;
  }
  var se = 1, X = 2;
  function k(z) {
    this.schema = z.schema || r, this.indent = Math.max(1, z.indent || 2), this.noArrayIndent = z.noArrayIndent || !1, this.skipInvalid = z.skipInvalid || !1, this.flowLevel = e.isNothing(z.flowLevel) ? -1 : z.flowLevel, this.styleMap = W(this.schema, z.styles || null), this.sortKeys = z.sortKeys || !1, this.lineWidth = z.lineWidth || 80, this.noRefs = z.noRefs || !1, this.noCompatMode = z.noCompatMode || !1, this.condenseFlow = z.condenseFlow || !1, this.quotingType = z.quotingType === '"' ? X : se, this.forceQuotes = z.forceQuotes || !1, this.replacer = typeof z.replacer == "function" ? z.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function I(z, he) {
    for (var we = e.repeat(" ", he), xe = 0, Te = -1, ke = "", Pe, Ue = z.length; xe < Ue; )
      Te = z.indexOf(`
`, xe), Te === -1 ? (Pe = z.slice(xe), xe = Ue) : (Pe = z.slice(xe, Te + 1), xe = Te + 1), Pe.length && Pe !== `
` && (ke += we), ke += Pe;
    return ke;
  }
  function C(z, he) {
    return `
` + e.repeat(" ", z.indent * he);
  }
  function T(z, he) {
    var we, xe, Te;
    for (we = 0, xe = z.implicitTypes.length; we < xe; we += 1)
      if (Te = z.implicitTypes[we], Te.resolve(he))
        return !0;
    return !1;
  }
  function A(z) {
    return z === u || z === s;
  }
  function L(z) {
    return 32 <= z && z <= 126 || 161 <= z && z <= 55295 && z !== 8232 && z !== 8233 || 57344 <= z && z <= 65533 && z !== a || 65536 <= z && z <= 1114111;
  }
  function b(z) {
    return L(z) && z !== a && z !== c && z !== o;
  }
  function P(z, he, we) {
    var xe = b(z), Te = xe && !A(z);
    return (
      // ns-plain-safe
      (we ? (
        // c = flow-in
        xe
      ) : xe && z !== _ && z !== R && z !== N && z !== F && z !== G) && z !== f && !(he === y && !Te) || b(he) && !A(he) && z === f || he === y && Te
    );
  }
  function te(z) {
    return L(z) && z !== a && !A(z) && z !== g && z !== w && z !== y && z !== _ && z !== R && z !== N && z !== F && z !== G && z !== f && z !== v && z !== h && z !== l && z !== U && z !== x && z !== S && z !== m && z !== d && z !== p && z !== E && z !== B;
  }
  function H(z) {
    return !A(z) && z !== y;
  }
  function D(z, he) {
    var we = z.charCodeAt(he), xe;
    return we >= 55296 && we <= 56319 && he + 1 < z.length && (xe = z.charCodeAt(he + 1), xe >= 56320 && xe <= 57343) ? (we - 55296) * 1024 + xe - 56320 + 65536 : we;
  }
  function q(z) {
    var he = /^\n* /;
    return he.test(z);
  }
  var J = 1, ne = 2, ce = 3, Ee = 4, ge = 5;
  function Ge(z, he, we, xe, Te, ke, Pe, Ue) {
    var Ve, We = 0, yt = null, Rt = !1, ot = !1, $n = xe !== -1, wr = -1, ln = te(D(z, 0)) && H(D(z, z.length - 1));
    if (he || Pe)
      for (Ve = 0; Ve < z.length; We >= 65536 ? Ve += 2 : Ve++) {
        if (We = D(z, Ve), !L(We))
          return ge;
        ln = ln && P(We, yt, Ue), yt = We;
      }
    else {
      for (Ve = 0; Ve < z.length; We >= 65536 ? Ve += 2 : Ve++) {
        if (We = D(z, Ve), We === o)
          Rt = !0, $n && (ot = ot || // Foldable line = too long, and not more-indented.
          Ve - wr - 1 > xe && z[wr + 1] !== " ", wr = Ve);
        else if (!L(We))
          return ge;
        ln = ln && P(We, yt, Ue), yt = We;
      }
      ot = ot || $n && Ve - wr - 1 > xe && z[wr + 1] !== " ";
    }
    return !Rt && !ot ? ln && !Pe && !Te(z) ? J : ke === X ? ge : ne : we > 9 && q(z) ? ge : Pe ? ke === X ? ge : ne : ot ? Ee : ce;
  }
  function ze(z, he, we, xe, Te) {
    z.dump = (function() {
      if (he.length === 0)
        return z.quotingType === X ? '""' : "''";
      if (!z.noCompatMode && (V.indexOf(he) !== -1 || ie.test(he)))
        return z.quotingType === X ? '"' + he + '"' : "'" + he + "'";
      var ke = z.indent * Math.max(1, we), Pe = z.lineWidth === -1 ? -1 : Math.max(Math.min(z.lineWidth, 40), z.lineWidth - ke), Ue = xe || z.flowLevel > -1 && we >= z.flowLevel;
      function Ve(We) {
        return T(z, We);
      }
      switch (Ge(
        he,
        Ue,
        z.indent,
        Pe,
        Ve,
        z.quotingType,
        z.forceQuotes && !xe,
        Te
      )) {
        case J:
          return he;
        case ne:
          return "'" + he.replace(/'/g, "''") + "'";
        case ce:
          return "|" + Xe(he, z.indent) + He(I(he, ke));
        case Ee:
          return ">" + Xe(he, z.indent) + He(I(O(he, Pe), ke));
        case ge:
          return '"' + me(he) + '"';
        default:
          throw new t("impossible error: invalid scalar style");
      }
    })();
  }
  function Xe(z, he) {
    var we = q(z) ? String(he) : "", xe = z[z.length - 1] === `
`, Te = xe && (z[z.length - 2] === `
` || z === `
`), ke = Te ? "+" : xe ? "" : "-";
    return we + ke + `
`;
  }
  function He(z) {
    return z[z.length - 1] === `
` ? z.slice(0, -1) : z;
  }
  function O(z, he) {
    for (var we = /(\n+)([^\n]*)/g, xe = (function() {
      var We = z.indexOf(`
`);
      return We = We !== -1 ? We : z.length, we.lastIndex = We, le(z.slice(0, We), he);
    })(), Te = z[0] === `
` || z[0] === " ", ke, Pe; Pe = we.exec(z); ) {
      var Ue = Pe[1], Ve = Pe[2];
      ke = Ve[0] === " ", xe += Ue + (!Te && !ke && Ve !== "" ? `
` : "") + le(Ve, he), Te = ke;
    }
    return xe;
  }
  function le(z, he) {
    if (z === "" || z[0] === " ") return z;
    for (var we = / [^ ]/g, xe, Te = 0, ke, Pe = 0, Ue = 0, Ve = ""; xe = we.exec(z); )
      Ue = xe.index, Ue - Te > he && (ke = Pe > Te ? Pe : Ue, Ve += `
` + z.slice(Te, ke), Te = ke + 1), Pe = Ue;
    return Ve += `
`, z.length - Te > he && Pe > Te ? Ve += z.slice(Te, Pe) + `
` + z.slice(Pe + 1) : Ve += z.slice(Te), Ve.slice(1);
  }
  function me(z) {
    for (var he = "", we = 0, xe, Te = 0; Te < z.length; we >= 65536 ? Te += 2 : Te++)
      we = D(z, Te), xe = M[we], !xe && L(we) ? (he += z[Te], we >= 65536 && (he += z[Te + 1])) : he += xe || ae(we);
    return he;
  }
  function Ne(z, he, we) {
    var xe = "", Te = z.tag, ke, Pe, Ue;
    for (ke = 0, Pe = we.length; ke < Pe; ke += 1)
      Ue = we[ke], z.replacer && (Ue = z.replacer.call(we, String(ke), Ue)), (Me(z, he, Ue, !1, !1) || typeof Ue > "u" && Me(z, he, null, !1, !1)) && (xe !== "" && (xe += "," + (z.condenseFlow ? "" : " ")), xe += z.dump);
    z.tag = Te, z.dump = "[" + xe + "]";
  }
  function _e(z, he, we, xe) {
    var Te = "", ke = z.tag, Pe, Ue, Ve;
    for (Pe = 0, Ue = we.length; Pe < Ue; Pe += 1)
      Ve = we[Pe], z.replacer && (Ve = z.replacer.call(we, String(Pe), Ve)), (Me(z, he + 1, Ve, !0, !0, !1, !0) || typeof Ve > "u" && Me(z, he + 1, null, !0, !0, !1, !0)) && ((!xe || Te !== "") && (Te += C(z, he)), z.dump && o === z.dump.charCodeAt(0) ? Te += "-" : Te += "- ", Te += z.dump);
    z.tag = ke, z.dump = Te || "[]";
  }
  function $e(z, he, we) {
    var xe = "", Te = z.tag, ke = Object.keys(we), Pe, Ue, Ve, We, yt;
    for (Pe = 0, Ue = ke.length; Pe < Ue; Pe += 1)
      yt = "", xe !== "" && (yt += ", "), z.condenseFlow && (yt += '"'), Ve = ke[Pe], We = we[Ve], z.replacer && (We = z.replacer.call(we, Ve, We)), Me(z, he, Ve, !1, !1) && (z.dump.length > 1024 && (yt += "? "), yt += z.dump + (z.condenseFlow ? '"' : "") + ":" + (z.condenseFlow ? "" : " "), Me(z, he, We, !1, !1) && (yt += z.dump, xe += yt));
    z.tag = Te, z.dump = "{" + xe + "}";
  }
  function Ae(z, he, we, xe) {
    var Te = "", ke = z.tag, Pe = Object.keys(we), Ue, Ve, We, yt, Rt, ot;
    if (z.sortKeys === !0)
      Pe.sort();
    else if (typeof z.sortKeys == "function")
      Pe.sort(z.sortKeys);
    else if (z.sortKeys)
      throw new t("sortKeys must be a boolean or a function");
    for (Ue = 0, Ve = Pe.length; Ue < Ve; Ue += 1)
      ot = "", (!xe || Te !== "") && (ot += C(z, he)), We = Pe[Ue], yt = we[We], z.replacer && (yt = z.replacer.call(we, We, yt)), Me(z, he + 1, We, !0, !0, !0) && (Rt = z.tag !== null && z.tag !== "?" || z.dump && z.dump.length > 1024, Rt && (z.dump && o === z.dump.charCodeAt(0) ? ot += "?" : ot += "? "), ot += z.dump, Rt && (ot += C(z, he)), Me(z, he + 1, yt, !0, Rt) && (z.dump && o === z.dump.charCodeAt(0) ? ot += ":" : ot += ": ", ot += z.dump, Te += ot));
    z.tag = ke, z.dump = Te || "{}";
  }
  function De(z, he, we) {
    var xe, Te, ke, Pe, Ue, Ve;
    for (Te = we ? z.explicitTypes : z.implicitTypes, ke = 0, Pe = Te.length; ke < Pe; ke += 1)
      if (Ue = Te[ke], (Ue.instanceOf || Ue.predicate) && (!Ue.instanceOf || typeof he == "object" && he instanceof Ue.instanceOf) && (!Ue.predicate || Ue.predicate(he))) {
        if (we ? Ue.multi && Ue.representName ? z.tag = Ue.representName(he) : z.tag = Ue.tag : z.tag = "?", Ue.represent) {
          if (Ve = z.styleMap[Ue.tag] || Ue.defaultStyle, n.call(Ue.represent) === "[object Function]")
            xe = Ue.represent(he, Ve);
          else if (i.call(Ue.represent, Ve))
            xe = Ue.represent[Ve](he, Ve);
          else
            throw new t("!<" + Ue.tag + '> tag resolver accepts not "' + Ve + '" style');
          z.dump = xe;
        }
        return !0;
      }
    return !1;
  }
  function Me(z, he, we, xe, Te, ke, Pe) {
    z.tag = null, z.dump = we, De(z, we, !1) || De(z, we, !0);
    var Ue = n.call(z.dump), Ve = xe, We;
    xe && (xe = z.flowLevel < 0 || z.flowLevel > he);
    var yt = Ue === "[object Object]" || Ue === "[object Array]", Rt, ot;
    if (yt && (Rt = z.duplicates.indexOf(we), ot = Rt !== -1), (z.tag !== null && z.tag !== "?" || ot || z.indent !== 2 && he > 0) && (Te = !1), ot && z.usedDuplicates[Rt])
      z.dump = "*ref_" + Rt;
    else {
      if (yt && ot && !z.usedDuplicates[Rt] && (z.usedDuplicates[Rt] = !0), Ue === "[object Object]")
        xe && Object.keys(z.dump).length !== 0 ? (Ae(z, he, z.dump, Te), ot && (z.dump = "&ref_" + Rt + z.dump)) : ($e(z, he, z.dump), ot && (z.dump = "&ref_" + Rt + " " + z.dump));
      else if (Ue === "[object Array]")
        xe && z.dump.length !== 0 ? (z.noArrayIndent && !Pe && he > 0 ? _e(z, he - 1, z.dump, Te) : _e(z, he, z.dump, Te), ot && (z.dump = "&ref_" + Rt + z.dump)) : (Ne(z, he, z.dump), ot && (z.dump = "&ref_" + Rt + " " + z.dump));
      else if (Ue === "[object String]")
        z.tag !== "?" && ze(z, z.dump, he, ke, Ve);
      else {
        if (Ue === "[object Undefined]")
          return !1;
        if (z.skipInvalid) return !1;
        throw new t("unacceptable kind of an object to dump " + Ue);
      }
      z.tag !== null && z.tag !== "?" && (We = encodeURI(
        z.tag[0] === "!" ? z.tag.slice(1) : z.tag
      ).replace(/!/g, "%21"), z.tag[0] === "!" ? We = "!" + We : We.slice(0, 18) === "tag:yaml.org,2002:" ? We = "!!" + We.slice(18) : We = "!<" + We + ">", z.dump = We + " " + z.dump);
    }
    return !0;
  }
  function it(z, he) {
    var we = [], xe = [], Te, ke;
    for (at(z, we, xe), Te = 0, ke = xe.length; Te < ke; Te += 1)
      he.duplicates.push(we[xe[Te]]);
    he.usedDuplicates = new Array(ke);
  }
  function at(z, he, we) {
    var xe, Te, ke;
    if (z !== null && typeof z == "object")
      if (Te = he.indexOf(z), Te !== -1)
        we.indexOf(Te) === -1 && we.push(Te);
      else if (he.push(z), Array.isArray(z))
        for (Te = 0, ke = z.length; Te < ke; Te += 1)
          at(z[Te], he, we);
      else
        for (xe = Object.keys(z), Te = 0, ke = xe.length; Te < ke; Te += 1)
          at(z[xe[Te]], he, we);
  }
  function je(z, he) {
    he = he || {};
    var we = new k(he);
    we.noRefs || it(z, we);
    var xe = z;
    return we.replacer && (xe = we.replacer.call({ "": xe }, "", xe)), Me(we, 0, xe, !0, !0) ? we.dump + `
` : "";
  }
  return Lu.dump = je, Lu;
}
var Xp;
function y0() {
  if (Xp) return tr;
  Xp = 1;
  var e = rS(), t = nS();
  function r(n, i) {
    return function() {
      throw new Error("Function yaml." + n + " is removed in js-yaml 4. Use yaml." + i + " instead, which is now safe by default.");
    };
  }
  return tr.Type = hr(), tr.Schema = sE(), tr.FAILSAFE_SCHEMA = uE(), tr.JSON_SCHEMA = mE(), tr.CORE_SCHEMA = gE(), tr.DEFAULT_SCHEMA = _0(), tr.load = e.load, tr.loadAll = e.loadAll, tr.dump = t.dump, tr.YAMLException = ns(), tr.types = {
    binary: yE(),
    float: pE(),
    map: lE(),
    null: fE(),
    pairs: wE(),
    set: xE(),
    timestamp: vE(),
    bool: dE(),
    int: hE(),
    merge: _E(),
    omap: EE(),
    seq: cE(),
    str: oE()
  }, tr.safeLoad = r("safeLoad", "load"), tr.safeLoadAll = r("safeLoadAll", "loadAll"), tr.safeDump = r("safeDump", "dump"), tr;
}
var ma = {}, Kp;
function iS() {
  if (Kp) return ma;
  Kp = 1, Object.defineProperty(ma, "__esModule", { value: !0 }), ma.Lazy = void 0;
  class e {
    constructor(r) {
      this._value = null, this.creator = r;
    }
    get hasValue() {
      return this.creator == null;
    }
    get value() {
      if (this.creator == null)
        return this._value;
      const r = this.creator();
      return this.value = r, r;
    }
    set value(r) {
      this._value = r, this.creator = null;
    }
  }
  return ma.Lazy = e, ma;
}
var Os = { exports: {} }, Mu, Yp;
function Zc() {
  if (Yp) return Mu;
  Yp = 1;
  const e = "2.0.0", t = 256, r = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, n = 16, i = t - 6;
  return Mu = {
    MAX_LENGTH: t,
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: i,
    MAX_SAFE_INTEGER: r,
    RELEASE_TYPES: [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ],
    SEMVER_SPEC_VERSION: e,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }, Mu;
}
var Uu, Jp;
function el() {
  return Jp || (Jp = 1, Uu = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
  }), Uu;
}
var Qp;
function is() {
  return Qp || (Qp = 1, (function(e, t) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: r,
      MAX_SAFE_BUILD_LENGTH: n,
      MAX_LENGTH: i
    } = Zc(), a = el();
    t = e.exports = {};
    const s = t.re = [], o = t.safeRe = [], c = t.src = [], u = t.safeSrc = [], l = t.t = {};
    let d = 0;
    const f = "[a-zA-Z0-9-]", p = [
      ["\\s", 1],
      ["\\d", i],
      [f, n]
    ], v = (h) => {
      for (const [_, g] of p)
        h = h.split(`${_}*`).join(`${_}{0,${g}}`).split(`${_}+`).join(`${_}{1,${g}}`);
      return h;
    }, m = (h, _, g) => {
      const y = v(_), x = d++;
      a(h, x, _), l[h] = x, c[x] = _, u[x] = y, s[x] = new RegExp(_, g ? "g" : void 0), o[x] = new RegExp(y, g ? "g" : void 0);
    };
    m("NUMERICIDENTIFIER", "0|[1-9]\\d*"), m("NUMERICIDENTIFIERLOOSE", "\\d+"), m("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`), m("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), m("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), m("PRERELEASEIDENTIFIER", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIER]})`), m("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIERLOOSE]})`), m("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), m("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), m("BUILDIDENTIFIER", `${f}+`), m("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), m("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), m("FULL", `^${c[l.FULLPLAIN]}$`), m("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), m("LOOSE", `^${c[l.LOOSEPLAIN]}$`), m("GTLT", "((?:<|>)?=?)"), m("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), m("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`), m("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), m("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), m("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), m("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), m("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), m("COERCE", `${c[l.COERCEPLAIN]}(?:$|[^\\d])`), m("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), m("COERCERTL", c[l.COERCE], !0), m("COERCERTLFULL", c[l.COERCEFULL], !0), m("LONETILDE", "(?:~>?)"), m("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", m("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), m("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), m("LONECARET", "(?:\\^)"), m("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", m("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), m("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), m("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), m("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), m("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", m("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), m("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), m("STAR", "(<|>)?=?\\s*\\*"), m("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), m("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(Os, Os.exports)), Os.exports;
}
var qu, Zp;
function E0() {
  if (Zp) return qu;
  Zp = 1;
  const e = Object.freeze({ loose: !0 }), t = Object.freeze({});
  return qu = (n) => n ? typeof n != "object" ? e : n : t, qu;
}
var Bu, em;
function TE() {
  if (em) return Bu;
  em = 1;
  const e = /^[0-9]+$/, t = (n, i) => {
    if (typeof n == "number" && typeof i == "number")
      return n === i ? 0 : n < i ? -1 : 1;
    const a = e.test(n), s = e.test(i);
    return a && s && (n = +n, i = +i), n === i ? 0 : a && !s ? -1 : s && !a ? 1 : n < i ? -1 : 1;
  };
  return Bu = {
    compareIdentifiers: t,
    rcompareIdentifiers: (n, i) => t(i, n)
  }, Bu;
}
var ju, tm;
function pr() {
  if (tm) return ju;
  tm = 1;
  const e = el(), { MAX_LENGTH: t, MAX_SAFE_INTEGER: r } = Zc(), { safeRe: n, t: i } = is(), a = E0(), { compareIdentifiers: s } = TE();
  class o {
    constructor(u, l) {
      if (l = a(l), u instanceof o) {
        if (u.loose === !!l.loose && u.includePrerelease === !!l.includePrerelease)
          return u;
        u = u.version;
      } else if (typeof u != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof u}".`);
      if (u.length > t)
        throw new TypeError(
          `version is longer than ${t} characters`
        );
      e("SemVer", u, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
      const d = u.trim().match(l.loose ? n[i.LOOSE] : n[i.FULL]);
      if (!d)
        throw new TypeError(`Invalid Version: ${u}`);
      if (this.raw = u, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > r || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > r || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > r || this.patch < 0)
        throw new TypeError("Invalid patch version");
      d[4] ? this.prerelease = d[4].split(".").map((f) => {
        if (/^[0-9]+$/.test(f)) {
          const p = +f;
          if (p >= 0 && p < r)
            return p;
        }
        return f;
      }) : this.prerelease = [], this.build = d[5] ? d[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(u) {
      if (e("SemVer.compare", this.version, this.options, u), !(u instanceof o)) {
        if (typeof u == "string" && u === this.version)
          return 0;
        u = new o(u, this.options);
      }
      return u.version === this.version ? 0 : this.compareMain(u) || this.comparePre(u);
    }
    compareMain(u) {
      return u instanceof o || (u = new o(u, this.options)), this.major < u.major ? -1 : this.major > u.major ? 1 : this.minor < u.minor ? -1 : this.minor > u.minor ? 1 : this.patch < u.patch ? -1 : this.patch > u.patch ? 1 : 0;
    }
    comparePre(u) {
      if (u instanceof o || (u = new o(u, this.options)), this.prerelease.length && !u.prerelease.length)
        return -1;
      if (!this.prerelease.length && u.prerelease.length)
        return 1;
      if (!this.prerelease.length && !u.prerelease.length)
        return 0;
      let l = 0;
      do {
        const d = this.prerelease[l], f = u.prerelease[l];
        if (e("prerelease compare", l, d, f), d === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === f)
          continue;
        return s(d, f);
      } while (++l);
    }
    compareBuild(u) {
      u instanceof o || (u = new o(u, this.options));
      let l = 0;
      do {
        const d = this.build[l], f = u.build[l];
        if (e("build compare", l, d, f), d === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === f)
          continue;
        return s(d, f);
      } while (++l);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(u, l, d) {
      if (u.startsWith("pre")) {
        if (!l && d === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (l) {
          const f = `-${l}`.match(this.options.loose ? n[i.PRERELEASELOOSE] : n[i.PRERELEASE]);
          if (!f || f[1] !== l)
            throw new Error(`invalid identifier: ${l}`);
        }
      }
      switch (u) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l, d);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l, d);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        case "release":
          if (this.prerelease.length === 0)
            throw new Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const f = Number(d) ? 1 : 0;
          if (this.prerelease.length === 0)
            this.prerelease = [f];
          else {
            let p = this.prerelease.length;
            for (; --p >= 0; )
              typeof this.prerelease[p] == "number" && (this.prerelease[p]++, p = -2);
            if (p === -1) {
              if (l === this.prerelease.join(".") && d === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(f);
            }
          }
          if (l) {
            let p = [l, f];
            d === !1 && (p = [l]), s(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = p) : this.prerelease = p;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${u}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  return ju = o, ju;
}
var Vu, rm;
function Zi() {
  if (rm) return Vu;
  rm = 1;
  const e = pr();
  return Vu = (r, n, i = !1) => {
    if (r instanceof e)
      return r;
    try {
      return new e(r, n);
    } catch (a) {
      if (!i)
        return null;
      throw a;
    }
  }, Vu;
}
var Hu, nm;
function aS() {
  if (nm) return Hu;
  nm = 1;
  const e = Zi();
  return Hu = (r, n) => {
    const i = e(r, n);
    return i ? i.version : null;
  }, Hu;
}
var Gu, im;
function sS() {
  if (im) return Gu;
  im = 1;
  const e = Zi();
  return Gu = (r, n) => {
    const i = e(r.trim().replace(/^[=v]+/, ""), n);
    return i ? i.version : null;
  }, Gu;
}
var zu, am;
function oS() {
  if (am) return zu;
  am = 1;
  const e = pr();
  return zu = (r, n, i, a, s) => {
    typeof i == "string" && (s = a, a = i, i = void 0);
    try {
      return new e(
        r instanceof e ? r.version : r,
        i
      ).inc(n, a, s).version;
    } catch {
      return null;
    }
  }, zu;
}
var Wu, sm;
function cS() {
  if (sm) return Wu;
  sm = 1;
  const e = Zi();
  return Wu = (r, n) => {
    const i = e(r, null, !0), a = e(n, null, !0), s = i.compare(a);
    if (s === 0)
      return null;
    const o = s > 0, c = o ? i : a, u = o ? a : i, l = !!c.prerelease.length;
    if (!!u.prerelease.length && !l) {
      if (!u.patch && !u.minor)
        return "major";
      if (u.compareMain(c) === 0)
        return u.minor && !u.patch ? "minor" : "patch";
    }
    const f = l ? "pre" : "";
    return i.major !== a.major ? f + "major" : i.minor !== a.minor ? f + "minor" : i.patch !== a.patch ? f + "patch" : "prerelease";
  }, Wu;
}
var Xu, om;
function lS() {
  if (om) return Xu;
  om = 1;
  const e = pr();
  return Xu = (r, n) => new e(r, n).major, Xu;
}
var Ku, cm;
function uS() {
  if (cm) return Ku;
  cm = 1;
  const e = pr();
  return Ku = (r, n) => new e(r, n).minor, Ku;
}
var Yu, lm;
function fS() {
  if (lm) return Yu;
  lm = 1;
  const e = pr();
  return Yu = (r, n) => new e(r, n).patch, Yu;
}
var Ju, um;
function dS() {
  if (um) return Ju;
  um = 1;
  const e = Zi();
  return Ju = (r, n) => {
    const i = e(r, n);
    return i && i.prerelease.length ? i.prerelease : null;
  }, Ju;
}
var Qu, fm;
function Yr() {
  if (fm) return Qu;
  fm = 1;
  const e = pr();
  return Qu = (r, n, i) => new e(r, i).compare(new e(n, i)), Qu;
}
var Zu, dm;
function hS() {
  if (dm) return Zu;
  dm = 1;
  const e = Yr();
  return Zu = (r, n, i) => e(n, r, i), Zu;
}
var ef, hm;
function pS() {
  if (hm) return ef;
  hm = 1;
  const e = Yr();
  return ef = (r, n) => e(r, n, !0), ef;
}
var tf, pm;
function w0() {
  if (pm) return tf;
  pm = 1;
  const e = pr();
  return tf = (r, n, i) => {
    const a = new e(r, i), s = new e(n, i);
    return a.compare(s) || a.compareBuild(s);
  }, tf;
}
var rf, mm;
function mS() {
  if (mm) return rf;
  mm = 1;
  const e = w0();
  return rf = (r, n) => r.sort((i, a) => e(i, a, n)), rf;
}
var nf, gm;
function gS() {
  if (gm) return nf;
  gm = 1;
  const e = w0();
  return nf = (r, n) => r.sort((i, a) => e(a, i, n)), nf;
}
var af, vm;
function tl() {
  if (vm) return af;
  vm = 1;
  const e = Yr();
  return af = (r, n, i) => e(r, n, i) > 0, af;
}
var sf, _m;
function x0() {
  if (_m) return sf;
  _m = 1;
  const e = Yr();
  return sf = (r, n, i) => e(r, n, i) < 0, sf;
}
var of, ym;
function SE() {
  if (ym) return of;
  ym = 1;
  const e = Yr();
  return of = (r, n, i) => e(r, n, i) === 0, of;
}
var cf, Em;
function AE() {
  if (Em) return cf;
  Em = 1;
  const e = Yr();
  return cf = (r, n, i) => e(r, n, i) !== 0, cf;
}
var lf, wm;
function T0() {
  if (wm) return lf;
  wm = 1;
  const e = Yr();
  return lf = (r, n, i) => e(r, n, i) >= 0, lf;
}
var uf, xm;
function S0() {
  if (xm) return uf;
  xm = 1;
  const e = Yr();
  return uf = (r, n, i) => e(r, n, i) <= 0, uf;
}
var ff, Tm;
function RE() {
  if (Tm) return ff;
  Tm = 1;
  const e = SE(), t = AE(), r = tl(), n = T0(), i = x0(), a = S0();
  return ff = (o, c, u, l) => {
    switch (c) {
      case "===":
        return typeof o == "object" && (o = o.version), typeof u == "object" && (u = u.version), o === u;
      case "!==":
        return typeof o == "object" && (o = o.version), typeof u == "object" && (u = u.version), o !== u;
      case "":
      case "=":
      case "==":
        return e(o, u, l);
      case "!=":
        return t(o, u, l);
      case ">":
        return r(o, u, l);
      case ">=":
        return n(o, u, l);
      case "<":
        return i(o, u, l);
      case "<=":
        return a(o, u, l);
      default:
        throw new TypeError(`Invalid operator: ${c}`);
    }
  }, ff;
}
var df, Sm;
function vS() {
  if (Sm) return df;
  Sm = 1;
  const e = pr(), t = Zi(), { safeRe: r, t: n } = is();
  return df = (a, s) => {
    if (a instanceof e)
      return a;
    if (typeof a == "number" && (a = String(a)), typeof a != "string")
      return null;
    s = s || {};
    let o = null;
    if (!s.rtl)
      o = a.match(s.includePrerelease ? r[n.COERCEFULL] : r[n.COERCE]);
    else {
      const p = s.includePrerelease ? r[n.COERCERTLFULL] : r[n.COERCERTL];
      let v;
      for (; (v = p.exec(a)) && (!o || o.index + o[0].length !== a.length); )
        (!o || v.index + v[0].length !== o.index + o[0].length) && (o = v), p.lastIndex = v.index + v[1].length + v[2].length;
      p.lastIndex = -1;
    }
    if (o === null)
      return null;
    const c = o[2], u = o[3] || "0", l = o[4] || "0", d = s.includePrerelease && o[5] ? `-${o[5]}` : "", f = s.includePrerelease && o[6] ? `+${o[6]}` : "";
    return t(`${c}.${u}.${l}${d}${f}`, s);
  }, df;
}
var hf, Am;
function _S() {
  if (Am) return hf;
  Am = 1;
  class e {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(r) {
      const n = this.map.get(r);
      if (n !== void 0)
        return this.map.delete(r), this.map.set(r, n), n;
    }
    delete(r) {
      return this.map.delete(r);
    }
    set(r, n) {
      if (!this.delete(r) && n !== void 0) {
        if (this.map.size >= this.max) {
          const a = this.map.keys().next().value;
          this.delete(a);
        }
        this.map.set(r, n);
      }
      return this;
    }
  }
  return hf = e, hf;
}
var pf, Rm;
function Jr() {
  if (Rm) return pf;
  Rm = 1;
  const e = /\s+/g;
  class t {
    constructor(V, ie) {
      if (ie = i(ie), V instanceof t)
        return V.loose === !!ie.loose && V.includePrerelease === !!ie.includePrerelease ? V : new t(V.raw, ie);
      if (V instanceof a)
        return this.raw = V.value, this.set = [[V]], this.formatted = void 0, this;
      if (this.options = ie, this.loose = !!ie.loose, this.includePrerelease = !!ie.includePrerelease, this.raw = V.trim().replace(e, " "), this.set = this.raw.split("||").map((W) => this.parseRange(W.trim())).filter((W) => W.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const W = this.set[0];
        if (this.set = this.set.filter((ae) => !m(ae[0])), this.set.length === 0)
          this.set = [W];
        else if (this.set.length > 1) {
          for (const ae of this.set)
            if (ae.length === 1 && h(ae[0])) {
              this.set = [ae];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let V = 0; V < this.set.length; V++) {
          V > 0 && (this.formatted += "||");
          const ie = this.set[V];
          for (let W = 0; W < ie.length; W++)
            W > 0 && (this.formatted += " "), this.formatted += ie[W].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(V) {
      const W = ((this.options.includePrerelease && p) | (this.options.loose && v)) + ":" + V, ae = n.get(W);
      if (ae)
        return ae;
      const se = this.options.loose, X = se ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      V = V.replace(X, U(this.options.includePrerelease)), s("hyphen replace", V), V = V.replace(c[u.COMPARATORTRIM], l), s("comparator trim", V), V = V.replace(c[u.TILDETRIM], d), s("tilde trim", V), V = V.replace(c[u.CARETTRIM], f), s("caret trim", V);
      let k = V.split(" ").map((A) => g(A, this.options)).join(" ").split(/\s+/).map((A) => F(A, this.options));
      se && (k = k.filter((A) => (s("loose invalid filter", A, this.options), !!A.match(c[u.COMPARATORLOOSE])))), s("range list", k);
      const I = /* @__PURE__ */ new Map(), C = k.map((A) => new a(A, this.options));
      for (const A of C) {
        if (m(A))
          return [A];
        I.set(A.value, A);
      }
      I.size > 1 && I.has("") && I.delete("");
      const T = [...I.values()];
      return n.set(W, T), T;
    }
    intersects(V, ie) {
      if (!(V instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((W) => _(W, ie) && V.set.some((ae) => _(ae, ie) && W.every((se) => ae.every((X) => se.intersects(X, ie)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(V) {
      if (!V)
        return !1;
      if (typeof V == "string")
        try {
          V = new o(V, this.options);
        } catch {
          return !1;
        }
      for (let ie = 0; ie < this.set.length; ie++)
        if (G(this.set[ie], V, this.options))
          return !0;
      return !1;
    }
  }
  pf = t;
  const r = _S(), n = new r(), i = E0(), a = rl(), s = el(), o = pr(), {
    safeRe: c,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: d,
    caretTrimReplace: f
  } = is(), { FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: v } = Zc(), m = (M) => M.value === "<0.0.0-0", h = (M) => M.value === "", _ = (M, V) => {
    let ie = !0;
    const W = M.slice();
    let ae = W.pop();
    for (; ie && W.length; )
      ie = W.every((se) => ae.intersects(se, V)), ae = W.pop();
    return ie;
  }, g = (M, V) => (M = M.replace(c[u.BUILD], ""), s("comp", M, V), M = w(M, V), s("caret", M), M = x(M, V), s("tildes", M), M = R(M, V), s("xrange", M), M = B(M, V), s("stars", M), M), y = (M) => !M || M.toLowerCase() === "x" || M === "*", x = (M, V) => M.trim().split(/\s+/).map((ie) => S(ie, V)).join(" "), S = (M, V) => {
    const ie = V.loose ? c[u.TILDELOOSE] : c[u.TILDE];
    return M.replace(ie, (W, ae, se, X, k) => {
      s("tilde", M, W, ae, se, X, k);
      let I;
      return y(ae) ? I = "" : y(se) ? I = `>=${ae}.0.0 <${+ae + 1}.0.0-0` : y(X) ? I = `>=${ae}.${se}.0 <${ae}.${+se + 1}.0-0` : k ? (s("replaceTilde pr", k), I = `>=${ae}.${se}.${X}-${k} <${ae}.${+se + 1}.0-0`) : I = `>=${ae}.${se}.${X} <${ae}.${+se + 1}.0-0`, s("tilde return", I), I;
    });
  }, w = (M, V) => M.trim().split(/\s+/).map((ie) => E(ie, V)).join(" "), E = (M, V) => {
    s("caret", M, V);
    const ie = V.loose ? c[u.CARETLOOSE] : c[u.CARET], W = V.includePrerelease ? "-0" : "";
    return M.replace(ie, (ae, se, X, k, I) => {
      s("caret", M, ae, se, X, k, I);
      let C;
      return y(se) ? C = "" : y(X) ? C = `>=${se}.0.0${W} <${+se + 1}.0.0-0` : y(k) ? se === "0" ? C = `>=${se}.${X}.0${W} <${se}.${+X + 1}.0-0` : C = `>=${se}.${X}.0${W} <${+se + 1}.0.0-0` : I ? (s("replaceCaret pr", I), se === "0" ? X === "0" ? C = `>=${se}.${X}.${k}-${I} <${se}.${X}.${+k + 1}-0` : C = `>=${se}.${X}.${k}-${I} <${se}.${+X + 1}.0-0` : C = `>=${se}.${X}.${k}-${I} <${+se + 1}.0.0-0`) : (s("no pr"), se === "0" ? X === "0" ? C = `>=${se}.${X}.${k}${W} <${se}.${X}.${+k + 1}-0` : C = `>=${se}.${X}.${k}${W} <${se}.${+X + 1}.0-0` : C = `>=${se}.${X}.${k} <${+se + 1}.0.0-0`), s("caret return", C), C;
    });
  }, R = (M, V) => (s("replaceXRanges", M, V), M.split(/\s+/).map((ie) => N(ie, V)).join(" ")), N = (M, V) => {
    M = M.trim();
    const ie = V.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
    return M.replace(ie, (W, ae, se, X, k, I) => {
      s("xRange", M, W, ae, se, X, k, I);
      const C = y(se), T = C || y(X), A = T || y(k), L = A;
      return ae === "=" && L && (ae = ""), I = V.includePrerelease ? "-0" : "", C ? ae === ">" || ae === "<" ? W = "<0.0.0-0" : W = "*" : ae && L ? (T && (X = 0), k = 0, ae === ">" ? (ae = ">=", T ? (se = +se + 1, X = 0, k = 0) : (X = +X + 1, k = 0)) : ae === "<=" && (ae = "<", T ? se = +se + 1 : X = +X + 1), ae === "<" && (I = "-0"), W = `${ae + se}.${X}.${k}${I}`) : T ? W = `>=${se}.0.0${I} <${+se + 1}.0.0-0` : A && (W = `>=${se}.${X}.0${I} <${se}.${+X + 1}.0-0`), s("xRange return", W), W;
    });
  }, B = (M, V) => (s("replaceStars", M, V), M.trim().replace(c[u.STAR], "")), F = (M, V) => (s("replaceGTE0", M, V), M.trim().replace(c[V.includePrerelease ? u.GTE0PRE : u.GTE0], "")), U = (M) => (V, ie, W, ae, se, X, k, I, C, T, A, L) => (y(W) ? ie = "" : y(ae) ? ie = `>=${W}.0.0${M ? "-0" : ""}` : y(se) ? ie = `>=${W}.${ae}.0${M ? "-0" : ""}` : X ? ie = `>=${ie}` : ie = `>=${ie}${M ? "-0" : ""}`, y(C) ? I = "" : y(T) ? I = `<${+C + 1}.0.0-0` : y(A) ? I = `<${C}.${+T + 1}.0-0` : L ? I = `<=${C}.${T}.${A}-${L}` : M ? I = `<${C}.${T}.${+A + 1}-0` : I = `<=${I}`, `${ie} ${I}`.trim()), G = (M, V, ie) => {
    for (let W = 0; W < M.length; W++)
      if (!M[W].test(V))
        return !1;
    if (V.prerelease.length && !ie.includePrerelease) {
      for (let W = 0; W < M.length; W++)
        if (s(M[W].semver), M[W].semver !== a.ANY && M[W].semver.prerelease.length > 0) {
          const ae = M[W].semver;
          if (ae.major === V.major && ae.minor === V.minor && ae.patch === V.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return pf;
}
var mf, $m;
function rl() {
  if ($m) return mf;
  $m = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(l, d) {
      if (d = r(d), l instanceof t) {
        if (l.loose === !!d.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), s("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, s("comp", this);
    }
    parse(l) {
      const d = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], f = l.match(d);
      if (!f)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = f[1] !== void 0 ? f[1] : "", this.operator === "=" && (this.operator = ""), f[2] ? this.semver = new o(f[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (s("Comparator.test", l, this.options.loose), this.semver === e || l === e)
        return !0;
      if (typeof l == "string")
        try {
          l = new o(l, this.options);
        } catch {
          return !1;
        }
      return a(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new c(this.value, d).test(l.semver) : (d = r(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || a(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || a(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  mf = t;
  const r = E0(), { safeRe: n, t: i } = is(), a = RE(), s = el(), o = pr(), c = Jr();
  return mf;
}
var gf, Om;
function nl() {
  if (Om) return gf;
  Om = 1;
  const e = Jr();
  return gf = (r, n, i) => {
    try {
      n = new e(n, i);
    } catch {
      return !1;
    }
    return n.test(r);
  }, gf;
}
var vf, Nm;
function yS() {
  if (Nm) return vf;
  Nm = 1;
  const e = Jr();
  return vf = (r, n) => new e(r, n).set.map((i) => i.map((a) => a.value).join(" ").trim().split(" ")), vf;
}
var _f, Pm;
function ES() {
  if (Pm) return _f;
  Pm = 1;
  const e = pr(), t = Jr();
  return _f = (n, i, a) => {
    let s = null, o = null, c = null;
    try {
      c = new t(i, a);
    } catch {
      return null;
    }
    return n.forEach((u) => {
      c.test(u) && (!s || o.compare(u) === -1) && (s = u, o = new e(s, a));
    }), s;
  }, _f;
}
var yf, Cm;
function wS() {
  if (Cm) return yf;
  Cm = 1;
  const e = pr(), t = Jr();
  return yf = (n, i, a) => {
    let s = null, o = null, c = null;
    try {
      c = new t(i, a);
    } catch {
      return null;
    }
    return n.forEach((u) => {
      c.test(u) && (!s || o.compare(u) === 1) && (s = u, o = new e(s, a));
    }), s;
  }, yf;
}
var Ef, Im;
function xS() {
  if (Im) return Ef;
  Im = 1;
  const e = pr(), t = Jr(), r = tl();
  return Ef = (i, a) => {
    i = new t(i, a);
    let s = new e("0.0.0");
    if (i.test(s) || (s = new e("0.0.0-0"), i.test(s)))
      return s;
    s = null;
    for (let o = 0; o < i.set.length; ++o) {
      const c = i.set[o];
      let u = null;
      c.forEach((l) => {
        const d = new e(l.semver.version);
        switch (l.operator) {
          case ">":
            d.prerelease.length === 0 ? d.patch++ : d.prerelease.push(0), d.raw = d.format();
          /* fallthrough */
          case "":
          case ">=":
            (!u || r(d, u)) && (u = d);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${l.operator}`);
        }
      }), u && (!s || r(s, u)) && (s = u);
    }
    return s && i.test(s) ? s : null;
  }, Ef;
}
var wf, bm;
function TS() {
  if (bm) return wf;
  bm = 1;
  const e = Jr();
  return wf = (r, n) => {
    try {
      return new e(r, n).range || "*";
    } catch {
      return null;
    }
  }, wf;
}
var xf, Fm;
function A0() {
  if (Fm) return xf;
  Fm = 1;
  const e = pr(), t = rl(), { ANY: r } = t, n = Jr(), i = nl(), a = tl(), s = x0(), o = S0(), c = T0();
  return xf = (l, d, f, p) => {
    l = new e(l, p), d = new n(d, p);
    let v, m, h, _, g;
    switch (f) {
      case ">":
        v = a, m = o, h = s, _ = ">", g = ">=";
        break;
      case "<":
        v = s, m = c, h = a, _ = "<", g = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (i(l, d, p))
      return !1;
    for (let y = 0; y < d.set.length; ++y) {
      const x = d.set[y];
      let S = null, w = null;
      if (x.forEach((E) => {
        E.semver === r && (E = new t(">=0.0.0")), S = S || E, w = w || E, v(E.semver, S.semver, p) ? S = E : h(E.semver, w.semver, p) && (w = E);
      }), S.operator === _ || S.operator === g || (!w.operator || w.operator === _) && m(l, w.semver))
        return !1;
      if (w.operator === g && h(l, w.semver))
        return !1;
    }
    return !0;
  }, xf;
}
var Tf, Dm;
function SS() {
  if (Dm) return Tf;
  Dm = 1;
  const e = A0();
  return Tf = (r, n, i) => e(r, n, ">", i), Tf;
}
var Sf, km;
function AS() {
  if (km) return Sf;
  km = 1;
  const e = A0();
  return Sf = (r, n, i) => e(r, n, "<", i), Sf;
}
var Af, Lm;
function RS() {
  if (Lm) return Af;
  Lm = 1;
  const e = Jr();
  return Af = (r, n, i) => (r = new e(r, i), n = new e(n, i), r.intersects(n, i)), Af;
}
var Rf, Mm;
function $S() {
  if (Mm) return Rf;
  Mm = 1;
  const e = nl(), t = Yr();
  return Rf = (r, n, i) => {
    const a = [];
    let s = null, o = null;
    const c = r.sort((f, p) => t(f, p, i));
    for (const f of c)
      e(f, n, i) ? (o = f, s || (s = f)) : (o && a.push([s, o]), o = null, s = null);
    s && a.push([s, null]);
    const u = [];
    for (const [f, p] of a)
      f === p ? u.push(f) : !p && f === c[0] ? u.push("*") : p ? f === c[0] ? u.push(`<=${p}`) : u.push(`${f} - ${p}`) : u.push(`>=${f}`);
    const l = u.join(" || "), d = typeof n.raw == "string" ? n.raw : String(n);
    return l.length < d.length ? l : n;
  }, Rf;
}
var $f, Um;
function OS() {
  if (Um) return $f;
  Um = 1;
  const e = Jr(), t = rl(), { ANY: r } = t, n = nl(), i = Yr(), a = (d, f, p = {}) => {
    if (d === f)
      return !0;
    d = new e(d, p), f = new e(f, p);
    let v = !1;
    e: for (const m of d.set) {
      for (const h of f.set) {
        const _ = c(m, h, p);
        if (v = v || _ !== null, _)
          continue e;
      }
      if (v)
        return !1;
    }
    return !0;
  }, s = [new t(">=0.0.0-0")], o = [new t(">=0.0.0")], c = (d, f, p) => {
    if (d === f)
      return !0;
    if (d.length === 1 && d[0].semver === r) {
      if (f.length === 1 && f[0].semver === r)
        return !0;
      p.includePrerelease ? d = s : d = o;
    }
    if (f.length === 1 && f[0].semver === r) {
      if (p.includePrerelease)
        return !0;
      f = o;
    }
    const v = /* @__PURE__ */ new Set();
    let m, h;
    for (const R of d)
      R.operator === ">" || R.operator === ">=" ? m = u(m, R, p) : R.operator === "<" || R.operator === "<=" ? h = l(h, R, p) : v.add(R.semver);
    if (v.size > 1)
      return null;
    let _;
    if (m && h) {
      if (_ = i(m.semver, h.semver, p), _ > 0)
        return null;
      if (_ === 0 && (m.operator !== ">=" || h.operator !== "<="))
        return null;
    }
    for (const R of v) {
      if (m && !n(R, String(m), p) || h && !n(R, String(h), p))
        return null;
      for (const N of f)
        if (!n(R, String(N), p))
          return !1;
      return !0;
    }
    let g, y, x, S, w = h && !p.includePrerelease && h.semver.prerelease.length ? h.semver : !1, E = m && !p.includePrerelease && m.semver.prerelease.length ? m.semver : !1;
    w && w.prerelease.length === 1 && h.operator === "<" && w.prerelease[0] === 0 && (w = !1);
    for (const R of f) {
      if (S = S || R.operator === ">" || R.operator === ">=", x = x || R.operator === "<" || R.operator === "<=", m) {
        if (E && R.semver.prerelease && R.semver.prerelease.length && R.semver.major === E.major && R.semver.minor === E.minor && R.semver.patch === E.patch && (E = !1), R.operator === ">" || R.operator === ">=") {
          if (g = u(m, R, p), g === R && g !== m)
            return !1;
        } else if (m.operator === ">=" && !n(m.semver, String(R), p))
          return !1;
      }
      if (h) {
        if (w && R.semver.prerelease && R.semver.prerelease.length && R.semver.major === w.major && R.semver.minor === w.minor && R.semver.patch === w.patch && (w = !1), R.operator === "<" || R.operator === "<=") {
          if (y = l(h, R, p), y === R && y !== h)
            return !1;
        } else if (h.operator === "<=" && !n(h.semver, String(R), p))
          return !1;
      }
      if (!R.operator && (h || m) && _ !== 0)
        return !1;
    }
    return !(m && x && !h && _ !== 0 || h && S && !m && _ !== 0 || E || w);
  }, u = (d, f, p) => {
    if (!d)
      return f;
    const v = i(d.semver, f.semver, p);
    return v > 0 ? d : v < 0 || f.operator === ">" && d.operator === ">=" ? f : d;
  }, l = (d, f, p) => {
    if (!d)
      return f;
    const v = i(d.semver, f.semver, p);
    return v < 0 ? d : v > 0 || f.operator === "<" && d.operator === "<=" ? f : d;
  };
  return $f = a, $f;
}
var Of, qm;
function $E() {
  if (qm) return Of;
  qm = 1;
  const e = is(), t = Zc(), r = pr(), n = TE(), i = Zi(), a = aS(), s = sS(), o = oS(), c = cS(), u = lS(), l = uS(), d = fS(), f = dS(), p = Yr(), v = hS(), m = pS(), h = w0(), _ = mS(), g = gS(), y = tl(), x = x0(), S = SE(), w = AE(), E = T0(), R = S0(), N = RE(), B = vS(), F = rl(), U = Jr(), G = nl(), M = yS(), V = ES(), ie = wS(), W = xS(), ae = TS(), se = A0(), X = SS(), k = AS(), I = RS(), C = $S(), T = OS();
  return Of = {
    parse: i,
    valid: a,
    clean: s,
    inc: o,
    diff: c,
    major: u,
    minor: l,
    patch: d,
    prerelease: f,
    compare: p,
    rcompare: v,
    compareLoose: m,
    compareBuild: h,
    sort: _,
    rsort: g,
    gt: y,
    lt: x,
    eq: S,
    neq: w,
    gte: E,
    lte: R,
    cmp: N,
    coerce: B,
    Comparator: F,
    Range: U,
    satisfies: G,
    toComparators: M,
    maxSatisfying: V,
    minSatisfying: ie,
    minVersion: W,
    validRange: ae,
    outside: se,
    gtr: X,
    ltr: k,
    intersects: I,
    simplifyRange: C,
    subset: T,
    SemVer: r,
    re: e.re,
    src: e.src,
    tokens: e.t,
    SEMVER_SPEC_VERSION: t.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: t.RELEASE_TYPES,
    compareIdentifiers: n.compareIdentifiers,
    rcompareIdentifiers: n.rcompareIdentifiers
  }, Of;
}
var Oi = {}, Ua = { exports: {} };
Ua.exports;
var Bm;
function NS() {
  return Bm || (Bm = 1, (function(e, t) {
    var r = 200, n = "__lodash_hash_undefined__", i = 1, a = 2, s = 9007199254740991, o = "[object Arguments]", c = "[object Array]", u = "[object AsyncFunction]", l = "[object Boolean]", d = "[object Date]", f = "[object Error]", p = "[object Function]", v = "[object GeneratorFunction]", m = "[object Map]", h = "[object Number]", _ = "[object Null]", g = "[object Object]", y = "[object Promise]", x = "[object Proxy]", S = "[object RegExp]", w = "[object Set]", E = "[object String]", R = "[object Symbol]", N = "[object Undefined]", B = "[object WeakMap]", F = "[object ArrayBuffer]", U = "[object DataView]", G = "[object Float32Array]", M = "[object Float64Array]", V = "[object Int8Array]", ie = "[object Int16Array]", W = "[object Int32Array]", ae = "[object Uint8Array]", se = "[object Uint8ClampedArray]", X = "[object Uint16Array]", k = "[object Uint32Array]", I = /[\\^$.*+?()[\]{}|]/g, C = /^\[object .+?Constructor\]$/, T = /^(?:0|[1-9]\d*)$/, A = {};
    A[G] = A[M] = A[V] = A[ie] = A[W] = A[ae] = A[se] = A[X] = A[k] = !0, A[o] = A[c] = A[F] = A[l] = A[U] = A[d] = A[f] = A[p] = A[m] = A[h] = A[g] = A[S] = A[w] = A[E] = A[B] = !1;
    var L = typeof zr == "object" && zr && zr.Object === Object && zr, b = typeof self == "object" && self && self.Object === Object && self, P = L || b || Function("return this")(), te = t && !t.nodeType && t, H = te && !0 && e && !e.nodeType && e, D = H && H.exports === te, q = D && L.process, J = (function() {
      try {
        return q && q.binding && q.binding("util");
      } catch {
      }
    })(), ne = J && J.isTypedArray;
    function ce(Q, oe) {
      for (var Re = -1, Be = Q == null ? 0 : Q.length, St = 0, Qe = []; ++Re < Be; ) {
        var Nt = Q[Re];
        oe(Nt, Re, Q) && (Qe[St++] = Nt);
      }
      return Qe;
    }
    function Ee(Q, oe) {
      for (var Re = -1, Be = oe.length, St = Q.length; ++Re < Be; )
        Q[St + Re] = oe[Re];
      return Q;
    }
    function ge(Q, oe) {
      for (var Re = -1, Be = Q == null ? 0 : Q.length; ++Re < Be; )
        if (oe(Q[Re], Re, Q))
          return !0;
      return !1;
    }
    function Ge(Q, oe) {
      for (var Re = -1, Be = Array(Q); ++Re < Q; )
        Be[Re] = oe(Re);
      return Be;
    }
    function ze(Q) {
      return function(oe) {
        return Q(oe);
      };
    }
    function Xe(Q, oe) {
      return Q.has(oe);
    }
    function He(Q, oe) {
      return Q?.[oe];
    }
    function O(Q) {
      var oe = -1, Re = Array(Q.size);
      return Q.forEach(function(Be, St) {
        Re[++oe] = [St, Be];
      }), Re;
    }
    function le(Q, oe) {
      return function(Re) {
        return Q(oe(Re));
      };
    }
    function me(Q) {
      var oe = -1, Re = Array(Q.size);
      return Q.forEach(function(Be) {
        Re[++oe] = Be;
      }), Re;
    }
    var Ne = Array.prototype, _e = Function.prototype, $e = Object.prototype, Ae = P["__core-js_shared__"], De = _e.toString, Me = $e.hasOwnProperty, it = (function() {
      var Q = /[^.]+$/.exec(Ae && Ae.keys && Ae.keys.IE_PROTO || "");
      return Q ? "Symbol(src)_1." + Q : "";
    })(), at = $e.toString, je = RegExp(
      "^" + De.call(Me).replace(I, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), z = D ? P.Buffer : void 0, he = P.Symbol, we = P.Uint8Array, xe = $e.propertyIsEnumerable, Te = Ne.splice, ke = he ? he.toStringTag : void 0, Pe = Object.getOwnPropertySymbols, Ue = z ? z.isBuffer : void 0, Ve = le(Object.keys, Object), We = Ri(P, "DataView"), yt = Ri(P, "Map"), Rt = Ri(P, "Promise"), ot = Ri(P, "Set"), $n = Ri(P, "WeakMap"), wr = Ri(Object, "create"), ln = Jn(We), Ol = Jn(yt), Nl = Jn(Rt), sa = Jn(ot), Pl = Jn($n), ds = he ? he.prototype : void 0, oa = ds ? ds.valueOf : void 0;
    function j(Q) {
      var oe = -1, Re = Q == null ? 0 : Q.length;
      for (this.clear(); ++oe < Re; ) {
        var Be = Q[oe];
        this.set(Be[0], Be[1]);
      }
    }
    function Z() {
      this.__data__ = wr ? wr(null) : {}, this.size = 0;
    }
    function K(Q) {
      var oe = this.has(Q) && delete this.__data__[Q];
      return this.size -= oe ? 1 : 0, oe;
    }
    function Y(Q) {
      var oe = this.__data__;
      if (wr) {
        var Re = oe[Q];
        return Re === n ? void 0 : Re;
      }
      return Me.call(oe, Q) ? oe[Q] : void 0;
    }
    function ee(Q) {
      var oe = this.__data__;
      return wr ? oe[Q] !== void 0 : Me.call(oe, Q);
    }
    function re(Q, oe) {
      var Re = this.__data__;
      return this.size += this.has(Q) ? 0 : 1, Re[Q] = wr && oe === void 0 ? n : oe, this;
    }
    j.prototype.clear = Z, j.prototype.delete = K, j.prototype.get = Y, j.prototype.has = ee, j.prototype.set = re;
    function ue(Q) {
      var oe = -1, Re = Q == null ? 0 : Q.length;
      for (this.clear(); ++oe < Re; ) {
        var Be = Q[oe];
        this.set(Be[0], Be[1]);
      }
    }
    function ye() {
      this.__data__ = [], this.size = 0;
    }
    function fe(Q) {
      var oe = this.__data__, Re = hs(oe, Q);
      if (Re < 0)
        return !1;
      var Be = oe.length - 1;
      return Re == Be ? oe.pop() : Te.call(oe, Re, 1), --this.size, !0;
    }
    function de(Q) {
      var oe = this.__data__, Re = hs(oe, Q);
      return Re < 0 ? void 0 : oe[Re][1];
    }
    function pe(Q) {
      return hs(this.__data__, Q) > -1;
    }
    function Oe(Q, oe) {
      var Re = this.__data__, Be = hs(Re, Q);
      return Be < 0 ? (++this.size, Re.push([Q, oe])) : Re[Be][1] = oe, this;
    }
    ue.prototype.clear = ye, ue.prototype.delete = fe, ue.prototype.get = de, ue.prototype.has = pe, ue.prototype.set = Oe;
    function Ie(Q) {
      var oe = -1, Re = Q == null ? 0 : Q.length;
      for (this.clear(); ++oe < Re; ) {
        var Be = Q[oe];
        this.set(Be[0], Be[1]);
      }
    }
    function qe() {
      this.size = 0, this.__data__ = {
        hash: new j(),
        map: new (yt || ue)(),
        string: new j()
      };
    }
    function Ce(Q) {
      var oe = ps(this, Q).delete(Q);
      return this.size -= oe ? 1 : 0, oe;
    }
    function Le(Q) {
      return ps(this, Q).get(Q);
    }
    function Ke(Q) {
      return ps(this, Q).has(Q);
    }
    function Tt(Q, oe) {
      var Re = ps(this, Q), Be = Re.size;
      return Re.set(Q, oe), this.size += Re.size == Be ? 0 : 1, this;
    }
    Ie.prototype.clear = qe, Ie.prototype.delete = Ce, Ie.prototype.get = Le, Ie.prototype.has = Ke, Ie.prototype.set = Tt;
    function Et(Q) {
      var oe = -1, Re = Q == null ? 0 : Q.length;
      for (this.__data__ = new Ie(); ++oe < Re; )
        this.add(Q[oe]);
    }
    function Lt(Q) {
      return this.__data__.set(Q, n), this;
    }
    function Kn(Q) {
      return this.__data__.has(Q);
    }
    Et.prototype.add = Et.prototype.push = Lt, Et.prototype.has = Kn;
    function gr(Q) {
      var oe = this.__data__ = new ue(Q);
      this.size = oe.size;
    }
    function Yn() {
      this.__data__ = new ue(), this.size = 0;
    }
    function un(Q) {
      var oe = this.__data__, Re = oe.delete(Q);
      return this.size = oe.size, Re;
    }
    function ca(Q) {
      return this.__data__.get(Q);
    }
    function Ur(Q) {
      return this.__data__.has(Q);
    }
    function jx(Q, oe) {
      var Re = this.__data__;
      if (Re instanceof ue) {
        var Be = Re.__data__;
        if (!yt || Be.length < r - 1)
          return Be.push([Q, oe]), this.size = ++Re.size, this;
        Re = this.__data__ = new Ie(Be);
      }
      return Re.set(Q, oe), this.size = Re.size, this;
    }
    gr.prototype.clear = Yn, gr.prototype.delete = un, gr.prototype.get = ca, gr.prototype.has = Ur, gr.prototype.set = jx;
    function Vx(Q, oe) {
      var Re = ms(Q), Be = !Re && iT(Q), St = !Re && !Be && Cl(Q), Qe = !Re && !Be && !St && Eh(Q), Nt = Re || Be || St || Qe, Mt = Nt ? Ge(Q.length, String) : [], jt = Mt.length;
      for (var Ot in Q)
        Me.call(Q, Ot) && !(Nt && // Safari 9 has enumerable `arguments.length` in strict mode.
        (Ot == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        St && (Ot == "offset" || Ot == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        Qe && (Ot == "buffer" || Ot == "byteLength" || Ot == "byteOffset") || // Skip index properties.
        Zx(Ot, jt))) && Mt.push(Ot);
      return Mt;
    }
    function hs(Q, oe) {
      for (var Re = Q.length; Re--; )
        if (gh(Q[Re][0], oe))
          return Re;
      return -1;
    }
    function Hx(Q, oe, Re) {
      var Be = oe(Q);
      return ms(Q) ? Be : Ee(Be, Re(Q));
    }
    function la(Q) {
      return Q == null ? Q === void 0 ? N : _ : ke && ke in Object(Q) ? Jx(Q) : nT(Q);
    }
    function dh(Q) {
      return ua(Q) && la(Q) == o;
    }
    function hh(Q, oe, Re, Be, St) {
      return Q === oe ? !0 : Q == null || oe == null || !ua(Q) && !ua(oe) ? Q !== Q && oe !== oe : Gx(Q, oe, Re, Be, hh, St);
    }
    function Gx(Q, oe, Re, Be, St, Qe) {
      var Nt = ms(Q), Mt = ms(oe), jt = Nt ? c : On(Q), Ot = Mt ? c : On(oe);
      jt = jt == o ? g : jt, Ot = Ot == o ? g : Ot;
      var xr = jt == g, qr = Ot == g, Qt = jt == Ot;
      if (Qt && Cl(Q)) {
        if (!Cl(oe))
          return !1;
        Nt = !0, xr = !1;
      }
      if (Qt && !xr)
        return Qe || (Qe = new gr()), Nt || Eh(Q) ? ph(Q, oe, Re, Be, St, Qe) : Kx(Q, oe, jt, Re, Be, St, Qe);
      if (!(Re & i)) {
        var Ir = xr && Me.call(Q, "__wrapped__"), br = qr && Me.call(oe, "__wrapped__");
        if (Ir || br) {
          var Nn = Ir ? Q.value() : Q, fn = br ? oe.value() : oe;
          return Qe || (Qe = new gr()), St(Nn, fn, Re, Be, Qe);
        }
      }
      return Qt ? (Qe || (Qe = new gr()), Yx(Q, oe, Re, Be, St, Qe)) : !1;
    }
    function zx(Q) {
      if (!yh(Q) || tT(Q))
        return !1;
      var oe = vh(Q) ? je : C;
      return oe.test(Jn(Q));
    }
    function Wx(Q) {
      return ua(Q) && _h(Q.length) && !!A[la(Q)];
    }
    function Xx(Q) {
      if (!rT(Q))
        return Ve(Q);
      var oe = [];
      for (var Re in Object(Q))
        Me.call(Q, Re) && Re != "constructor" && oe.push(Re);
      return oe;
    }
    function ph(Q, oe, Re, Be, St, Qe) {
      var Nt = Re & i, Mt = Q.length, jt = oe.length;
      if (Mt != jt && !(Nt && jt > Mt))
        return !1;
      var Ot = Qe.get(Q);
      if (Ot && Qe.get(oe))
        return Ot == oe;
      var xr = -1, qr = !0, Qt = Re & a ? new Et() : void 0;
      for (Qe.set(Q, oe), Qe.set(oe, Q); ++xr < Mt; ) {
        var Ir = Q[xr], br = oe[xr];
        if (Be)
          var Nn = Nt ? Be(br, Ir, xr, oe, Q, Qe) : Be(Ir, br, xr, Q, oe, Qe);
        if (Nn !== void 0) {
          if (Nn)
            continue;
          qr = !1;
          break;
        }
        if (Qt) {
          if (!ge(oe, function(fn, Qn) {
            if (!Xe(Qt, Qn) && (Ir === fn || St(Ir, fn, Re, Be, Qe)))
              return Qt.push(Qn);
          })) {
            qr = !1;
            break;
          }
        } else if (!(Ir === br || St(Ir, br, Re, Be, Qe))) {
          qr = !1;
          break;
        }
      }
      return Qe.delete(Q), Qe.delete(oe), qr;
    }
    function Kx(Q, oe, Re, Be, St, Qe, Nt) {
      switch (Re) {
        case U:
          if (Q.byteLength != oe.byteLength || Q.byteOffset != oe.byteOffset)
            return !1;
          Q = Q.buffer, oe = oe.buffer;
        case F:
          return !(Q.byteLength != oe.byteLength || !Qe(new we(Q), new we(oe)));
        case l:
        case d:
        case h:
          return gh(+Q, +oe);
        case f:
          return Q.name == oe.name && Q.message == oe.message;
        case S:
        case E:
          return Q == oe + "";
        case m:
          var Mt = O;
        case w:
          var jt = Be & i;
          if (Mt || (Mt = me), Q.size != oe.size && !jt)
            return !1;
          var Ot = Nt.get(Q);
          if (Ot)
            return Ot == oe;
          Be |= a, Nt.set(Q, oe);
          var xr = ph(Mt(Q), Mt(oe), Be, St, Qe, Nt);
          return Nt.delete(Q), xr;
        case R:
          if (oa)
            return oa.call(Q) == oa.call(oe);
      }
      return !1;
    }
    function Yx(Q, oe, Re, Be, St, Qe) {
      var Nt = Re & i, Mt = mh(Q), jt = Mt.length, Ot = mh(oe), xr = Ot.length;
      if (jt != xr && !Nt)
        return !1;
      for (var qr = jt; qr--; ) {
        var Qt = Mt[qr];
        if (!(Nt ? Qt in oe : Me.call(oe, Qt)))
          return !1;
      }
      var Ir = Qe.get(Q);
      if (Ir && Qe.get(oe))
        return Ir == oe;
      var br = !0;
      Qe.set(Q, oe), Qe.set(oe, Q);
      for (var Nn = Nt; ++qr < jt; ) {
        Qt = Mt[qr];
        var fn = Q[Qt], Qn = oe[Qt];
        if (Be)
          var wh = Nt ? Be(Qn, fn, Qt, oe, Q, Qe) : Be(fn, Qn, Qt, Q, oe, Qe);
        if (!(wh === void 0 ? fn === Qn || St(fn, Qn, Re, Be, Qe) : wh)) {
          br = !1;
          break;
        }
        Nn || (Nn = Qt == "constructor");
      }
      if (br && !Nn) {
        var gs = Q.constructor, vs = oe.constructor;
        gs != vs && "constructor" in Q && "constructor" in oe && !(typeof gs == "function" && gs instanceof gs && typeof vs == "function" && vs instanceof vs) && (br = !1);
      }
      return Qe.delete(Q), Qe.delete(oe), br;
    }
    function mh(Q) {
      return Hx(Q, oT, Qx);
    }
    function ps(Q, oe) {
      var Re = Q.__data__;
      return eT(oe) ? Re[typeof oe == "string" ? "string" : "hash"] : Re.map;
    }
    function Ri(Q, oe) {
      var Re = He(Q, oe);
      return zx(Re) ? Re : void 0;
    }
    function Jx(Q) {
      var oe = Me.call(Q, ke), Re = Q[ke];
      try {
        Q[ke] = void 0;
        var Be = !0;
      } catch {
      }
      var St = at.call(Q);
      return Be && (oe ? Q[ke] = Re : delete Q[ke]), St;
    }
    var Qx = Pe ? function(Q) {
      return Q == null ? [] : (Q = Object(Q), ce(Pe(Q), function(oe) {
        return xe.call(Q, oe);
      }));
    } : cT, On = la;
    (We && On(new We(new ArrayBuffer(1))) != U || yt && On(new yt()) != m || Rt && On(Rt.resolve()) != y || ot && On(new ot()) != w || $n && On(new $n()) != B) && (On = function(Q) {
      var oe = la(Q), Re = oe == g ? Q.constructor : void 0, Be = Re ? Jn(Re) : "";
      if (Be)
        switch (Be) {
          case ln:
            return U;
          case Ol:
            return m;
          case Nl:
            return y;
          case sa:
            return w;
          case Pl:
            return B;
        }
      return oe;
    });
    function Zx(Q, oe) {
      return oe = oe ?? s, !!oe && (typeof Q == "number" || T.test(Q)) && Q > -1 && Q % 1 == 0 && Q < oe;
    }
    function eT(Q) {
      var oe = typeof Q;
      return oe == "string" || oe == "number" || oe == "symbol" || oe == "boolean" ? Q !== "__proto__" : Q === null;
    }
    function tT(Q) {
      return !!it && it in Q;
    }
    function rT(Q) {
      var oe = Q && Q.constructor, Re = typeof oe == "function" && oe.prototype || $e;
      return Q === Re;
    }
    function nT(Q) {
      return at.call(Q);
    }
    function Jn(Q) {
      if (Q != null) {
        try {
          return De.call(Q);
        } catch {
        }
        try {
          return Q + "";
        } catch {
        }
      }
      return "";
    }
    function gh(Q, oe) {
      return Q === oe || Q !== Q && oe !== oe;
    }
    var iT = dh(/* @__PURE__ */ (function() {
      return arguments;
    })()) ? dh : function(Q) {
      return ua(Q) && Me.call(Q, "callee") && !xe.call(Q, "callee");
    }, ms = Array.isArray;
    function aT(Q) {
      return Q != null && _h(Q.length) && !vh(Q);
    }
    var Cl = Ue || lT;
    function sT(Q, oe) {
      return hh(Q, oe);
    }
    function vh(Q) {
      if (!yh(Q))
        return !1;
      var oe = la(Q);
      return oe == p || oe == v || oe == u || oe == x;
    }
    function _h(Q) {
      return typeof Q == "number" && Q > -1 && Q % 1 == 0 && Q <= s;
    }
    function yh(Q) {
      var oe = typeof Q;
      return Q != null && (oe == "object" || oe == "function");
    }
    function ua(Q) {
      return Q != null && typeof Q == "object";
    }
    var Eh = ne ? ze(ne) : Wx;
    function oT(Q) {
      return aT(Q) ? Vx(Q) : Xx(Q);
    }
    function cT() {
      return [];
    }
    function lT() {
      return !1;
    }
    e.exports = sT;
  })(Ua, Ua.exports)), Ua.exports;
}
var jm;
function PS() {
  if (jm) return Oi;
  jm = 1, Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.DownloadedUpdateHelper = void 0, Oi.createTempUpdateFile = o;
  const e = ts, t = Kr, r = NS(), n = /* @__PURE__ */ zn(), i = vt;
  let a = class {
    constructor(u) {
      this.cacheDir = u, this._file = null, this._packageFile = null, this.versionInfo = null, this.fileInfo = null, this._downloadedFileInfo = null;
    }
    get downloadedFileInfo() {
      return this._downloadedFileInfo;
    }
    get file() {
      return this._file;
    }
    get packageFile() {
      return this._packageFile;
    }
    get cacheDirForPendingUpdate() {
      return i.join(this.cacheDir, "pending");
    }
    async validateDownloadedPath(u, l, d, f) {
      if (this.versionInfo != null && this.file === u && this.fileInfo != null)
        return r(this.versionInfo, l) && r(this.fileInfo.info, d.info) && await (0, n.pathExists)(u) ? u : null;
      const p = await this.getValidCachedUpdateFile(d, f);
      return p === null ? null : (f.info(`Update has already been downloaded to ${u}).`), this._file = p, p);
    }
    async setDownloadedFile(u, l, d, f, p, v) {
      this._file = u, this._packageFile = l, this.versionInfo = d, this.fileInfo = f, this._downloadedFileInfo = {
        fileName: p,
        sha512: f.info.sha512,
        isAdminRightsRequired: f.info.isAdminRightsRequired === !0
      }, v && await (0, n.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
    }
    async clear() {
      this._file = null, this._packageFile = null, this.versionInfo = null, this.fileInfo = null, await this.cleanCacheDirForPendingUpdate();
    }
    async cleanCacheDirForPendingUpdate() {
      try {
        await (0, n.emptyDir)(this.cacheDirForPendingUpdate);
      } catch {
      }
    }
    /**
     * Returns "update-info.json" which is created in the update cache directory's "pending" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.
     * @param fileInfo
     * @param logger
     */
    async getValidCachedUpdateFile(u, l) {
      const d = this.getUpdateInfoFile();
      if (!await (0, n.pathExists)(d))
        return null;
      let p;
      try {
        p = await (0, n.readJson)(d);
      } catch (_) {
        let g = "No cached update info available";
        return _.code !== "ENOENT" && (await this.cleanCacheDirForPendingUpdate(), g += ` (error on read: ${_.message})`), l.info(g), null;
      }
      if (!(p?.fileName !== null))
        return l.warn("Cached update info is corrupted: no fileName, directory for cached update will be cleaned"), await this.cleanCacheDirForPendingUpdate(), null;
      if (u.info.sha512 !== p.sha512)
        return l.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${p.sha512}, expected: ${u.info.sha512}. Directory for cached update will be cleaned`), await this.cleanCacheDirForPendingUpdate(), null;
      const m = i.join(this.cacheDirForPendingUpdate, p.fileName);
      if (!await (0, n.pathExists)(m))
        return l.info("Cached update file doesn't exist"), null;
      const h = await s(m);
      return u.info.sha512 !== h ? (l.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${h}, expected: ${u.info.sha512}`), await this.cleanCacheDirForPendingUpdate(), null) : (this._downloadedFileInfo = p, m);
    }
    getUpdateInfoFile() {
      return i.join(this.cacheDirForPendingUpdate, "update-info.json");
    }
  };
  Oi.DownloadedUpdateHelper = a;
  function s(c, u = "sha512", l = "base64", d) {
    return new Promise((f, p) => {
      const v = (0, e.createHash)(u);
      v.on("error", p).setEncoding(l), (0, t.createReadStream)(c, {
        ...d,
        highWaterMark: 1024 * 1024
        /* better to use more memory but hash faster */
      }).on("error", p).on("end", () => {
        v.end(), f(v.read());
      }).pipe(v, { end: !1 });
    });
  }
  async function o(c, u, l) {
    let d = 0, f = i.join(u, c);
    for (let p = 0; p < 3; p++)
      try {
        return await (0, n.unlink)(f), f;
      } catch (v) {
        if (v.code === "ENOENT")
          return f;
        l.warn(`Error on remove temp update file: ${v}`), f = i.join(u, `${d++}-${c}`);
      }
    return f;
  }
  return Oi;
}
var ga = {}, Ns = {}, Vm;
function CS() {
  if (Vm) return Ns;
  Vm = 1, Object.defineProperty(Ns, "__esModule", { value: !0 }), Ns.getAppCacheDir = r;
  const e = vt, t = Yc;
  function r() {
    const n = (0, t.homedir)();
    let i;
    return process.platform === "win32" ? i = process.env.LOCALAPPDATA || e.join(n, "AppData", "Local") : process.platform === "darwin" ? i = e.join(n, "Library", "Caches") : i = process.env.XDG_CACHE_HOME || e.join(n, ".cache"), i;
  }
  return Ns;
}
var Hm;
function IS() {
  if (Hm) return ga;
  Hm = 1, Object.defineProperty(ga, "__esModule", { value: !0 }), ga.ElectronAppAdapter = void 0;
  const e = vt, t = CS();
  let r = class {
    constructor(i = Tn.app) {
      this.app = i;
    }
    whenReady() {
      return this.app.whenReady();
    }
    get version() {
      return this.app.getVersion();
    }
    get name() {
      return this.app.getName();
    }
    get isPackaged() {
      return this.app.isPackaged === !0;
    }
    get appUpdateConfigPath() {
      return this.isPackaged ? e.join(process.resourcesPath, "app-update.yml") : e.join(this.app.getAppPath(), "dev-app-update.yml");
    }
    get userDataPath() {
      return this.app.getPath("userData");
    }
    get baseCachePath() {
      return (0, t.getAppCacheDir)();
    }
    quit() {
      this.app.quit();
    }
    relaunch() {
      this.app.relaunch();
    }
    onQuit(i) {
      this.app.once("quit", (a, s) => i(s));
    }
  };
  return ga.ElectronAppAdapter = r, ga;
}
var Nf = {}, Gm;
function bS() {
  return Gm || (Gm = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ElectronHttpExecutor = e.NET_SESSION_NAME = void 0, e.getNetSession = r;
    const t = Jt();
    e.NET_SESSION_NAME = "electron-updater";
    function r() {
      return Tn.session.fromPartition(e.NET_SESSION_NAME, {
        cache: !1
      });
    }
    class n extends t.HttpExecutor {
      constructor(a) {
        super(), this.proxyLoginCallback = a, this.cachedSession = null;
      }
      async download(a, s, o) {
        return await o.cancellationToken.createPromise((c, u, l) => {
          const d = {
            headers: o.headers || void 0,
            redirect: "manual"
          };
          (0, t.configureRequestUrl)(a, d), (0, t.configureRequestOptions)(d), this.doDownload(d, {
            destination: s,
            options: o,
            onCancel: l,
            callback: (f) => {
              f == null ? c(s) : u(f);
            },
            responseHandler: null
          }, 0);
        });
      }
      createRequest(a, s) {
        a.headers && a.headers.Host && (a.host = a.headers.Host, delete a.headers.Host), this.cachedSession == null && (this.cachedSession = r());
        const o = Tn.net.request({
          ...a,
          session: this.cachedSession
        });
        return o.on("response", s), this.proxyLoginCallback != null && o.on("login", this.proxyLoginCallback), o;
      }
      addRedirectHandlers(a, s, o, c, u) {
        a.on("redirect", (l, d, f) => {
          a.abort(), c > this.maxRedirects ? o(this.createMaxRedirectError()) : u(t.HttpExecutor.prepareRedirectUrlOptions(f, s));
        });
      }
    }
    e.ElectronHttpExecutor = n;
  })(Nf)), Nf;
}
var va = {}, ii = {}, Pf, zm;
function FS() {
  if (zm) return Pf;
  zm = 1;
  var e = "[object Symbol]", t = /[\\^$.*+?()[\]{}|]/g, r = RegExp(t.source), n = typeof zr == "object" && zr && zr.Object === Object && zr, i = typeof self == "object" && self && self.Object === Object && self, a = n || i || Function("return this")(), s = Object.prototype, o = s.toString, c = a.Symbol, u = c ? c.prototype : void 0, l = u ? u.toString : void 0;
  function d(h) {
    if (typeof h == "string")
      return h;
    if (p(h))
      return l ? l.call(h) : "";
    var _ = h + "";
    return _ == "0" && 1 / h == -1 / 0 ? "-0" : _;
  }
  function f(h) {
    return !!h && typeof h == "object";
  }
  function p(h) {
    return typeof h == "symbol" || f(h) && o.call(h) == e;
  }
  function v(h) {
    return h == null ? "" : d(h);
  }
  function m(h) {
    return h = v(h), h && r.test(h) ? h.replace(t, "\\$&") : h;
  }
  return Pf = m, Pf;
}
var Wm;
function yi() {
  if (Wm) return ii;
  Wm = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.newBaseUrl = r, ii.newUrlFromBase = n, ii.getChannelFilename = i, ii.blockmapFiles = a;
  const e = Yi, t = FS();
  function r(s) {
    const o = new e.URL(s);
    return o.pathname.endsWith("/") || (o.pathname += "/"), o;
  }
  function n(s, o, c = !1) {
    const u = new e.URL(s, o), l = o.search;
    return l != null && l.length !== 0 ? u.search = l : c && (u.search = `noCache=${Date.now().toString(32)}`), u;
  }
  function i(s) {
    return `${s}.yml`;
  }
  function a(s, o, c) {
    const u = n(`${s.pathname}.blockmap`, s);
    return [n(`${s.pathname.replace(new RegExp(t(c), "g"), o)}.blockmap`, s), u];
  }
  return ii;
}
var dn = {}, Xm;
function Lr() {
  if (Xm) return dn;
  Xm = 1, Object.defineProperty(dn, "__esModule", { value: !0 }), dn.Provider = void 0, dn.findFile = i, dn.parseUpdateInfo = a, dn.getFileList = s, dn.resolveFiles = o;
  const e = Jt(), t = y0(), r = yi();
  let n = class {
    constructor(u) {
      this.runtimeOptions = u, this.requestHeaders = null, this.executor = u.executor;
    }
    get isUseMultipleRangeRequest() {
      return this.runtimeOptions.isUseMultipleRangeRequest !== !1;
    }
    getChannelFilePrefix() {
      if (this.runtimeOptions.platform === "linux") {
        const u = process.env.TEST_UPDATER_ARCH || process.arch;
        return "-linux" + (u === "x64" ? "" : `-${u}`);
      } else
        return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
    }
    // due to historical reasons for windows we use channel name without platform specifier
    getDefaultChannelName() {
      return this.getCustomChannelName("latest");
    }
    getCustomChannelName(u) {
      return `${u}${this.getChannelFilePrefix()}`;
    }
    get fileExtraDownloadHeaders() {
      return null;
    }
    setRequestHeaders(u) {
      this.requestHeaders = u;
    }
    /**
     * Method to perform API request only to resolve update info, but not to download update.
     */
    httpRequest(u, l, d) {
      return this.executor.request(this.createRequestOptions(u, l), d);
    }
    createRequestOptions(u, l) {
      const d = {};
      return this.requestHeaders == null ? l != null && (d.headers = l) : d.headers = l == null ? this.requestHeaders : { ...this.requestHeaders, ...l }, (0, e.configureRequestUrl)(u, d), d;
    }
  };
  dn.Provider = n;
  function i(c, u, l) {
    if (c.length === 0)
      throw (0, e.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
    const d = c.find((f) => f.url.pathname.toLowerCase().endsWith(`.${u}`));
    return d ?? (l == null ? c[0] : c.find((f) => !l.some((p) => f.url.pathname.toLowerCase().endsWith(`.${p}`))));
  }
  function a(c, u, l) {
    if (c == null)
      throw (0, e.newError)(`Cannot parse update info from ${u} in the latest release artifacts (${l}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    let d;
    try {
      d = (0, t.load)(c);
    } catch (f) {
      throw (0, e.newError)(`Cannot parse update info from ${u} in the latest release artifacts (${l}): ${f.stack || f.message}, rawData: ${c}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    return d;
  }
  function s(c) {
    const u = c.files;
    if (u != null && u.length > 0)
      return u;
    if (c.path != null)
      return [
        {
          url: c.path,
          sha2: c.sha2,
          sha512: c.sha512
        }
      ];
    throw (0, e.newError)(`No files provided: ${(0, e.safeStringifyJson)(c)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
  }
  function o(c, u, l = (d) => d) {
    const f = s(c).map((m) => {
      if (m.sha2 == null && m.sha512 == null)
        throw (0, e.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, e.safeStringifyJson)(m)}`, "ERR_UPDATER_NO_CHECKSUM");
      return {
        url: (0, r.newUrlFromBase)(l(m.url), u),
        info: m
      };
    }), p = c.packages, v = p == null ? null : p[process.arch] || p.ia32;
    return v != null && (f[0].packageInfo = {
      ...v,
      path: (0, r.newUrlFromBase)(l(v.path), u).href
    }), f;
  }
  return dn;
}
var Km;
function OE() {
  if (Km) return va;
  Km = 1, Object.defineProperty(va, "__esModule", { value: !0 }), va.GenericProvider = void 0;
  const e = Jt(), t = yi(), r = Lr();
  let n = class extends r.Provider {
    constructor(a, s, o) {
      super(o), this.configuration = a, this.updater = s, this.baseUrl = (0, t.newBaseUrl)(this.configuration.url);
    }
    get channel() {
      const a = this.updater.channel || this.configuration.channel;
      return a == null ? this.getDefaultChannelName() : this.getCustomChannelName(a);
    }
    async getLatestVersion() {
      const a = (0, t.getChannelFilename)(this.channel), s = (0, t.newUrlFromBase)(a, this.baseUrl, this.updater.isAddNoCacheQuery);
      for (let o = 0; ; o++)
        try {
          return (0, r.parseUpdateInfo)(await this.httpRequest(s), a, s);
        } catch (c) {
          if (c instanceof e.HttpError && c.statusCode === 404)
            throw (0, e.newError)(`Cannot find channel "${a}" update info: ${c.stack || c.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
          if (c.code === "ECONNREFUSED" && o < 3) {
            await new Promise((u, l) => {
              try {
                setTimeout(u, 1e3 * o);
              } catch (d) {
                l(d);
              }
            });
            continue;
          }
          throw c;
        }
    }
    resolveFiles(a) {
      return (0, r.resolveFiles)(a, this.baseUrl);
    }
  };
  return va.GenericProvider = n, va;
}
var _a = {}, ya = {}, Ym;
function DS() {
  if (Ym) return ya;
  Ym = 1, Object.defineProperty(ya, "__esModule", { value: !0 }), ya.BitbucketProvider = void 0;
  const e = Jt(), t = yi(), r = Lr();
  let n = class extends r.Provider {
    constructor(a, s, o) {
      super({
        ...o,
        isUseMultipleRangeRequest: !1
      }), this.configuration = a, this.updater = s;
      const { owner: c, slug: u } = a;
      this.baseUrl = (0, t.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${c}/${u}/downloads`);
    }
    get channel() {
      return this.updater.channel || this.configuration.channel || "latest";
    }
    async getLatestVersion() {
      const a = new e.CancellationToken(), s = (0, t.getChannelFilename)(this.getCustomChannelName(this.channel)), o = (0, t.newUrlFromBase)(s, this.baseUrl, this.updater.isAddNoCacheQuery);
      try {
        const c = await this.httpRequest(o, void 0, a);
        return (0, r.parseUpdateInfo)(c, s, o);
      } catch (c) {
        throw (0, e.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${c.stack || c.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    resolveFiles(a) {
      return (0, r.resolveFiles)(a, this.baseUrl);
    }
    toString() {
      const { owner: a, slug: s } = this.configuration;
      return `Bitbucket (owner: ${a}, slug: ${s}, channel: ${this.channel})`;
    }
  };
  return ya.BitbucketProvider = n, ya;
}
var Cn = {}, Jm;
function NE() {
  if (Jm) return Cn;
  Jm = 1, Object.defineProperty(Cn, "__esModule", { value: !0 }), Cn.GitHubProvider = Cn.BaseGitHubProvider = void 0, Cn.computeReleaseNotes = u;
  const e = Jt(), t = $E(), r = Yi, n = yi(), i = Lr(), a = /\/tag\/([^/]+)$/;
  class s extends i.Provider {
    constructor(d, f, p) {
      super({
        ...p,
        /* because GitHib uses S3 */
        isUseMultipleRangeRequest: !1
      }), this.options = d, this.baseUrl = (0, n.newBaseUrl)((0, e.githubUrl)(d, f));
      const v = f === "github.com" ? "api.github.com" : f;
      this.baseApiUrl = (0, n.newBaseUrl)((0, e.githubUrl)(d, v));
    }
    computeGithubBasePath(d) {
      const f = this.options.host;
      return f && !["github.com", "api.github.com"].includes(f) ? `/api/v3${d}` : d;
    }
  }
  Cn.BaseGitHubProvider = s;
  let o = class extends s {
    constructor(d, f, p) {
      super(d, "github.com", p), this.options = d, this.updater = f;
    }
    get channel() {
      const d = this.updater.channel || this.options.channel;
      return d == null ? this.getDefaultChannelName() : this.getCustomChannelName(d);
    }
    async getLatestVersion() {
      var d, f, p, v, m;
      const h = new e.CancellationToken(), _ = await this.httpRequest((0, n.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
        accept: "application/xml, application/atom+xml, text/xml, */*"
      }, h), g = (0, e.parseXml)(_);
      let y = g.element("entry", !1, "No published versions on GitHub"), x = null;
      try {
        if (this.updater.allowPrerelease) {
          const B = ((d = this.updater) === null || d === void 0 ? void 0 : d.channel) || ((f = t.prerelease(this.updater.currentVersion)) === null || f === void 0 ? void 0 : f[0]) || null;
          if (B === null)
            x = a.exec(y.element("link").attribute("href"))[1];
          else
            for (const F of g.getElements("entry")) {
              const U = a.exec(F.element("link").attribute("href"));
              if (U === null)
                continue;
              const G = U[1], M = ((p = t.prerelease(G)) === null || p === void 0 ? void 0 : p[0]) || null, V = !B || ["alpha", "beta"].includes(B), ie = M !== null && !["alpha", "beta"].includes(String(M));
              if (V && !ie && !(B === "beta" && M === "alpha")) {
                x = G;
                break;
              }
              if (M && M === B) {
                x = G;
                break;
              }
            }
        } else {
          x = await this.getLatestTagName(h);
          for (const B of g.getElements("entry"))
            if (a.exec(B.element("link").attribute("href"))[1] === x) {
              y = B;
              break;
            }
        }
      } catch (B) {
        throw (0, e.newError)(`Cannot parse releases feed: ${B.stack || B.message},
XML:
${_}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
      }
      if (x == null)
        throw (0, e.newError)("No published versions on GitHub", "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
      let S, w = "", E = "";
      const R = async (B) => {
        w = (0, n.getChannelFilename)(B), E = (0, n.newUrlFromBase)(this.getBaseDownloadPath(String(x), w), this.baseUrl);
        const F = this.createRequestOptions(E);
        try {
          return await this.executor.request(F, h);
        } catch (U) {
          throw U instanceof e.HttpError && U.statusCode === 404 ? (0, e.newError)(`Cannot find ${w} in the latest release artifacts (${E}): ${U.stack || U.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : U;
        }
      };
      try {
        let B = this.channel;
        this.updater.allowPrerelease && (!((v = t.prerelease(x)) === null || v === void 0) && v[0]) && (B = this.getCustomChannelName(String((m = t.prerelease(x)) === null || m === void 0 ? void 0 : m[0]))), S = await R(B);
      } catch (B) {
        if (this.updater.allowPrerelease)
          S = await R(this.getDefaultChannelName());
        else
          throw B;
      }
      const N = (0, i.parseUpdateInfo)(S, w, E);
      return N.releaseName == null && (N.releaseName = y.elementValueOrEmpty("title")), N.releaseNotes == null && (N.releaseNotes = u(this.updater.currentVersion, this.updater.fullChangelog, g, y)), {
        tag: x,
        ...N
      };
    }
    async getLatestTagName(d) {
      const f = this.options, p = f.host == null || f.host === "github.com" ? (0, n.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new r.URL(`${this.computeGithubBasePath(`/repos/${f.owner}/${f.repo}/releases`)}/latest`, this.baseApiUrl);
      try {
        const v = await this.httpRequest(p, { Accept: "application/json" }, d);
        return v == null ? null : JSON.parse(v).tag_name;
      } catch (v) {
        throw (0, e.newError)(`Unable to find latest version on GitHub (${p}), please ensure a production release exists: ${v.stack || v.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    get basePath() {
      return `/${this.options.owner}/${this.options.repo}/releases`;
    }
    resolveFiles(d) {
      return (0, i.resolveFiles)(d, this.baseUrl, (f) => this.getBaseDownloadPath(d.tag, f.replace(/ /g, "-")));
    }
    getBaseDownloadPath(d, f) {
      return `${this.basePath}/download/${d}/${f}`;
    }
  };
  Cn.GitHubProvider = o;
  function c(l) {
    const d = l.elementValueOrEmpty("content");
    return d === "No content." ? "" : d;
  }
  function u(l, d, f, p) {
    if (!d)
      return c(p);
    const v = [];
    for (const m of f.getElements("entry")) {
      const h = /\/tag\/v?([^/]+)$/.exec(m.element("link").attribute("href"))[1];
      t.lt(l, h) && v.push({
        version: h,
        note: c(m)
      });
    }
    return v.sort((m, h) => t.rcompare(m.version, h.version));
  }
  return Cn;
}
var Ea = {}, Qm;
function kS() {
  if (Qm) return Ea;
  Qm = 1, Object.defineProperty(Ea, "__esModule", { value: !0 }), Ea.KeygenProvider = void 0;
  const e = Jt(), t = yi(), r = Lr();
  let n = class extends r.Provider {
    constructor(a, s, o) {
      super({
        ...o,
        isUseMultipleRangeRequest: !1
      }), this.configuration = a, this.updater = s, this.defaultHostname = "api.keygen.sh";
      const c = this.configuration.host || this.defaultHostname;
      this.baseUrl = (0, t.newBaseUrl)(`https://${c}/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
    }
    get channel() {
      return this.updater.channel || this.configuration.channel || "stable";
    }
    async getLatestVersion() {
      const a = new e.CancellationToken(), s = (0, t.getChannelFilename)(this.getCustomChannelName(this.channel)), o = (0, t.newUrlFromBase)(s, this.baseUrl, this.updater.isAddNoCacheQuery);
      try {
        const c = await this.httpRequest(o, {
          Accept: "application/vnd.api+json",
          "Keygen-Version": "1.1"
        }, a);
        return (0, r.parseUpdateInfo)(c, s, o);
      } catch (c) {
        throw (0, e.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${c.stack || c.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    resolveFiles(a) {
      return (0, r.resolveFiles)(a, this.baseUrl);
    }
    toString() {
      const { account: a, product: s, platform: o } = this.configuration;
      return `Keygen (account: ${a}, product: ${s}, platform: ${o}, channel: ${this.channel})`;
    }
  };
  return Ea.KeygenProvider = n, Ea;
}
var wa = {}, Zm;
function LS() {
  if (Zm) return wa;
  Zm = 1, Object.defineProperty(wa, "__esModule", { value: !0 }), wa.PrivateGitHubProvider = void 0;
  const e = Jt(), t = y0(), r = vt, n = Yi, i = yi(), a = NE(), s = Lr();
  let o = class extends a.BaseGitHubProvider {
    constructor(u, l, d, f) {
      super(u, "api.github.com", f), this.updater = l, this.token = d;
    }
    createRequestOptions(u, l) {
      const d = super.createRequestOptions(u, l);
      return d.redirect = "manual", d;
    }
    async getLatestVersion() {
      const u = new e.CancellationToken(), l = (0, i.getChannelFilename)(this.getDefaultChannelName()), d = await this.getLatestVersionInfo(u), f = d.assets.find((m) => m.name === l);
      if (f == null)
        throw (0, e.newError)(`Cannot find ${l} in the release ${d.html_url || d.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      const p = new n.URL(f.url);
      let v;
      try {
        v = (0, t.load)(await this.httpRequest(p, this.configureHeaders("application/octet-stream"), u));
      } catch (m) {
        throw m instanceof e.HttpError && m.statusCode === 404 ? (0, e.newError)(`Cannot find ${l} in the latest release artifacts (${p}): ${m.stack || m.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : m;
      }
      return v.assets = d.assets, v;
    }
    get fileExtraDownloadHeaders() {
      return this.configureHeaders("application/octet-stream");
    }
    configureHeaders(u) {
      return {
        accept: u,
        authorization: `token ${this.token}`
      };
    }
    async getLatestVersionInfo(u) {
      const l = this.updater.allowPrerelease;
      let d = this.basePath;
      l || (d = `${d}/latest`);
      const f = (0, i.newUrlFromBase)(d, this.baseUrl);
      try {
        const p = JSON.parse(await this.httpRequest(f, this.configureHeaders("application/vnd.github.v3+json"), u));
        return l ? p.find((v) => v.prerelease) || p[0] : p;
      } catch (p) {
        throw (0, e.newError)(`Unable to find latest version on GitHub (${f}), please ensure a production release exists: ${p.stack || p.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    get basePath() {
      return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
    }
    resolveFiles(u) {
      return (0, s.getFileList)(u).map((l) => {
        const d = r.posix.basename(l.url).replace(/ /g, "-"), f = u.assets.find((p) => p != null && p.name === d);
        if (f == null)
          throw (0, e.newError)(`Cannot find asset "${d}" in: ${JSON.stringify(u.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
        return {
          url: new n.URL(f.url),
          info: l
        };
      });
    }
  };
  return wa.PrivateGitHubProvider = o, wa;
}
var e1;
function MS() {
  if (e1) return _a;
  e1 = 1, Object.defineProperty(_a, "__esModule", { value: !0 }), _a.isUrlProbablySupportMultiRangeRequests = s, _a.createClient = o;
  const e = Jt(), t = DS(), r = OE(), n = NE(), i = kS(), a = LS();
  function s(c) {
    return !c.includes("s3.amazonaws.com");
  }
  function o(c, u, l) {
    if (typeof c == "string")
      throw (0, e.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
    const d = c.provider;
    switch (d) {
      case "github": {
        const f = c, p = (f.private ? process.env.GH_TOKEN || process.env.GITHUB_TOKEN : null) || f.token;
        return p == null ? new n.GitHubProvider(f, u, l) : new a.PrivateGitHubProvider(f, u, p, l);
      }
      case "bitbucket":
        return new t.BitbucketProvider(c, u, l);
      case "keygen":
        return new i.KeygenProvider(c, u, l);
      case "s3":
      case "spaces":
        return new r.GenericProvider({
          provider: "generic",
          url: (0, e.getS3LikeProviderBaseUrl)(c),
          channel: c.channel || null
        }, u, {
          ...l,
          // https://github.com/minio/minio/issues/5285#issuecomment-350428955
          isUseMultipleRangeRequest: !1
        });
      case "generic": {
        const f = c;
        return new r.GenericProvider(f, u, {
          ...l,
          isUseMultipleRangeRequest: f.useMultipleRangeRequest !== !1 && s(f.url)
        });
      }
      case "custom": {
        const f = c, p = f.updateProvider;
        if (!p)
          throw (0, e.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
        return new p(f, u, l);
      }
      default:
        throw (0, e.newError)(`Unsupported provider: ${d}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
    }
  }
  return _a;
}
var xa = {}, Ta = {}, Ni = {}, Pi = {}, t1;
function R0() {
  if (t1) return Pi;
  t1 = 1, Object.defineProperty(Pi, "__esModule", { value: !0 }), Pi.OperationKind = void 0, Pi.computeOperations = t;
  var e;
  (function(s) {
    s[s.COPY = 0] = "COPY", s[s.DOWNLOAD = 1] = "DOWNLOAD";
  })(e || (Pi.OperationKind = e = {}));
  function t(s, o, c) {
    const u = a(s.files), l = a(o.files);
    let d = null;
    const f = o.files[0], p = [], v = f.name, m = u.get(v);
    if (m == null)
      throw new Error(`no file ${v} in old blockmap`);
    const h = l.get(v);
    let _ = 0;
    const { checksumToOffset: g, checksumToOldSize: y } = i(u.get(v), m.offset, c);
    let x = f.offset;
    for (let S = 0; S < h.checksums.length; x += h.sizes[S], S++) {
      const w = h.sizes[S], E = h.checksums[S];
      let R = g.get(E);
      R != null && y.get(E) !== w && (c.warn(`Checksum ("${E}") matches, but size differs (old: ${y.get(E)}, new: ${w})`), R = void 0), R === void 0 ? (_++, d != null && d.kind === e.DOWNLOAD && d.end === x ? d.end += w : (d = {
        kind: e.DOWNLOAD,
        start: x,
        end: x + w
        // oldBlocks: null,
      }, n(d, p, E, S))) : d != null && d.kind === e.COPY && d.end === R ? d.end += w : (d = {
        kind: e.COPY,
        start: R,
        end: R + w
        // oldBlocks: [checksum]
      }, n(d, p, E, S));
    }
    return _ > 0 && c.info(`File${f.name === "file" ? "" : " " + f.name} has ${_} changed blocks`), p;
  }
  const r = process.env.DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES === "true";
  function n(s, o, c, u) {
    if (r && o.length !== 0) {
      const l = o[o.length - 1];
      if (l.kind === s.kind && s.start < l.end && s.start > l.start) {
        const d = [l.start, l.end, s.start, s.end].reduce((f, p) => f < p ? f : p);
        throw new Error(`operation (block index: ${u}, checksum: ${c}, kind: ${e[s.kind]}) overlaps previous operation (checksum: ${c}):
abs: ${l.start} until ${l.end} and ${s.start} until ${s.end}
rel: ${l.start - d} until ${l.end - d} and ${s.start - d} until ${s.end - d}`);
      }
    }
    o.push(s);
  }
  function i(s, o, c) {
    const u = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
    let d = o;
    for (let f = 0; f < s.checksums.length; f++) {
      const p = s.checksums[f], v = s.sizes[f], m = l.get(p);
      if (m === void 0)
        u.set(p, d), l.set(p, v);
      else if (c.debug != null) {
        const h = m === v ? "(same size)" : `(size: ${m}, this size: ${v})`;
        c.debug(`${p} duplicated in blockmap ${h}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
      }
      d += v;
    }
    return { checksumToOffset: u, checksumToOldSize: l };
  }
  function a(s) {
    const o = /* @__PURE__ */ new Map();
    for (const c of s)
      o.set(c.name, c);
    return o;
  }
  return Pi;
}
var r1;
function PE() {
  if (r1) return Ni;
  r1 = 1, Object.defineProperty(Ni, "__esModule", { value: !0 }), Ni.DataSplitter = void 0, Ni.copyData = s;
  const e = Jt(), t = Kr, r = es, n = R0(), i = Buffer.from(`\r
\r
`);
  var a;
  (function(c) {
    c[c.INIT = 0] = "INIT", c[c.HEADER = 1] = "HEADER", c[c.BODY = 2] = "BODY";
  })(a || (a = {}));
  function s(c, u, l, d, f) {
    const p = (0, t.createReadStream)("", {
      fd: l,
      autoClose: !1,
      start: c.start,
      // end is inclusive
      end: c.end - 1
    });
    p.on("error", d), p.once("end", f), p.pipe(u, {
      end: !1
    });
  }
  let o = class extends r.Writable {
    constructor(u, l, d, f, p, v) {
      super(), this.out = u, this.options = l, this.partIndexToTaskIndex = d, this.partIndexToLength = p, this.finishHandler = v, this.partIndex = -1, this.headerListBuffer = null, this.readState = a.INIT, this.ignoreByteCount = 0, this.remainingPartDataCount = 0, this.actualPartLength = 0, this.boundaryLength = f.length + 4, this.ignoreByteCount = this.boundaryLength - 2;
    }
    get isFinished() {
      return this.partIndex === this.partIndexToLength.length;
    }
    // noinspection JSUnusedGlobalSymbols
    _write(u, l, d) {
      if (this.isFinished) {
        console.error(`Trailing ignored data: ${u.length} bytes`);
        return;
      }
      this.handleData(u).then(d).catch(d);
    }
    async handleData(u) {
      let l = 0;
      if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0)
        throw (0, e.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
      if (this.ignoreByteCount > 0) {
        const d = Math.min(this.ignoreByteCount, u.length);
        this.ignoreByteCount -= d, l = d;
      } else if (this.remainingPartDataCount > 0) {
        const d = Math.min(this.remainingPartDataCount, u.length);
        this.remainingPartDataCount -= d, await this.processPartData(u, 0, d), l = d;
      }
      if (l !== u.length) {
        if (this.readState === a.HEADER) {
          const d = this.searchHeaderListEnd(u, l);
          if (d === -1)
            return;
          l = d, this.readState = a.BODY, this.headerListBuffer = null;
        }
        for (; ; ) {
          if (this.readState === a.BODY)
            this.readState = a.INIT;
          else {
            this.partIndex++;
            let v = this.partIndexToTaskIndex.get(this.partIndex);
            if (v == null)
              if (this.isFinished)
                v = this.options.end;
              else
                throw (0, e.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
            const m = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
            if (m < v)
              await this.copyExistingData(m, v);
            else if (m > v)
              throw (0, e.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
            if (this.isFinished) {
              this.onPartEnd(), this.finishHandler();
              return;
            }
            if (l = this.searchHeaderListEnd(u, l), l === -1) {
              this.readState = a.HEADER;
              return;
            }
          }
          const d = this.partIndexToLength[this.partIndex], f = l + d, p = Math.min(f, u.length);
          if (await this.processPartStarted(u, l, p), this.remainingPartDataCount = d - (p - l), this.remainingPartDataCount > 0)
            return;
          if (l = f + this.boundaryLength, l >= u.length) {
            this.ignoreByteCount = this.boundaryLength - (u.length - f);
            return;
          }
        }
      }
    }
    copyExistingData(u, l) {
      return new Promise((d, f) => {
        const p = () => {
          if (u === l) {
            d();
            return;
          }
          const v = this.options.tasks[u];
          if (v.kind !== n.OperationKind.COPY) {
            f(new Error("Task kind must be COPY"));
            return;
          }
          s(v, this.out, this.options.oldFileFd, f, () => {
            u++, p();
          });
        };
        p();
      });
    }
    searchHeaderListEnd(u, l) {
      const d = u.indexOf(i, l);
      if (d !== -1)
        return d + i.length;
      const f = l === 0 ? u : u.slice(l);
      return this.headerListBuffer == null ? this.headerListBuffer = f : this.headerListBuffer = Buffer.concat([this.headerListBuffer, f]), -1;
    }
    onPartEnd() {
      const u = this.partIndexToLength[this.partIndex - 1];
      if (this.actualPartLength !== u)
        throw (0, e.newError)(`Expected length: ${u} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
      this.actualPartLength = 0;
    }
    processPartStarted(u, l, d) {
      return this.partIndex !== 0 && this.onPartEnd(), this.processPartData(u, l, d);
    }
    processPartData(u, l, d) {
      this.actualPartLength += d - l;
      const f = this.out;
      return f.write(l === 0 && u.length === d ? u : u.slice(l, d)) ? Promise.resolve() : new Promise((p, v) => {
        f.on("error", v), f.once("drain", () => {
          f.removeListener("error", v), p();
        });
      });
    }
  };
  return Ni.DataSplitter = o, Ni;
}
var Sa = {}, n1;
function US() {
  if (n1) return Sa;
  n1 = 1, Object.defineProperty(Sa, "__esModule", { value: !0 }), Sa.executeTasksUsingMultipleRangeRequests = n, Sa.checkIsRangesSupported = a;
  const e = Jt(), t = PE(), r = R0();
  function n(s, o, c, u, l) {
    const d = (f) => {
      if (f >= o.length) {
        s.fileMetadataBuffer != null && c.write(s.fileMetadataBuffer), c.end();
        return;
      }
      const p = f + 1e3;
      i(s, {
        tasks: o,
        start: f,
        end: Math.min(o.length, p),
        oldFileFd: u
      }, c, () => d(p), l);
    };
    return d;
  }
  function i(s, o, c, u, l) {
    let d = "bytes=", f = 0;
    const p = /* @__PURE__ */ new Map(), v = [];
    for (let _ = o.start; _ < o.end; _++) {
      const g = o.tasks[_];
      g.kind === r.OperationKind.DOWNLOAD && (d += `${g.start}-${g.end - 1}, `, p.set(f, _), f++, v.push(g.end - g.start));
    }
    if (f <= 1) {
      const _ = (g) => {
        if (g >= o.end) {
          u();
          return;
        }
        const y = o.tasks[g++];
        if (y.kind === r.OperationKind.COPY)
          (0, t.copyData)(y, c, o.oldFileFd, l, () => _(g));
        else {
          const x = s.createRequestOptions();
          x.headers.Range = `bytes=${y.start}-${y.end - 1}`;
          const S = s.httpExecutor.createRequest(x, (w) => {
            a(w, l) && (w.pipe(c, {
              end: !1
            }), w.once("end", () => _(g)));
          });
          s.httpExecutor.addErrorAndTimeoutHandlers(S, l), S.end();
        }
      };
      _(o.start);
      return;
    }
    const m = s.createRequestOptions();
    m.headers.Range = d.substring(0, d.length - 2);
    const h = s.httpExecutor.createRequest(m, (_) => {
      if (!a(_, l))
        return;
      const g = (0, e.safeGetHeader)(_, "content-type"), y = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(g);
      if (y == null) {
        l(new Error(`Content-Type "multipart/byteranges" is expected, but got "${g}"`));
        return;
      }
      const x = new t.DataSplitter(c, o, p, y[1] || y[2], v, u);
      x.on("error", l), _.pipe(x), _.on("end", () => {
        setTimeout(() => {
          h.abort(), l(new Error("Response ends without calling any handlers"));
        }, 1e4);
      });
    });
    s.httpExecutor.addErrorAndTimeoutHandlers(h, l), h.end();
  }
  function a(s, o) {
    if (s.statusCode >= 400)
      return o((0, e.createHttpError)(s)), !1;
    if (s.statusCode !== 206) {
      const c = (0, e.safeGetHeader)(s, "accept-ranges");
      if (c == null || c === "none")
        return o(new Error(`Server doesn't support Accept-Ranges (response code ${s.statusCode})`)), !1;
    }
    return !0;
  }
  return Sa;
}
var Aa = {}, i1;
function qS() {
  if (i1) return Aa;
  i1 = 1, Object.defineProperty(Aa, "__esModule", { value: !0 }), Aa.ProgressDifferentialDownloadCallbackTransform = void 0;
  const e = es;
  var t;
  (function(n) {
    n[n.COPY = 0] = "COPY", n[n.DOWNLOAD = 1] = "DOWNLOAD";
  })(t || (t = {}));
  let r = class extends e.Transform {
    constructor(i, a, s) {
      super(), this.progressDifferentialDownloadInfo = i, this.cancellationToken = a, this.onProgress = s, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.expectedBytes = 0, this.index = 0, this.operationType = t.COPY, this.nextUpdate = this.start + 1e3;
    }
    _transform(i, a, s) {
      if (this.cancellationToken.cancelled) {
        s(new Error("cancelled"), null);
        return;
      }
      if (this.operationType == t.COPY) {
        s(null, i);
        return;
      }
      this.transferred += i.length, this.delta += i.length;
      const o = Date.now();
      o >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal && (this.nextUpdate = o + 1e3, this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((o - this.start) / 1e3))
      }), this.delta = 0), s(null, i);
    }
    beginFileCopy() {
      this.operationType = t.COPY;
    }
    beginRangeDownload() {
      this.operationType = t.DOWNLOAD, this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
    }
    endRangeDownload() {
      this.transferred !== this.progressDifferentialDownloadInfo.grandTotal && this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
    }
    // Called when we are 100% done with the connection/download
    _flush(i) {
      if (this.cancellationToken.cancelled) {
        i(new Error("cancelled"));
        return;
      }
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      }), this.delta = 0, this.transferred = 0, i(null);
    }
  };
  return Aa.ProgressDifferentialDownloadCallbackTransform = r, Aa;
}
var a1;
function CE() {
  if (a1) return Ta;
  a1 = 1, Object.defineProperty(Ta, "__esModule", { value: !0 }), Ta.DifferentialDownloader = void 0;
  const e = Jt(), t = /* @__PURE__ */ zn(), r = Kr, n = PE(), i = Yi, a = R0(), s = US(), o = qS();
  let c = class {
    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
    constructor(f, p, v) {
      this.blockAwareFileInfo = f, this.httpExecutor = p, this.options = v, this.fileMetadataBuffer = null, this.logger = v.logger;
    }
    createRequestOptions() {
      const f = {
        headers: {
          ...this.options.requestHeaders,
          accept: "*/*"
        }
      };
      return (0, e.configureRequestUrl)(this.options.newUrl, f), (0, e.configureRequestOptions)(f), f;
    }
    doDownload(f, p) {
      if (f.version !== p.version)
        throw new Error(`version is different (${f.version} - ${p.version}), full download is required`);
      const v = this.logger, m = (0, a.computeOperations)(f, p, v);
      v.debug != null && v.debug(JSON.stringify(m, null, 2));
      let h = 0, _ = 0;
      for (const y of m) {
        const x = y.end - y.start;
        y.kind === a.OperationKind.DOWNLOAD ? h += x : _ += x;
      }
      const g = this.blockAwareFileInfo.size;
      if (h + _ + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== g)
        throw new Error(`Internal error, size mismatch: downloadSize: ${h}, copySize: ${_}, newSize: ${g}`);
      return v.info(`Full: ${u(g)}, To download: ${u(h)} (${Math.round(h / (g / 100))}%)`), this.downloadFile(m);
    }
    downloadFile(f) {
      const p = [], v = () => Promise.all(p.map((m) => (0, t.close)(m.descriptor).catch((h) => {
        this.logger.error(`cannot close file "${m.path}": ${h}`);
      })));
      return this.doDownloadFile(f, p).then(v).catch((m) => v().catch((h) => {
        try {
          this.logger.error(`cannot close files: ${h}`);
        } catch (_) {
          try {
            console.error(_);
          } catch {
          }
        }
        throw m;
      }).then(() => {
        throw m;
      }));
    }
    async doDownloadFile(f, p) {
      const v = await (0, t.open)(this.options.oldFile, "r");
      p.push({ descriptor: v, path: this.options.oldFile });
      const m = await (0, t.open)(this.options.newFile, "w");
      p.push({ descriptor: m, path: this.options.newFile });
      const h = (0, r.createWriteStream)(this.options.newFile, { fd: m });
      await new Promise((_, g) => {
        const y = [];
        let x;
        if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
          const U = [];
          let G = 0;
          for (const V of f)
            V.kind === a.OperationKind.DOWNLOAD && (U.push(V.end - V.start), G += V.end - V.start);
          const M = {
            expectedByteCounts: U,
            grandTotal: G
          };
          x = new o.ProgressDifferentialDownloadCallbackTransform(M, this.options.cancellationToken, this.options.onProgress), y.push(x);
        }
        const S = new e.DigestTransform(this.blockAwareFileInfo.sha512);
        S.isValidateOnEnd = !1, y.push(S), h.on("finish", () => {
          h.close(() => {
            p.splice(1, 1);
            try {
              S.validate();
            } catch (U) {
              g(U);
              return;
            }
            _(void 0);
          });
        }), y.push(h);
        let w = null;
        for (const U of y)
          U.on("error", g), w == null ? w = U : w = w.pipe(U);
        const E = y[0];
        let R;
        if (this.options.isUseMultipleRangeRequest) {
          R = (0, s.executeTasksUsingMultipleRangeRequests)(this, f, E, v, g), R(0);
          return;
        }
        let N = 0, B = null;
        this.logger.info(`Differential download: ${this.options.newUrl}`);
        const F = this.createRequestOptions();
        F.redirect = "manual", R = (U) => {
          var G, M;
          if (U >= f.length) {
            this.fileMetadataBuffer != null && E.write(this.fileMetadataBuffer), E.end();
            return;
          }
          const V = f[U++];
          if (V.kind === a.OperationKind.COPY) {
            x && x.beginFileCopy(), (0, n.copyData)(V, E, v, g, () => R(U));
            return;
          }
          const ie = `bytes=${V.start}-${V.end - 1}`;
          F.headers.range = ie, (M = (G = this.logger) === null || G === void 0 ? void 0 : G.debug) === null || M === void 0 || M.call(G, `download range: ${ie}`), x && x.beginRangeDownload();
          const W = this.httpExecutor.createRequest(F, (ae) => {
            ae.on("error", g), ae.on("aborted", () => {
              g(new Error("response has been aborted by the server"));
            }), ae.statusCode >= 400 && g((0, e.createHttpError)(ae)), ae.pipe(E, {
              end: !1
            }), ae.once("end", () => {
              x && x.endRangeDownload(), ++N === 100 ? (N = 0, setTimeout(() => R(U), 1e3)) : R(U);
            });
          });
          W.on("redirect", (ae, se, X) => {
            this.logger.info(`Redirect to ${l(X)}`), B = X, (0, e.configureRequestUrl)(new i.URL(B), F), W.followRedirect();
          }), this.httpExecutor.addErrorAndTimeoutHandlers(W, g), W.end();
        }, R(0);
      });
    }
    async readRemoteBytes(f, p) {
      const v = Buffer.allocUnsafe(p + 1 - f), m = this.createRequestOptions();
      m.headers.range = `bytes=${f}-${p}`;
      let h = 0;
      if (await this.request(m, (_) => {
        _.copy(v, h), h += _.length;
      }), h !== v.length)
        throw new Error(`Received data length ${h} is not equal to expected ${v.length}`);
      return v;
    }
    request(f, p) {
      return new Promise((v, m) => {
        const h = this.httpExecutor.createRequest(f, (_) => {
          (0, s.checkIsRangesSupported)(_, m) && (_.on("error", m), _.on("aborted", () => {
            m(new Error("response has been aborted by the server"));
          }), _.on("data", p), _.on("end", () => v()));
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(h, m), h.end();
      });
    }
  };
  Ta.DifferentialDownloader = c;
  function u(d, f = " KB") {
    return new Intl.NumberFormat("en").format((d / 1024).toFixed(2)) + f;
  }
  function l(d) {
    const f = d.indexOf("?");
    return f < 0 ? d : d.substring(0, f);
  }
  return Ta;
}
var s1;
function BS() {
  if (s1) return xa;
  s1 = 1, Object.defineProperty(xa, "__esModule", { value: !0 }), xa.GenericDifferentialDownloader = void 0;
  const e = CE();
  let t = class extends e.DifferentialDownloader {
    download(n, i) {
      return this.doDownload(n, i);
    }
  };
  return xa.GenericDifferentialDownloader = t, xa;
}
var Cf = {}, o1;
function Ei() {
  return o1 || (o1 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.UpdaterSignal = e.UPDATE_DOWNLOADED = e.DOWNLOAD_PROGRESS = e.CancellationToken = void 0, e.addHandler = n;
    const t = Jt();
    Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
      return t.CancellationToken;
    } }), e.DOWNLOAD_PROGRESS = "download-progress", e.UPDATE_DOWNLOADED = "update-downloaded";
    class r {
      constructor(a) {
        this.emitter = a;
      }
      /**
       * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
       */
      login(a) {
        n(this.emitter, "login", a);
      }
      progress(a) {
        n(this.emitter, e.DOWNLOAD_PROGRESS, a);
      }
      updateDownloaded(a) {
        n(this.emitter, e.UPDATE_DOWNLOADED, a);
      }
      updateCancelled(a) {
        n(this.emitter, "update-cancelled", a);
      }
    }
    e.UpdaterSignal = r;
    function n(i, a, s) {
      i.on(a, s);
    }
  })(Cf)), Cf;
}
var c1;
function $0() {
  if (c1) return ti;
  c1 = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.NoOpLogger = ti.AppUpdater = void 0;
  const e = Jt(), t = ts, r = Yc, n = Qy, i = /* @__PURE__ */ zn(), a = y0(), s = iS(), o = vt, c = $E(), u = PS(), l = IS(), d = bS(), f = OE(), p = MS(), v = eE, m = yi(), h = BS(), _ = Ei();
  let g = class IE extends n.EventEmitter {
    /**
     * Get the update channel. Doesn't return `channel` from the update configuration, only if was previously set.
     */
    get channel() {
      return this._channel;
    }
    /**
     * Set the update channel. Overrides `channel` in the update configuration.
     *
     * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
     */
    set channel(w) {
      if (this._channel != null) {
        if (typeof w != "string")
          throw (0, e.newError)(`Channel must be a string, but got: ${w}`, "ERR_UPDATER_INVALID_CHANNEL");
        if (w.length === 0)
          throw (0, e.newError)("Channel must be not an empty string", "ERR_UPDATER_INVALID_CHANNEL");
      }
      this._channel = w, this.allowDowngrade = !0;
    }
    /**
     *  Shortcut for explicitly adding auth tokens to request headers
     */
    addAuthHeader(w) {
      this.requestHeaders = Object.assign({}, this.requestHeaders, {
        authorization: w
      });
    }
    // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
    get netSession() {
      return (0, d.getNetSession)();
    }
    /**
     * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
     * Set it to `null` if you would like to disable a logging feature.
     */
    get logger() {
      return this._logger;
    }
    set logger(w) {
      this._logger = w ?? new x();
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * test only
     * @private
     */
    set updateConfigPath(w) {
      this.clientPromise = null, this._appUpdateConfigPath = w, this.configOnDisk = new s.Lazy(() => this.loadUpdateConfig());
    }
    /**
     * Allows developer to override default logic for determining if an update is supported.
     * The default logic compares the `UpdateInfo` minimum system version against the `os.release()` with `semver` package
     */
    get isUpdateSupported() {
      return this._isUpdateSupported;
    }
    set isUpdateSupported(w) {
      w && (this._isUpdateSupported = w);
    }
    constructor(w, E) {
      super(), this.autoDownload = !0, this.autoInstallOnAppQuit = !0, this.autoRunAppAfterInstall = !0, this.allowPrerelease = !1, this.fullChangelog = !1, this.allowDowngrade = !1, this.disableWebInstaller = !1, this.disableDifferentialDownload = !1, this.forceDevUpdateConfig = !1, this._channel = null, this.downloadedUpdateHelper = null, this.requestHeaders = null, this._logger = console, this.signals = new _.UpdaterSignal(this), this._appUpdateConfigPath = null, this._isUpdateSupported = (B) => this.checkIfUpdateSupported(B), this.clientPromise = null, this.stagingUserIdPromise = new s.Lazy(() => this.getOrCreateStagingUserId()), this.configOnDisk = new s.Lazy(() => this.loadUpdateConfig()), this.checkForUpdatesPromise = null, this.downloadPromise = null, this.updateInfoAndProvider = null, this._testOnlyOptions = null, this.on("error", (B) => {
        this._logger.error(`Error: ${B.stack || B.message}`);
      }), E == null ? (this.app = new l.ElectronAppAdapter(), this.httpExecutor = new d.ElectronHttpExecutor((B, F) => this.emit("login", B, F))) : (this.app = E, this.httpExecutor = null);
      const R = this.app.version, N = (0, c.parse)(R);
      if (N == null)
        throw (0, e.newError)(`App version is not a valid semver version: "${R}"`, "ERR_UPDATER_INVALID_VERSION");
      this.currentVersion = N, this.allowPrerelease = y(N), w != null && (this.setFeedURL(w), typeof w != "string" && w.requestHeaders && (this.requestHeaders = w.requestHeaders));
    }
    //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
    getFeedURL() {
      return "Deprecated. Do not use it.";
    }
    /**
     * Configure update provider. If value is `string`, [GenericServerOptions](./publish.md#genericserveroptions) will be set with value as `url`.
     * @param options If you want to override configuration in the `app-update.yml`.
     */
    setFeedURL(w) {
      const E = this.createProviderRuntimeOptions();
      let R;
      typeof w == "string" ? R = new f.GenericProvider({ provider: "generic", url: w }, this, {
        ...E,
        isUseMultipleRangeRequest: (0, p.isUrlProbablySupportMultiRangeRequests)(w)
      }) : R = (0, p.createClient)(w, this, E), this.clientPromise = Promise.resolve(R);
    }
    /**
     * Asks the server whether there is an update.
     * @returns null if the updater is disabled, otherwise info about the latest version
     */
    checkForUpdates() {
      if (!this.isUpdaterActive())
        return Promise.resolve(null);
      let w = this.checkForUpdatesPromise;
      if (w != null)
        return this._logger.info("Checking for update (already in progress)"), w;
      const E = () => this.checkForUpdatesPromise = null;
      return this._logger.info("Checking for update"), w = this.doCheckForUpdates().then((R) => (E(), R)).catch((R) => {
        throw E(), this.emit("error", R, `Cannot check for updates: ${(R.stack || R).toString()}`), R;
      }), this.checkForUpdatesPromise = w, w;
    }
    isUpdaterActive() {
      return this.app.isPackaged || this.forceDevUpdateConfig ? !0 : (this._logger.info("Skip checkForUpdates because application is not packed and dev update config is not forced"), !1);
    }
    // noinspection JSUnusedGlobalSymbols
    checkForUpdatesAndNotify(w) {
      return this.checkForUpdates().then((E) => E?.downloadPromise ? (E.downloadPromise.then(() => {
        const R = IE.formatDownloadNotification(E.updateInfo.version, this.app.name, w);
        new Tn.Notification(R).show();
      }), E) : (this._logger.debug != null && this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null"), E));
    }
    static formatDownloadNotification(w, E, R) {
      return R == null && (R = {
        title: "A new update is ready to install",
        body: "{appName} version {version} has been downloaded and will be automatically installed on exit"
      }), R = {
        title: R.title.replace("{appName}", E).replace("{version}", w),
        body: R.body.replace("{appName}", E).replace("{version}", w)
      }, R;
    }
    async isStagingMatch(w) {
      const E = w.stagingPercentage;
      let R = E;
      if (R == null)
        return !0;
      if (R = parseInt(R, 10), isNaN(R))
        return this._logger.warn(`Staging percentage is NaN: ${E}`), !0;
      R = R / 100;
      const N = await this.stagingUserIdPromise.value, F = e.UUID.parse(N).readUInt32BE(12) / 4294967295;
      return this._logger.info(`Staging percentage: ${R}, percentage: ${F}, user id: ${N}`), F < R;
    }
    computeFinalHeaders(w) {
      return this.requestHeaders != null && Object.assign(w, this.requestHeaders), w;
    }
    async isUpdateAvailable(w) {
      const E = (0, c.parse)(w.version);
      if (E == null)
        throw (0, e.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${w.version}"`, "ERR_UPDATER_INVALID_VERSION");
      const R = this.currentVersion;
      if ((0, c.eq)(E, R) || !await Promise.resolve(this.isUpdateSupported(w)) || !await this.isStagingMatch(w))
        return !1;
      const B = (0, c.gt)(E, R), F = (0, c.lt)(E, R);
      return B ? !0 : this.allowDowngrade && F;
    }
    checkIfUpdateSupported(w) {
      const E = w?.minimumSystemVersion, R = (0, r.release)();
      if (E)
        try {
          if ((0, c.lt)(R, E))
            return this._logger.info(`Current OS version ${R} is less than the minimum OS version required ${E} for version ${R}`), !1;
        } catch (N) {
          this._logger.warn(`Failed to compare current OS version(${R}) with minimum OS version(${E}): ${(N.message || N).toString()}`);
        }
      return !0;
    }
    async getUpdateInfoAndProvider() {
      await this.app.whenReady(), this.clientPromise == null && (this.clientPromise = this.configOnDisk.value.then((R) => (0, p.createClient)(R, this, this.createProviderRuntimeOptions())));
      const w = await this.clientPromise, E = await this.stagingUserIdPromise.value;
      return w.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": E })), {
        info: await w.getLatestVersion(),
        provider: w
      };
    }
    createProviderRuntimeOptions() {
      return {
        isUseMultipleRangeRequest: !0,
        platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
        executor: this.httpExecutor
      };
    }
    async doCheckForUpdates() {
      this.emit("checking-for-update");
      const w = await this.getUpdateInfoAndProvider(), E = w.info;
      if (!await this.isUpdateAvailable(E))
        return this._logger.info(`Update for version ${this.currentVersion.format()} is not available (latest version: ${E.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`), this.emit("update-not-available", E), {
          isUpdateAvailable: !1,
          versionInfo: E,
          updateInfo: E
        };
      this.updateInfoAndProvider = w, this.onUpdateAvailable(E);
      const R = new e.CancellationToken();
      return {
        isUpdateAvailable: !0,
        versionInfo: E,
        updateInfo: E,
        cancellationToken: R,
        downloadPromise: this.autoDownload ? this.downloadUpdate(R) : null
      };
    }
    onUpdateAvailable(w) {
      this._logger.info(`Found version ${w.version} (url: ${(0, e.asArray)(w.files).map((E) => E.url).join(", ")})`), this.emit("update-available", w);
    }
    /**
     * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
     * @returns {Promise<Array<string>>} Paths to downloaded files.
     */
    downloadUpdate(w = new e.CancellationToken()) {
      const E = this.updateInfoAndProvider;
      if (E == null) {
        const N = new Error("Please check update first");
        return this.dispatchError(N), Promise.reject(N);
      }
      if (this.downloadPromise != null)
        return this._logger.info("Downloading update (already in progress)"), this.downloadPromise;
      this._logger.info(`Downloading update from ${(0, e.asArray)(E.info.files).map((N) => N.url).join(", ")}`);
      const R = (N) => {
        if (!(N instanceof e.CancellationError))
          try {
            this.dispatchError(N);
          } catch (B) {
            this._logger.warn(`Cannot dispatch error event: ${B.stack || B}`);
          }
        return N;
      };
      return this.downloadPromise = this.doDownloadUpdate({
        updateInfoAndProvider: E,
        requestHeaders: this.computeRequestHeaders(E.provider),
        cancellationToken: w,
        disableWebInstaller: this.disableWebInstaller,
        disableDifferentialDownload: this.disableDifferentialDownload
      }).catch((N) => {
        throw R(N);
      }).finally(() => {
        this.downloadPromise = null;
      }), this.downloadPromise;
    }
    dispatchError(w) {
      this.emit("error", w, (w.stack || w).toString());
    }
    dispatchUpdateDownloaded(w) {
      this.emit(_.UPDATE_DOWNLOADED, w);
    }
    async loadUpdateConfig() {
      return this._appUpdateConfigPath == null && (this._appUpdateConfigPath = this.app.appUpdateConfigPath), (0, a.load)(await (0, i.readFile)(this._appUpdateConfigPath, "utf-8"));
    }
    computeRequestHeaders(w) {
      const E = w.fileExtraDownloadHeaders;
      if (E != null) {
        const R = this.requestHeaders;
        return R == null ? E : {
          ...E,
          ...R
        };
      }
      return this.computeFinalHeaders({ accept: "*/*" });
    }
    async getOrCreateStagingUserId() {
      const w = o.join(this.app.userDataPath, ".updaterId");
      try {
        const R = await (0, i.readFile)(w, "utf-8");
        if (e.UUID.check(R))
          return R;
        this._logger.warn(`Staging user id file exists, but content was invalid: ${R}`);
      } catch (R) {
        R.code !== "ENOENT" && this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${R}`);
      }
      const E = e.UUID.v5((0, t.randomBytes)(4096), e.UUID.OID);
      this._logger.info(`Generated new staging user ID: ${E}`);
      try {
        await (0, i.outputFile)(w, E);
      } catch (R) {
        this._logger.warn(`Couldn't write out staging user ID: ${R}`);
      }
      return E;
    }
    /** @internal */
    get isAddNoCacheQuery() {
      const w = this.requestHeaders;
      if (w == null)
        return !0;
      for (const E of Object.keys(w)) {
        const R = E.toLowerCase();
        if (R === "authorization" || R === "private-token")
          return !1;
      }
      return !0;
    }
    async getOrCreateDownloadHelper() {
      let w = this.downloadedUpdateHelper;
      if (w == null) {
        const E = (await this.configOnDisk.value).updaterCacheDirName, R = this._logger;
        E == null && R.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
        const N = o.join(this.app.baseCachePath, E || this.app.name);
        R.debug != null && R.debug(`updater cache dir: ${N}`), w = new u.DownloadedUpdateHelper(N), this.downloadedUpdateHelper = w;
      }
      return w;
    }
    async executeDownload(w) {
      const E = w.fileInfo, R = {
        headers: w.downloadUpdateOptions.requestHeaders,
        cancellationToken: w.downloadUpdateOptions.cancellationToken,
        sha2: E.info.sha2,
        sha512: E.info.sha512
      };
      this.listenerCount(_.DOWNLOAD_PROGRESS) > 0 && (R.onProgress = (C) => this.emit(_.DOWNLOAD_PROGRESS, C));
      const N = w.downloadUpdateOptions.updateInfoAndProvider.info, B = N.version, F = E.packageInfo;
      function U() {
        const C = decodeURIComponent(w.fileInfo.url.pathname);
        return C.endsWith(`.${w.fileExtension}`) ? o.basename(C) : w.fileInfo.info.url;
      }
      const G = await this.getOrCreateDownloadHelper(), M = G.cacheDirForPendingUpdate;
      await (0, i.mkdir)(M, { recursive: !0 });
      const V = U();
      let ie = o.join(M, V);
      const W = F == null ? null : o.join(M, `package-${B}${o.extname(F.path) || ".7z"}`), ae = async (C) => (await G.setDownloadedFile(ie, W, N, E, V, C), await w.done({
        ...N,
        downloadedFile: ie
      }), W == null ? [ie] : [ie, W]), se = this._logger, X = await G.validateDownloadedPath(ie, N, E, se);
      if (X != null)
        return ie = X, await ae(!1);
      const k = async () => (await G.clear().catch(() => {
      }), await (0, i.unlink)(ie).catch(() => {
      })), I = await (0, u.createTempUpdateFile)(`temp-${V}`, M, se);
      try {
        await w.task(I, R, W, k), await (0, e.retry)(() => (0, i.rename)(I, ie), 60, 500, 0, 0, (C) => C instanceof Error && /^EBUSY:/.test(C.message));
      } catch (C) {
        throw await k(), C instanceof e.CancellationError && (se.info("cancelled"), this.emit("update-cancelled", N)), C;
      }
      return se.info(`New version ${B} has been downloaded to ${ie}`), await ae(!0);
    }
    async differentialDownloadInstaller(w, E, R, N, B) {
      try {
        if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload)
          return !0;
        const F = (0, m.blockmapFiles)(w.url, this.app.version, E.updateInfoAndProvider.info.version);
        this._logger.info(`Download block maps (old: "${F[0]}", new: ${F[1]})`);
        const U = async (V) => {
          const ie = await this.httpExecutor.downloadToBuffer(V, {
            headers: E.requestHeaders,
            cancellationToken: E.cancellationToken
          });
          if (ie == null || ie.length === 0)
            throw new Error(`Blockmap "${V.href}" is empty`);
          try {
            return JSON.parse((0, v.gunzipSync)(ie).toString());
          } catch (W) {
            throw new Error(`Cannot parse blockmap "${V.href}", error: ${W}`);
          }
        }, G = {
          newUrl: w.url,
          oldFile: o.join(this.downloadedUpdateHelper.cacheDir, B),
          logger: this._logger,
          newFile: R,
          isUseMultipleRangeRequest: N.isUseMultipleRangeRequest,
          requestHeaders: E.requestHeaders,
          cancellationToken: E.cancellationToken
        };
        this.listenerCount(_.DOWNLOAD_PROGRESS) > 0 && (G.onProgress = (V) => this.emit(_.DOWNLOAD_PROGRESS, V));
        const M = await Promise.all(F.map((V) => U(V)));
        return await new h.GenericDifferentialDownloader(w.info, this.httpExecutor, G).download(M[0], M[1]), !1;
      } catch (F) {
        if (this._logger.error(`Cannot download differentially, fallback to full download: ${F.stack || F}`), this._testOnlyOptions != null)
          throw F;
        return !0;
      }
    }
  };
  ti.AppUpdater = g;
  function y(S) {
    const w = (0, c.prerelease)(S);
    return w != null && w.length > 0;
  }
  class x {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    info(w) {
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    warn(w) {
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    error(w) {
    }
  }
  return ti.NoOpLogger = x, ti;
}
var l1;
function ea() {
  if (l1) return fa;
  l1 = 1, Object.defineProperty(fa, "__esModule", { value: !0 }), fa.BaseUpdater = void 0;
  const e = Kc, t = $0();
  let r = class extends t.AppUpdater {
    constructor(i, a) {
      super(i, a), this.quitAndInstallCalled = !1, this.quitHandlerAdded = !1;
    }
    quitAndInstall(i = !1, a = !1) {
      this._logger.info("Install on explicit quitAndInstall"), this.install(i, i ? a : this.autoRunAppAfterInstall) ? setImmediate(() => {
        Tn.autoUpdater.emit("before-quit-for-update"), this.app.quit();
      }) : this.quitAndInstallCalled = !1;
    }
    executeDownload(i) {
      return super.executeDownload({
        ...i,
        done: (a) => (this.dispatchUpdateDownloaded(a), this.addQuitHandler(), Promise.resolve())
      });
    }
    get installerPath() {
      return this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.file;
    }
    // must be sync (because quit even handler is not async)
    install(i = !1, a = !1) {
      if (this.quitAndInstallCalled)
        return this._logger.warn("install call ignored: quitAndInstallCalled is set to true"), !1;
      const s = this.downloadedUpdateHelper, o = this.installerPath, c = s == null ? null : s.downloadedFileInfo;
      if (o == null || c == null)
        return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
      this.quitAndInstallCalled = !0;
      try {
        return this._logger.info(`Install: isSilent: ${i}, isForceRunAfter: ${a}`), this.doInstall({
          isSilent: i,
          isForceRunAfter: a,
          isAdminRightsRequired: c.isAdminRightsRequired
        });
      } catch (u) {
        return this.dispatchError(u), !1;
      }
    }
    addQuitHandler() {
      this.quitHandlerAdded || !this.autoInstallOnAppQuit || (this.quitHandlerAdded = !0, this.app.onQuit((i) => {
        if (this.quitAndInstallCalled) {
          this._logger.info("Update installer has already been triggered. Quitting application.");
          return;
        }
        if (!this.autoInstallOnAppQuit) {
          this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
          return;
        }
        if (i !== 0) {
          this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${i}`);
          return;
        }
        this._logger.info("Auto install update on quit"), this.install(!0, !1);
      }));
    }
    wrapSudo() {
      const { name: i } = this.app, a = `"${i} would like to update"`, s = this.spawnSyncLog("which gksudo || which kdesudo || which pkexec || which beesu"), o = [s];
      return /kdesudo/i.test(s) ? (o.push("--comment", a), o.push("-c")) : /gksudo/i.test(s) ? o.push("--message", a) : /pkexec/i.test(s) && o.push("--disable-internal-agent"), o.join(" ");
    }
    spawnSyncLog(i, a = [], s = {}) {
      this._logger.info(`Executing: ${i} with args: ${a}`);
      const o = (0, e.spawnSync)(i, a, {
        env: { ...process.env, ...s },
        encoding: "utf-8",
        shell: !0
      }), { error: c, status: u, stdout: l, stderr: d } = o;
      if (c != null)
        throw this._logger.error(d), c;
      if (u != null && u !== 0)
        throw this._logger.error(d), new Error(`Command ${i} exited with code ${u}`);
      return l.trim();
    }
    /**
     * This handles both node 8 and node 10 way of emitting error when spawning a process
     *   - node 8: Throws the error
     *   - node 10: Emit the error(Need to listen with on)
     */
    // https://github.com/electron-userland/electron-builder/issues/1129
    // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors
    async spawnLog(i, a = [], s = void 0, o = "ignore") {
      return this._logger.info(`Executing: ${i} with args: ${a}`), new Promise((c, u) => {
        try {
          const l = { stdio: o, env: s, detached: !0 }, d = (0, e.spawn)(i, a, l);
          d.on("error", (f) => {
            u(f);
          }), d.unref(), d.pid !== void 0 && c(!0);
        } catch (l) {
          u(l);
        }
      });
    }
  };
  return fa.BaseUpdater = r, fa;
}
var Ra = {}, $a = {}, u1;
function bE() {
  if (u1) return $a;
  u1 = 1, Object.defineProperty($a, "__esModule", { value: !0 }), $a.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
  const e = /* @__PURE__ */ zn(), t = CE(), r = eE;
  let n = class extends t.DifferentialDownloader {
    async download() {
      const o = this.blockAwareFileInfo, c = o.size, u = c - (o.blockMapSize + 4);
      this.fileMetadataBuffer = await this.readRemoteBytes(u, c - 1);
      const l = i(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
      await this.doDownload(await a(this.options.oldFile), l);
    }
  };
  $a.FileWithEmbeddedBlockMapDifferentialDownloader = n;
  function i(s) {
    return JSON.parse((0, r.inflateRawSync)(s).toString());
  }
  async function a(s) {
    const o = await (0, e.open)(s, "r");
    try {
      const c = (await (0, e.fstat)(o)).size, u = Buffer.allocUnsafe(4);
      await (0, e.read)(o, u, 0, u.length, c - u.length);
      const l = Buffer.allocUnsafe(u.readUInt32BE(0));
      return await (0, e.read)(o, l, 0, l.length, c - u.length - l.length), await (0, e.close)(o), i(l);
    } catch (c) {
      throw await (0, e.close)(o), c;
    }
  }
  return $a;
}
var f1;
function d1() {
  if (f1) return Ra;
  f1 = 1, Object.defineProperty(Ra, "__esModule", { value: !0 }), Ra.AppImageUpdater = void 0;
  const e = Jt(), t = Kc, r = /* @__PURE__ */ zn(), n = Kr, i = vt, a = ea(), s = bE(), o = Lr(), c = Ei();
  let u = class extends a.BaseUpdater {
    constructor(d, f) {
      super(d, f);
    }
    isUpdaterActive() {
      return process.env.APPIMAGE == null ? (process.env.SNAP == null ? this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage") : this._logger.info("SNAP env is defined, updater is disabled"), !1) : super.isUpdaterActive();
    }
    /*** @private */
    doDownloadUpdate(d) {
      const f = d.updateInfoAndProvider.provider, p = (0, o.findFile)(f.resolveFiles(d.updateInfoAndProvider.info), "AppImage", ["rpm", "deb", "pacman"]);
      return this.executeDownload({
        fileExtension: "AppImage",
        fileInfo: p,
        downloadUpdateOptions: d,
        task: async (v, m) => {
          const h = process.env.APPIMAGE;
          if (h == null)
            throw (0, e.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
          (d.disableDifferentialDownload || await this.downloadDifferential(p, h, v, f, d)) && await this.httpExecutor.download(p.url, v, m), await (0, r.chmod)(v, 493);
        }
      });
    }
    async downloadDifferential(d, f, p, v, m) {
      try {
        const h = {
          newUrl: d.url,
          oldFile: f,
          logger: this._logger,
          newFile: p,
          isUseMultipleRangeRequest: v.isUseMultipleRangeRequest,
          requestHeaders: m.requestHeaders,
          cancellationToken: m.cancellationToken
        };
        return this.listenerCount(c.DOWNLOAD_PROGRESS) > 0 && (h.onProgress = (_) => this.emit(c.DOWNLOAD_PROGRESS, _)), await new s.FileWithEmbeddedBlockMapDifferentialDownloader(d.info, this.httpExecutor, h).download(), !1;
      } catch (h) {
        return this._logger.error(`Cannot download differentially, fallback to full download: ${h.stack || h}`), process.platform === "linux";
      }
    }
    doInstall(d) {
      const f = process.env.APPIMAGE;
      if (f == null)
        throw (0, e.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
      (0, n.unlinkSync)(f);
      let p;
      const v = i.basename(f), m = this.installerPath;
      if (m == null)
        return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
      i.basename(m) === v || !/\d+\.\d+\.\d+/.test(v) ? p = f : p = i.join(i.dirname(f), i.basename(m)), (0, t.execFileSync)("mv", ["-f", m, p]), p !== f && this.emit("appimage-filename-updated", p);
      const h = {
        ...process.env,
        APPIMAGE_SILENT_INSTALL: "true"
      };
      return d.isForceRunAfter ? this.spawnLog(p, [], h) : (h.APPIMAGE_EXIT_AFTER_INSTALL = "true", (0, t.execFileSync)(p, [], { env: h })), !0;
    }
  };
  return Ra.AppImageUpdater = u, Ra;
}
var Oa = {}, h1;
function p1() {
  if (h1) return Oa;
  h1 = 1, Object.defineProperty(Oa, "__esModule", { value: !0 }), Oa.DebUpdater = void 0;
  const e = ea(), t = Lr(), r = Ei();
  let n = class extends e.BaseUpdater {
    constructor(a, s) {
      super(a, s);
    }
    /*** @private */
    doDownloadUpdate(a) {
      const s = a.updateInfoAndProvider.provider, o = (0, t.findFile)(s.resolveFiles(a.updateInfoAndProvider.info), "deb", ["AppImage", "rpm", "pacman"]);
      return this.executeDownload({
        fileExtension: "deb",
        fileInfo: o,
        downloadUpdateOptions: a,
        task: async (c, u) => {
          this.listenerCount(r.DOWNLOAD_PROGRESS) > 0 && (u.onProgress = (l) => this.emit(r.DOWNLOAD_PROGRESS, l)), await this.httpExecutor.download(o.url, c, u);
        }
      });
    }
    get installerPath() {
      var a, s;
      return (s = (a = super.installerPath) === null || a === void 0 ? void 0 : a.replace(/ /g, "\\ ")) !== null && s !== void 0 ? s : null;
    }
    doInstall(a) {
      const s = this.wrapSudo(), o = /pkexec/i.test(s) ? "" : '"', c = this.installerPath;
      if (c == null)
        return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
      const u = ["dpkg", "-i", c, "||", "apt-get", "install", "-f", "-y"];
      return this.spawnSyncLog(s, [`${o}/bin/bash`, "-c", `'${u.join(" ")}'${o}`]), a.isForceRunAfter && this.app.relaunch(), !0;
    }
  };
  return Oa.DebUpdater = n, Oa;
}
var Na = {}, m1;
function g1() {
  if (m1) return Na;
  m1 = 1, Object.defineProperty(Na, "__esModule", { value: !0 }), Na.PacmanUpdater = void 0;
  const e = ea(), t = Ei(), r = Lr();
  let n = class extends e.BaseUpdater {
    constructor(a, s) {
      super(a, s);
    }
    /*** @private */
    doDownloadUpdate(a) {
      const s = a.updateInfoAndProvider.provider, o = (0, r.findFile)(s.resolveFiles(a.updateInfoAndProvider.info), "pacman", ["AppImage", "deb", "rpm"]);
      return this.executeDownload({
        fileExtension: "pacman",
        fileInfo: o,
        downloadUpdateOptions: a,
        task: async (c, u) => {
          this.listenerCount(t.DOWNLOAD_PROGRESS) > 0 && (u.onProgress = (l) => this.emit(t.DOWNLOAD_PROGRESS, l)), await this.httpExecutor.download(o.url, c, u);
        }
      });
    }
    get installerPath() {
      var a, s;
      return (s = (a = super.installerPath) === null || a === void 0 ? void 0 : a.replace(/ /g, "\\ ")) !== null && s !== void 0 ? s : null;
    }
    doInstall(a) {
      const s = this.wrapSudo(), o = /pkexec/i.test(s) ? "" : '"', c = this.installerPath;
      if (c == null)
        return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
      const u = ["pacman", "-U", "--noconfirm", c];
      return this.spawnSyncLog(s, [`${o}/bin/bash`, "-c", `'${u.join(" ")}'${o}`]), a.isForceRunAfter && this.app.relaunch(), !0;
    }
  };
  return Na.PacmanUpdater = n, Na;
}
var Pa = {}, v1;
function _1() {
  if (v1) return Pa;
  v1 = 1, Object.defineProperty(Pa, "__esModule", { value: !0 }), Pa.RpmUpdater = void 0;
  const e = ea(), t = Ei(), r = Lr();
  let n = class extends e.BaseUpdater {
    constructor(a, s) {
      super(a, s);
    }
    /*** @private */
    doDownloadUpdate(a) {
      const s = a.updateInfoAndProvider.provider, o = (0, r.findFile)(s.resolveFiles(a.updateInfoAndProvider.info), "rpm", ["AppImage", "deb", "pacman"]);
      return this.executeDownload({
        fileExtension: "rpm",
        fileInfo: o,
        downloadUpdateOptions: a,
        task: async (c, u) => {
          this.listenerCount(t.DOWNLOAD_PROGRESS) > 0 && (u.onProgress = (l) => this.emit(t.DOWNLOAD_PROGRESS, l)), await this.httpExecutor.download(o.url, c, u);
        }
      });
    }
    get installerPath() {
      var a, s;
      return (s = (a = super.installerPath) === null || a === void 0 ? void 0 : a.replace(/ /g, "\\ ")) !== null && s !== void 0 ? s : null;
    }
    doInstall(a) {
      const s = this.wrapSudo(), o = /pkexec/i.test(s) ? "" : '"', c = this.spawnSyncLog("which zypper"), u = this.installerPath;
      if (u == null)
        return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
      let l;
      return c ? l = [c, "--no-refresh", "install", "--allow-unsigned-rpm", "-y", "-f", u] : l = [this.spawnSyncLog("which dnf || which yum"), "-y", "install", u], this.spawnSyncLog(s, [`${o}/bin/bash`, "-c", `'${l.join(" ")}'${o}`]), a.isForceRunAfter && this.app.relaunch(), !0;
    }
  };
  return Pa.RpmUpdater = n, Pa;
}
var Ca = {}, y1;
function E1() {
  if (y1) return Ca;
  y1 = 1, Object.defineProperty(Ca, "__esModule", { value: !0 }), Ca.MacUpdater = void 0;
  const e = Jt(), t = /* @__PURE__ */ zn(), r = Kr, n = vt, i = vT, a = $0(), s = Lr(), o = Kc, c = ts;
  let u = class extends a.AppUpdater {
    constructor(d, f) {
      super(d, f), this.nativeUpdater = Tn.autoUpdater, this.squirrelDownloadedUpdate = !1, this.nativeUpdater.on("error", (p) => {
        this._logger.warn(p), this.emit("error", p);
      }), this.nativeUpdater.on("update-downloaded", () => {
        this.squirrelDownloadedUpdate = !0, this.debug("nativeUpdater.update-downloaded");
      });
    }
    debug(d) {
      this._logger.debug != null && this._logger.debug(d);
    }
    closeServerIfExists() {
      this.server && (this.debug("Closing proxy server"), this.server.close((d) => {
        d && this.debug("proxy server wasn't already open, probably attempted closing again as a safety check before quit");
      }));
    }
    async doDownloadUpdate(d) {
      let f = d.updateInfoAndProvider.provider.resolveFiles(d.updateInfoAndProvider.info);
      const p = this._logger, v = "sysctl.proc_translated";
      let m = !1;
      try {
        this.debug("Checking for macOS Rosetta environment"), m = (0, o.execFileSync)("sysctl", [v], { encoding: "utf8" }).includes(`${v}: 1`), p.info(`Checked for macOS Rosetta environment (isRosetta=${m})`);
      } catch (S) {
        p.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${S}`);
      }
      let h = !1;
      try {
        this.debug("Checking for arm64 in uname");
        const w = (0, o.execFileSync)("uname", ["-a"], { encoding: "utf8" }).includes("ARM");
        p.info(`Checked 'uname -a': arm64=${w}`), h = h || w;
      } catch (S) {
        p.warn(`uname shell command to check for arm64 failed: ${S}`);
      }
      h = h || process.arch === "arm64" || m;
      const _ = (S) => {
        var w;
        return S.url.pathname.includes("arm64") || ((w = S.info.url) === null || w === void 0 ? void 0 : w.includes("arm64"));
      };
      h && f.some(_) ? f = f.filter((S) => h === _(S)) : f = f.filter((S) => !_(S));
      const g = (0, s.findFile)(f, "zip", ["pkg", "dmg"]);
      if (g == null)
        throw (0, e.newError)(`ZIP file not provided: ${(0, e.safeStringifyJson)(f)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
      const y = d.updateInfoAndProvider.provider, x = "update.zip";
      return this.executeDownload({
        fileExtension: "zip",
        fileInfo: g,
        downloadUpdateOptions: d,
        task: async (S, w) => {
          const E = n.join(this.downloadedUpdateHelper.cacheDir, x), R = () => (0, t.pathExistsSync)(E) ? !d.disableDifferentialDownload : (p.info("Unable to locate previous update.zip for differential download (is this first install?), falling back to full download"), !1);
          let N = !0;
          R() && (N = await this.differentialDownloadInstaller(g, d, S, y, x)), N && await this.httpExecutor.download(g.url, S, w);
        },
        done: async (S) => {
          if (!d.disableDifferentialDownload)
            try {
              const w = n.join(this.downloadedUpdateHelper.cacheDir, x);
              await (0, t.copyFile)(S.downloadedFile, w);
            } catch (w) {
              this._logger.warn(`Unable to copy file for caching for future differential downloads: ${w.message}`);
            }
          return this.updateDownloaded(g, S);
        }
      });
    }
    async updateDownloaded(d, f) {
      var p;
      const v = f.downloadedFile, m = (p = d.info.size) !== null && p !== void 0 ? p : (await (0, t.stat)(v)).size, h = this._logger, _ = `fileToProxy=${d.url.href}`;
      this.closeServerIfExists(), this.debug(`Creating proxy server for native Squirrel.Mac (${_})`), this.server = (0, i.createServer)(), this.debug(`Proxy server for native Squirrel.Mac is created (${_})`), this.server.on("close", () => {
        h.info(`Proxy server for native Squirrel.Mac is closed (${_})`);
      });
      const g = (y) => {
        const x = y.address();
        return typeof x == "string" ? x : `http://127.0.0.1:${x?.port}`;
      };
      return await new Promise((y, x) => {
        const S = (0, c.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-"), w = Buffer.from(`autoupdater:${S}`, "ascii"), E = `/${(0, c.randomBytes)(64).toString("hex")}.zip`;
        this.server.on("request", (R, N) => {
          const B = R.url;
          if (h.info(`${B} requested`), B === "/") {
            if (!R.headers.authorization || R.headers.authorization.indexOf("Basic ") === -1) {
              N.statusCode = 401, N.statusMessage = "Invalid Authentication Credentials", N.end(), h.warn("No authenthication info");
              return;
            }
            const G = R.headers.authorization.split(" ")[1], M = Buffer.from(G, "base64").toString("ascii"), [V, ie] = M.split(":");
            if (V !== "autoupdater" || ie !== S) {
              N.statusCode = 401, N.statusMessage = "Invalid Authentication Credentials", N.end(), h.warn("Invalid authenthication credentials");
              return;
            }
            const W = Buffer.from(`{ "url": "${g(this.server)}${E}" }`);
            N.writeHead(200, { "Content-Type": "application/json", "Content-Length": W.length }), N.end(W);
            return;
          }
          if (!B.startsWith(E)) {
            h.warn(`${B} requested, but not supported`), N.writeHead(404), N.end();
            return;
          }
          h.info(`${E} requested by Squirrel.Mac, pipe ${v}`);
          let F = !1;
          N.on("finish", () => {
            F || (this.nativeUpdater.removeListener("error", x), y([]));
          });
          const U = (0, r.createReadStream)(v);
          U.on("error", (G) => {
            try {
              N.end();
            } catch (M) {
              h.warn(`cannot end response: ${M}`);
            }
            F = !0, this.nativeUpdater.removeListener("error", x), x(new Error(`Cannot pipe "${v}": ${G}`));
          }), N.writeHead(200, {
            "Content-Type": "application/zip",
            "Content-Length": m
          }), U.pipe(N);
        }), this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${_})`), this.server.listen(0, "127.0.0.1", () => {
          this.debug(`Proxy server for native Squirrel.Mac is listening (address=${g(this.server)}, ${_})`), this.nativeUpdater.setFeedURL({
            url: g(this.server),
            headers: {
              "Cache-Control": "no-cache",
              Authorization: `Basic ${w.toString("base64")}`
            }
          }), this.dispatchUpdateDownloaded(f), this.autoInstallOnAppQuit ? (this.nativeUpdater.once("error", x), this.nativeUpdater.checkForUpdates()) : y([]);
        });
      });
    }
    handleUpdateDownloaded() {
      this.autoRunAppAfterInstall ? this.nativeUpdater.quitAndInstall() : this.app.quit(), this.closeServerIfExists();
    }
    quitAndInstall() {
      this.squirrelDownloadedUpdate ? this.handleUpdateDownloaded() : (this.nativeUpdater.on("update-downloaded", () => this.handleUpdateDownloaded()), this.autoInstallOnAppQuit || this.nativeUpdater.checkForUpdates());
    }
  };
  return Ca.MacUpdater = u, Ca;
}
var Ia = {}, Ps = {}, w1;
function jS() {
  if (w1) return Ps;
  w1 = 1, Object.defineProperty(Ps, "__esModule", { value: !0 }), Ps.verifySignature = i;
  const e = Jt(), t = Kc, r = Yc, n = vt;
  function i(c, u, l) {
    return new Promise((d, f) => {
      const p = u.replace(/'/g, "''");
      l.info(`Verifying signature ${p}`), (0, t.execFile)('set "PSModulePath=" & chcp 65001 >NUL & powershell.exe', ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${p}' | ConvertTo-Json -Compress"`], {
        shell: !0,
        timeout: 20 * 1e3
      }, (v, m, h) => {
        var _;
        try {
          if (v != null || h) {
            s(l, v, h, f), d(null);
            return;
          }
          const g = a(m);
          if (g.Status === 0) {
            try {
              const w = n.normalize(g.Path), E = n.normalize(u);
              if (l.info(`LiteralPath: ${w}. Update Path: ${E}`), w !== E) {
                s(l, new Error(`LiteralPath of ${w} is different than ${E}`), h, f), d(null);
                return;
              }
            } catch (w) {
              l.warn(`Unable to verify LiteralPath of update asset due to missing data.Path. Skipping this step of validation. Message: ${(_ = w.message) !== null && _ !== void 0 ? _ : w.stack}`);
            }
            const x = (0, e.parseDn)(g.SignerCertificate.Subject);
            let S = !1;
            for (const w of c) {
              const E = (0, e.parseDn)(w);
              if (E.size ? S = Array.from(E.keys()).every((N) => E.get(N) === x.get(N)) : w === x.get("CN") && (l.warn(`Signature validated using only CN ${w}. Please add your full Distinguished Name (DN) to publisherNames configuration`), S = !0), S) {
                d(null);
                return;
              }
            }
          }
          const y = `publisherNames: ${c.join(" | ")}, raw info: ` + JSON.stringify(g, (x, S) => x === "RawData" ? void 0 : S, 2);
          l.warn(`Sign verification failed, installer signed with incorrect certificate: ${y}`), d(y);
        } catch (g) {
          s(l, g, null, f), d(null);
          return;
        }
      });
    });
  }
  function a(c) {
    const u = JSON.parse(c);
    delete u.PrivateKey, delete u.IsOSBinary, delete u.SignatureType;
    const l = u.SignerCertificate;
    return l != null && (delete l.Archived, delete l.Extensions, delete l.Handle, delete l.HasPrivateKey, delete l.SubjectName), u;
  }
  function s(c, u, l, d) {
    if (o()) {
      c.warn(`Cannot execute Get-AuthenticodeSignature: ${u || l}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
      return;
    }
    try {
      (0, t.execFileSync)("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
    } catch (f) {
      c.warn(`Cannot execute ConvertTo-Json: ${f.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
      return;
    }
    u != null && d(u), l && d(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${l}. Failing signature validation due to unknown stderr.`));
  }
  function o() {
    const c = r.release();
    return c.startsWith("6.") && !c.startsWith("6.3");
  }
  return Ps;
}
var x1;
function T1() {
  if (x1) return Ia;
  x1 = 1, Object.defineProperty(Ia, "__esModule", { value: !0 }), Ia.NsisUpdater = void 0;
  const e = Jt(), t = vt, r = ea(), n = bE(), i = Ei(), a = Lr(), s = /* @__PURE__ */ zn(), o = jS(), c = Yi;
  let u = class extends r.BaseUpdater {
    constructor(d, f) {
      super(d, f), this._verifyUpdateCodeSignature = (p, v) => (0, o.verifySignature)(p, v, this._logger);
    }
    /**
     * The verifyUpdateCodeSignature. You can pass [win-verify-signature](https://github.com/beyondkmp/win-verify-trust) or another custom verify function: ` (publisherName: string[], path: string) => Promise<string | null>`.
     * The default verify function uses [windowsExecutableCodeSignatureVerifier](https://github.com/electron-userland/electron-builder/blob/master/packages/electron-updater/src/windowsExecutableCodeSignatureVerifier.ts)
     */
    get verifyUpdateCodeSignature() {
      return this._verifyUpdateCodeSignature;
    }
    set verifyUpdateCodeSignature(d) {
      d && (this._verifyUpdateCodeSignature = d);
    }
    /*** @private */
    doDownloadUpdate(d) {
      const f = d.updateInfoAndProvider.provider, p = (0, a.findFile)(f.resolveFiles(d.updateInfoAndProvider.info), "exe");
      return this.executeDownload({
        fileExtension: "exe",
        downloadUpdateOptions: d,
        fileInfo: p,
        task: async (v, m, h, _) => {
          const g = p.packageInfo, y = g != null && h != null;
          if (y && d.disableWebInstaller)
            throw (0, e.newError)(`Unable to download new version ${d.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
          !y && !d.disableWebInstaller && this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version."), (y || d.disableDifferentialDownload || await this.differentialDownloadInstaller(p, d, v, f, e.CURRENT_APP_INSTALLER_FILE_NAME)) && await this.httpExecutor.download(p.url, v, m);
          const x = await this.verifySignature(v);
          if (x != null)
            throw await _(), (0, e.newError)(`New version ${d.updateInfoAndProvider.info.version} is not signed by the application owner: ${x}`, "ERR_UPDATER_INVALID_SIGNATURE");
          if (y && await this.differentialDownloadWebPackage(d, g, h, f))
            try {
              await this.httpExecutor.download(new c.URL(g.path), h, {
                headers: d.requestHeaders,
                cancellationToken: d.cancellationToken,
                sha512: g.sha512
              });
            } catch (S) {
              try {
                await (0, s.unlink)(h);
              } catch {
              }
              throw S;
            }
        }
      });
    }
    // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
    // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
    // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
    async verifySignature(d) {
      let f;
      try {
        if (f = (await this.configOnDisk.value).publisherName, f == null)
          return null;
      } catch (p) {
        if (p.code === "ENOENT")
          return null;
        throw p;
      }
      return await this._verifyUpdateCodeSignature(Array.isArray(f) ? f : [f], d);
    }
    doInstall(d) {
      const f = this.installerPath;
      if (f == null)
        return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
      const p = ["--updated"];
      d.isSilent && p.push("/S"), d.isForceRunAfter && p.push("--force-run"), this.installDirectory && p.push(`/D=${this.installDirectory}`);
      const v = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
      v != null && p.push(`--package-file=${v}`);
      const m = () => {
        this.spawnLog(t.join(process.resourcesPath, "elevate.exe"), [f].concat(p)).catch((h) => this.dispatchError(h));
      };
      return d.isAdminRightsRequired ? (this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe"), m(), !0) : (this.spawnLog(f, p).catch((h) => {
        const _ = h.code;
        this._logger.info(`Cannot run installer: error code: ${_}, error message: "${h.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`), _ === "UNKNOWN" || _ === "EACCES" ? m() : _ === "ENOENT" ? Tn.shell.openPath(f).catch((g) => this.dispatchError(g)) : this.dispatchError(h);
      }), !0);
    }
    async differentialDownloadWebPackage(d, f, p, v) {
      if (f.blockMapSize == null)
        return !0;
      try {
        const m = {
          newUrl: new c.URL(f.path),
          oldFile: t.join(this.downloadedUpdateHelper.cacheDir, e.CURRENT_APP_PACKAGE_FILE_NAME),
          logger: this._logger,
          newFile: p,
          requestHeaders: this.requestHeaders,
          isUseMultipleRangeRequest: v.isUseMultipleRangeRequest,
          cancellationToken: d.cancellationToken
        };
        this.listenerCount(i.DOWNLOAD_PROGRESS) > 0 && (m.onProgress = (h) => this.emit(i.DOWNLOAD_PROGRESS, h)), await new n.FileWithEmbeddedBlockMapDifferentialDownloader(f, this.httpExecutor, m).download();
      } catch (m) {
        return this._logger.error(`Cannot download differentially, fallback to full download: ${m.stack || m}`), process.platform === "win32";
      }
      return !1;
    }
  };
  return Ia.NsisUpdater = u, Ia;
}
var S1;
function VS() {
  return S1 || (S1 = 1, (function(e) {
    var t = ei && ei.__createBinding || (Object.create ? (function(h, _, g, y) {
      y === void 0 && (y = g);
      var x = Object.getOwnPropertyDescriptor(_, g);
      (!x || ("get" in x ? !_.__esModule : x.writable || x.configurable)) && (x = { enumerable: !0, get: function() {
        return _[g];
      } }), Object.defineProperty(h, y, x);
    }) : (function(h, _, g, y) {
      y === void 0 && (y = g), h[y] = _[g];
    })), r = ei && ei.__exportStar || function(h, _) {
      for (var g in h) g !== "default" && !Object.prototype.hasOwnProperty.call(_, g) && t(_, h, g);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NsisUpdater = e.MacUpdater = e.RpmUpdater = e.PacmanUpdater = e.DebUpdater = e.AppImageUpdater = e.Provider = e.NoOpLogger = e.AppUpdater = e.BaseUpdater = void 0;
    const n = /* @__PURE__ */ zn(), i = vt;
    var a = ea();
    Object.defineProperty(e, "BaseUpdater", { enumerable: !0, get: function() {
      return a.BaseUpdater;
    } });
    var s = $0();
    Object.defineProperty(e, "AppUpdater", { enumerable: !0, get: function() {
      return s.AppUpdater;
    } }), Object.defineProperty(e, "NoOpLogger", { enumerable: !0, get: function() {
      return s.NoOpLogger;
    } });
    var o = Lr();
    Object.defineProperty(e, "Provider", { enumerable: !0, get: function() {
      return o.Provider;
    } });
    var c = d1();
    Object.defineProperty(e, "AppImageUpdater", { enumerable: !0, get: function() {
      return c.AppImageUpdater;
    } });
    var u = p1();
    Object.defineProperty(e, "DebUpdater", { enumerable: !0, get: function() {
      return u.DebUpdater;
    } });
    var l = g1();
    Object.defineProperty(e, "PacmanUpdater", { enumerable: !0, get: function() {
      return l.PacmanUpdater;
    } });
    var d = _1();
    Object.defineProperty(e, "RpmUpdater", { enumerable: !0, get: function() {
      return d.RpmUpdater;
    } });
    var f = E1();
    Object.defineProperty(e, "MacUpdater", { enumerable: !0, get: function() {
      return f.MacUpdater;
    } });
    var p = T1();
    Object.defineProperty(e, "NsisUpdater", { enumerable: !0, get: function() {
      return p.NsisUpdater;
    } }), r(Ei(), e);
    let v;
    function m() {
      if (process.platform === "win32")
        v = new (T1()).NsisUpdater();
      else if (process.platform === "darwin")
        v = new (E1()).MacUpdater();
      else {
        v = new (d1()).AppImageUpdater();
        try {
          const h = i.join(process.resourcesPath, "package-type");
          if (!(0, n.existsSync)(h))
            return v;
          console.info("Checking for beta autoupdate feature for deb/rpm distributions");
          const _ = (0, n.readFileSync)(h).toString().trim();
          switch (console.info("Found package-type:", _), _) {
            case "deb":
              v = new (p1()).DebUpdater();
              break;
            case "rpm":
              v = new (_1()).RpmUpdater();
              break;
            case "pacman":
              v = new (g1()).PacmanUpdater();
              break;
            default:
              break;
          }
        } catch (h) {
          console.warn("Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder", h.message);
        }
      }
      return v;
    }
    Object.defineProperty(e, "autoUpdater", {
      enumerable: !0,
      get: () => v || m()
    });
  })(ei)), ei;
}
var kr = VS();
const pi = (e) => {
  const t = typeof e;
  return e !== null && (t === "object" || t === "function");
}, FE = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]), DE = 1e6, HS = (e) => e >= "0" && e <= "9";
function kE(e) {
  if (e === "0")
    return !0;
  if (/^[1-9]\d*$/.test(e)) {
    const t = Number.parseInt(e, 10);
    return t <= Number.MAX_SAFE_INTEGER && t <= DE;
  }
  return !1;
}
function If(e, t) {
  return FE.has(e) ? !1 : (e && kE(e) ? t.push(Number.parseInt(e, 10)) : t.push(e), !0);
}
function GS(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a string, got ${typeof e}`);
  const t = [];
  let r = "", n = "start", i = !1, a = 0;
  for (const s of e) {
    if (a++, i) {
      r += s, i = !1;
      continue;
    }
    if (s === "\\") {
      if (n === "index")
        throw new Error(`Invalid character '${s}' in an index at position ${a}`);
      if (n === "indexEnd")
        throw new Error(`Invalid character '${s}' after an index at position ${a}`);
      i = !0, n = n === "start" ? "property" : n;
      continue;
    }
    switch (s) {
      case ".": {
        if (n === "index")
          throw new Error(`Invalid character '${s}' in an index at position ${a}`);
        if (n === "indexEnd") {
          n = "property";
          break;
        }
        if (!If(r, t))
          return [];
        r = "", n = "property";
        break;
      }
      case "[": {
        if (n === "index")
          throw new Error(`Invalid character '${s}' in an index at position ${a}`);
        if (n === "indexEnd") {
          n = "index";
          break;
        }
        if (n === "property" || n === "start") {
          if ((r || n === "property") && !If(r, t))
            return [];
          r = "";
        }
        n = "index";
        break;
      }
      case "]": {
        if (n === "index") {
          if (r === "")
            r = (t.pop() || "") + "[]", n = "property";
          else {
            const o = Number.parseInt(r, 10);
            !Number.isNaN(o) && Number.isFinite(o) && o >= 0 && o <= Number.MAX_SAFE_INTEGER && o <= DE && r === String(o) ? t.push(o) : t.push(r), r = "", n = "indexEnd";
          }
          break;
        }
        if (n === "indexEnd")
          throw new Error(`Invalid character '${s}' after an index at position ${a}`);
        r += s;
        break;
      }
      default: {
        if (n === "index" && !HS(s))
          throw new Error(`Invalid character '${s}' in an index at position ${a}`);
        if (n === "indexEnd")
          throw new Error(`Invalid character '${s}' after an index at position ${a}`);
        n === "start" && (n = "property"), r += s;
      }
    }
  }
  switch (i && (r += "\\"), n) {
    case "property": {
      if (!If(r, t))
        return [];
      break;
    }
    case "index":
      throw new Error("Index was not closed");
    case "start": {
      t.push("");
      break;
    }
  }
  return t;
}
function il(e) {
  if (typeof e == "string")
    return GS(e);
  if (Array.isArray(e)) {
    const t = [];
    for (const [r, n] of e.entries()) {
      if (typeof n != "string" && typeof n != "number")
        throw new TypeError(`Expected a string or number for path segment at index ${r}, got ${typeof n}`);
      if (typeof n == "number" && !Number.isFinite(n))
        throw new TypeError(`Path segment at index ${r} must be a finite number, got ${n}`);
      if (FE.has(n))
        return [];
      typeof n == "string" && kE(n) ? t.push(Number.parseInt(n, 10)) : t.push(n);
    }
    return t;
  }
  return [];
}
function A1(e, t, r) {
  if (!pi(e) || typeof t != "string" && !Array.isArray(t))
    return r === void 0 ? e : r;
  const n = il(t);
  if (n.length === 0)
    return r;
  for (let i = 0; i < n.length; i++) {
    const a = n[i];
    if (e = e[a], e == null) {
      if (i !== n.length - 1)
        return r;
      break;
    }
  }
  return e === void 0 ? r : e;
}
function Cs(e, t, r) {
  if (!pi(e) || typeof t != "string" && !Array.isArray(t))
    return e;
  const n = e, i = il(t);
  if (i.length === 0)
    return e;
  for (let a = 0; a < i.length; a++) {
    const s = i[a];
    if (a === i.length - 1)
      e[s] = r;
    else if (!pi(e[s])) {
      const c = typeof i[a + 1] == "number";
      e[s] = c ? [] : {};
    }
    e = e[s];
  }
  return n;
}
function zS(e, t) {
  if (!pi(e) || typeof t != "string" && !Array.isArray(t))
    return !1;
  const r = il(t);
  if (r.length === 0)
    return !1;
  for (let n = 0; n < r.length; n++) {
    const i = r[n];
    if (n === r.length - 1)
      return Object.hasOwn(e, i) ? (delete e[i], !0) : !1;
    if (e = e[i], !pi(e))
      return !1;
  }
}
function bf(e, t) {
  if (!pi(e) || typeof t != "string" && !Array.isArray(t))
    return !1;
  const r = il(t);
  if (r.length === 0)
    return !1;
  for (const n of r) {
    if (!pi(e) || !(n in e))
      return !1;
    e = e[n];
  }
  return !0;
}
const qn = tE.homedir(), O0 = tE.tmpdir(), { env: ji } = $t, WS = (e) => {
  const t = ut.join(qn, "Library");
  return {
    data: ut.join(t, "Application Support", e),
    config: ut.join(t, "Preferences", e),
    cache: ut.join(t, "Caches", e),
    log: ut.join(t, "Logs", e),
    temp: ut.join(O0, e)
  };
}, XS = (e) => {
  const t = ji.APPDATA || ut.join(qn, "AppData", "Roaming"), r = ji.LOCALAPPDATA || ut.join(qn, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: ut.join(r, e, "Data"),
    config: ut.join(t, e, "Config"),
    cache: ut.join(r, e, "Cache"),
    log: ut.join(r, e, "Log"),
    temp: ut.join(O0, e)
  };
}, KS = (e) => {
  const t = ut.basename(qn);
  return {
    data: ut.join(ji.XDG_DATA_HOME || ut.join(qn, ".local", "share"), e),
    config: ut.join(ji.XDG_CONFIG_HOME || ut.join(qn, ".config"), e),
    cache: ut.join(ji.XDG_CACHE_HOME || ut.join(qn, ".cache"), e),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: ut.join(ji.XDG_STATE_HOME || ut.join(qn, ".local", "state"), e),
    temp: ut.join(O0, t, e)
  };
};
function YS(e, { suffix: t = "nodejs" } = {}) {
  if (typeof e != "string")
    throw new TypeError(`Expected a string, got ${typeof e}`);
  return t && (e += `-${t}`), $t.platform === "darwin" ? WS(e) : $t.platform === "win32" ? XS(e) : KS(e);
}
const In = (e, t) => {
  const { onError: r } = t;
  return function(...i) {
    return e.apply(void 0, i).catch(r);
  };
}, hn = (e, t) => {
  const { onError: r } = t;
  return function(...i) {
    try {
      return e.apply(void 0, i);
    } catch (a) {
      return r(a);
    }
  };
}, JS = 250, bn = (e, t) => {
  const { isRetriable: r } = t;
  return function(i) {
    const { timeout: a } = i, s = i.interval ?? JS, o = Date.now() + a;
    return function c(...u) {
      return e.apply(void 0, u).catch((l) => {
        if (!r(l) || Date.now() >= o)
          throw l;
        const d = Math.round(s * Math.random());
        return d > 0 ? new Promise((p) => setTimeout(p, d)).then(() => c.apply(void 0, u)) : c.apply(void 0, u);
      });
    };
  };
}, Fn = (e, t) => {
  const { isRetriable: r } = t;
  return function(i) {
    const { timeout: a } = i, s = Date.now() + a;
    return function(...c) {
      for (; ; )
        try {
          return e.apply(void 0, c);
        } catch (u) {
          if (!r(u) || Date.now() >= s)
            throw u;
          continue;
        }
    };
  };
}, Vi = {
  /* API */
  isChangeErrorOk: (e) => {
    if (!Vi.isNodeError(e))
      return !1;
    const { code: t } = e;
    return t === "ENOSYS" || !QS && (t === "EINVAL" || t === "EPERM");
  },
  isNodeError: (e) => e instanceof Error,
  isRetriableError: (e) => {
    if (!Vi.isNodeError(e))
      return !1;
    const { code: t } = e;
    return t === "EMFILE" || t === "ENFILE" || t === "EAGAIN" || t === "EBUSY" || t === "EACCESS" || t === "EACCES" || t === "EACCS" || t === "EPERM";
  },
  onChangeError: (e) => {
    if (!Vi.isNodeError(e))
      throw e;
    if (!Vi.isChangeErrorOk(e))
      throw e;
  }
}, Is = {
  onError: Vi.onChangeError
}, Tr = {
  onError: () => {
  }
}, QS = $t.getuid ? !$t.getuid() : !1, rr = {
  isRetriable: Vi.isRetriableError
}, nr = {
  attempt: {
    /* ASYNC */
    chmod: In(Zt(Je.chmod), Is),
    chown: In(Zt(Je.chown), Is),
    close: In(Zt(Je.close), Tr),
    fsync: In(Zt(Je.fsync), Tr),
    mkdir: In(Zt(Je.mkdir), Tr),
    realpath: In(Zt(Je.realpath), Tr),
    stat: In(Zt(Je.stat), Tr),
    unlink: In(Zt(Je.unlink), Tr),
    /* SYNC */
    chmodSync: hn(Je.chmodSync, Is),
    chownSync: hn(Je.chownSync, Is),
    closeSync: hn(Je.closeSync, Tr),
    existsSync: hn(Je.existsSync, Tr),
    fsyncSync: hn(Je.fsync, Tr),
    mkdirSync: hn(Je.mkdirSync, Tr),
    realpathSync: hn(Je.realpathSync, Tr),
    statSync: hn(Je.statSync, Tr),
    unlinkSync: hn(Je.unlinkSync, Tr)
  },
  retry: {
    /* ASYNC */
    close: bn(Zt(Je.close), rr),
    fsync: bn(Zt(Je.fsync), rr),
    open: bn(Zt(Je.open), rr),
    readFile: bn(Zt(Je.readFile), rr),
    rename: bn(Zt(Je.rename), rr),
    stat: bn(Zt(Je.stat), rr),
    write: bn(Zt(Je.write), rr),
    writeFile: bn(Zt(Je.writeFile), rr),
    /* SYNC */
    closeSync: Fn(Je.closeSync, rr),
    fsyncSync: Fn(Je.fsyncSync, rr),
    openSync: Fn(Je.openSync, rr),
    readFileSync: Fn(Je.readFileSync, rr),
    renameSync: Fn(Je.renameSync, rr),
    statSync: Fn(Je.statSync, rr),
    writeSync: Fn(Je.writeSync, rr),
    writeFileSync: Fn(Je.writeFileSync, rr)
  }
}, ZS = "utf8", R1 = 438, e2 = 511, t2 = {}, r2 = $t.geteuid ? $t.geteuid() : -1, n2 = $t.getegid ? $t.getegid() : -1, i2 = 1e3, a2 = !!$t.getuid;
$t.getuid && $t.getuid();
const $1 = 128, s2 = (e) => e instanceof Error && "code" in e, O1 = (e) => typeof e == "string", Ff = (e) => e === void 0, o2 = $t.platform === "linux", LE = $t.platform === "win32", N0 = ["SIGHUP", "SIGINT", "SIGTERM"];
LE || N0.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
o2 && N0.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
class c2 {
  /* CONSTRUCTOR */
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set(), this.exited = !1, this.exit = (t) => {
      if (!this.exited) {
        this.exited = !0;
        for (const r of this.callbacks)
          r();
        t && (LE && t !== "SIGINT" && t !== "SIGTERM" && t !== "SIGKILL" ? $t.kill($t.pid, "SIGTERM") : $t.kill($t.pid, t));
      }
    }, this.hook = () => {
      $t.once("exit", () => this.exit());
      for (const t of N0)
        try {
          $t.once(t, () => this.exit(t));
        } catch {
        }
    }, this.register = (t) => (this.callbacks.add(t), () => {
      this.callbacks.delete(t);
    }), this.hook();
  }
}
const l2 = new c2(), u2 = l2.register, ir = {
  /* VARIABLES */
  store: {},
  // filePath => purge
  /* API */
  create: (e) => {
    const t = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), i = `.tmp-${Date.now().toString().slice(-10)}${t}`;
    return `${e}${i}`;
  },
  get: (e, t, r = !0) => {
    const n = ir.truncate(t(e));
    return n in ir.store ? ir.get(e, t, r) : (ir.store[n] = r, [n, () => delete ir.store[n]]);
  },
  purge: (e) => {
    ir.store[e] && (delete ir.store[e], nr.attempt.unlink(e));
  },
  purgeSync: (e) => {
    ir.store[e] && (delete ir.store[e], nr.attempt.unlinkSync(e));
  },
  purgeSyncAll: () => {
    for (const e in ir.store)
      ir.purgeSync(e);
  },
  truncate: (e) => {
    const t = ut.basename(e);
    if (t.length <= $1)
      return e;
    const r = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(t);
    if (!r)
      return e;
    const n = t.length - $1;
    return `${e.slice(0, -t.length)}${r[1]}${r[2].slice(0, -n)}${r[3]}`;
  }
};
u2(ir.purgeSyncAll);
function ME(e, t, r = t2) {
  if (O1(r))
    return ME(e, t, { encoding: r });
  const i = { timeout: r.timeout ?? i2 };
  let a = null, s = null, o = null;
  try {
    const c = nr.attempt.realpathSync(e), u = !!c;
    e = c || e, [s, a] = ir.get(e, r.tmpCreate || ir.create, r.tmpPurge !== !1);
    const l = a2 && Ff(r.chown), d = Ff(r.mode);
    if (u && (l || d)) {
      const f = nr.attempt.statSync(e);
      f && (r = { ...r }, l && (r.chown = { uid: f.uid, gid: f.gid }), d && (r.mode = f.mode));
    }
    if (!u) {
      const f = ut.dirname(e);
      nr.attempt.mkdirSync(f, {
        mode: e2,
        recursive: !0
      });
    }
    o = nr.retry.openSync(i)(s, "w", r.mode || R1), r.tmpCreated && r.tmpCreated(s), O1(t) ? nr.retry.writeSync(i)(o, t, 0, r.encoding || ZS) : Ff(t) || nr.retry.writeSync(i)(o, t, 0, t.length, 0), r.fsync !== !1 && (r.fsyncWait !== !1 ? nr.retry.fsyncSync(i)(o) : nr.attempt.fsync(o)), nr.retry.closeSync(i)(o), o = null, r.chown && (r.chown.uid !== r2 || r.chown.gid !== n2) && nr.attempt.chownSync(s, r.chown.uid, r.chown.gid), r.mode && r.mode !== R1 && nr.attempt.chmodSync(s, r.mode);
    try {
      nr.retry.renameSync(i)(s, e);
    } catch (f) {
      if (!s2(f) || f.code !== "ENAMETOOLONG")
        throw f;
      nr.retry.renameSync(i)(s, ir.truncate(e));
    }
    a(), s = null;
  } finally {
    o && nr.attempt.closeSync(o), s && ir.purge(s);
  }
}
var bs = { exports: {} }, Df = {}, pn = {}, ai = {}, kf = {}, Lf = {}, Mf = {}, N1;
function Nc() {
  return N1 || (N1 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
    class t {
    }
    e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class r extends t {
      constructor(g) {
        if (super(), !e.IDENTIFIER.test(g))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = g;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    e.Name = r;
    class n extends t {
      constructor(g) {
        super(), this._items = typeof g == "string" ? [g] : g;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const g = this._items[0];
        return g === "" || g === '""';
      }
      get str() {
        var g;
        return (g = this._str) !== null && g !== void 0 ? g : this._str = this._items.reduce((y, x) => `${y}${x}`, "");
      }
      get names() {
        var g;
        return (g = this._names) !== null && g !== void 0 ? g : this._names = this._items.reduce((y, x) => (x instanceof r && (y[x.str] = (y[x.str] || 0) + 1), y), {});
      }
    }
    e._Code = n, e.nil = new n("");
    function i(_, ...g) {
      const y = [_[0]];
      let x = 0;
      for (; x < g.length; )
        o(y, g[x]), y.push(_[++x]);
      return new n(y);
    }
    e._ = i;
    const a = new n("+");
    function s(_, ...g) {
      const y = [p(_[0])];
      let x = 0;
      for (; x < g.length; )
        y.push(a), o(y, g[x]), y.push(a, p(_[++x]));
      return c(y), new n(y);
    }
    e.str = s;
    function o(_, g) {
      g instanceof n ? _.push(...g._items) : g instanceof r ? _.push(g) : _.push(d(g));
    }
    e.addCodeArg = o;
    function c(_) {
      let g = 1;
      for (; g < _.length - 1; ) {
        if (_[g] === a) {
          const y = u(_[g - 1], _[g + 1]);
          if (y !== void 0) {
            _.splice(g - 1, 3, y);
            continue;
          }
          _[g++] = "+";
        }
        g++;
      }
    }
    function u(_, g) {
      if (g === '""')
        return _;
      if (_ === '""')
        return g;
      if (typeof _ == "string")
        return g instanceof r || _[_.length - 1] !== '"' ? void 0 : typeof g != "string" ? `${_.slice(0, -1)}${g}"` : g[0] === '"' ? _.slice(0, -1) + g.slice(1) : void 0;
      if (typeof g == "string" && g[0] === '"' && !(_ instanceof r))
        return `"${_}${g.slice(1)}`;
    }
    function l(_, g) {
      return g.emptyStr() ? _ : _.emptyStr() ? g : s`${_}${g}`;
    }
    e.strConcat = l;
    function d(_) {
      return typeof _ == "number" || typeof _ == "boolean" || _ === null ? _ : p(Array.isArray(_) ? _.join(",") : _);
    }
    function f(_) {
      return new n(p(_));
    }
    e.stringify = f;
    function p(_) {
      return JSON.stringify(_).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    e.safeStringify = p;
    function v(_) {
      return typeof _ == "string" && e.IDENTIFIER.test(_) ? new n(`.${_}`) : i`[${_}]`;
    }
    e.getProperty = v;
    function m(_) {
      if (typeof _ == "string" && e.IDENTIFIER.test(_))
        return new n(`${_}`);
      throw new Error(`CodeGen: invalid export name: ${_}, use explicit $id name mapping`);
    }
    e.getEsmExportName = m;
    function h(_) {
      return new n(_.toString());
    }
    e.regexpCode = h;
  })(Mf)), Mf;
}
var Uf = {}, P1;
function C1() {
  return P1 || (P1 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
    const t = Nc();
    class r extends Error {
      constructor(u) {
        super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
      }
    }
    var n;
    (function(c) {
      c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
    })(n || (e.UsedValueState = n = {})), e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var")
    };
    class i {
      constructor({ prefixes: u, parent: l } = {}) {
        this._names = {}, this._prefixes = u, this._parent = l;
      }
      toName(u) {
        return u instanceof t.Name ? u : this.name(u);
      }
      name(u) {
        return new t.Name(this._newName(u));
      }
      _newName(u) {
        const l = this._names[u] || this._nameGroup(u);
        return `${u}${l.index++}`;
      }
      _nameGroup(u) {
        var l, d;
        if (!((d = (l = this._parent) === null || l === void 0 ? void 0 : l._prefixes) === null || d === void 0) && d.has(u) || this._prefixes && !this._prefixes.has(u))
          throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
        return this._names[u] = { prefix: u, index: 0 };
      }
    }
    e.Scope = i;
    class a extends t.Name {
      constructor(u, l) {
        super(l), this.prefix = u;
      }
      setValue(u, { property: l, itemIndex: d }) {
        this.value = u, this.scopePath = (0, t._)`.${new t.Name(l)}[${d}]`;
      }
    }
    e.ValueScopeName = a;
    const s = (0, t._)`\n`;
    class o extends i {
      constructor(u) {
        super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? s : t.nil };
      }
      get() {
        return this._scope;
      }
      name(u) {
        return new a(u, this._newName(u));
      }
      value(u, l) {
        var d;
        if (l.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const f = this.toName(u), { prefix: p } = f, v = (d = l.key) !== null && d !== void 0 ? d : l.ref;
        let m = this._values[p];
        if (m) {
          const g = m.get(v);
          if (g)
            return g;
        } else
          m = this._values[p] = /* @__PURE__ */ new Map();
        m.set(v, f);
        const h = this._scope[p] || (this._scope[p] = []), _ = h.length;
        return h[_] = l.ref, f.setValue(l, { property: p, itemIndex: _ }), f;
      }
      getValue(u, l) {
        const d = this._values[u];
        if (d)
          return d.get(l);
      }
      scopeRefs(u, l = this._values) {
        return this._reduceValues(l, (d) => {
          if (d.scopePath === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return (0, t._)`${u}${d.scopePath}`;
        });
      }
      scopeCode(u = this._values, l, d) {
        return this._reduceValues(u, (f) => {
          if (f.value === void 0)
            throw new Error(`CodeGen: name "${f}" has no value`);
          return f.value.code;
        }, l, d);
      }
      _reduceValues(u, l, d = {}, f) {
        let p = t.nil;
        for (const v in u) {
          const m = u[v];
          if (!m)
            continue;
          const h = d[v] = d[v] || /* @__PURE__ */ new Map();
          m.forEach((_) => {
            if (h.has(_))
              return;
            h.set(_, n.Started);
            let g = l(_);
            if (g) {
              const y = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
              p = (0, t._)`${p}${y} ${_} = ${g};${this.opts._n}`;
            } else if (g = f?.(_))
              p = (0, t._)`${p}${g}${this.opts._n}`;
            else
              throw new r(_);
            h.set(_, n.Completed);
          });
        }
        return p;
      }
    }
    e.ValueScope = o;
  })(Uf)), Uf;
}
var I1;
function Ze() {
  return I1 || (I1 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
    const t = Nc(), r = C1();
    var n = Nc();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
      return n.strConcat;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
      return n.getProperty;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
      return n.regexpCode;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } });
    var i = C1();
    Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
      return i.Scope;
    } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
      return i.ValueScope;
    } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
      return i.ValueScopeName;
    } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
      return i.varKinds;
    } }), e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+")
    };
    class a {
      optimizeNodes() {
        return this;
      }
      optimizeNames(T, A) {
        return this;
      }
    }
    class s extends a {
      constructor(T, A, L) {
        super(), this.varKind = T, this.name = A, this.rhs = L;
      }
      render({ es5: T, _n: A }) {
        const L = T ? r.varKinds.var : this.varKind, b = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${L} ${this.name}${b};` + A;
      }
      optimizeNames(T, A) {
        if (T[this.name.str])
          return this.rhs && (this.rhs = M(this.rhs, T, A)), this;
      }
      get names() {
        return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
      }
    }
    class o extends a {
      constructor(T, A, L) {
        super(), this.lhs = T, this.rhs = A, this.sideEffects = L;
      }
      render({ _n: T }) {
        return `${this.lhs} = ${this.rhs};` + T;
      }
      optimizeNames(T, A) {
        if (!(this.lhs instanceof t.Name && !T[this.lhs.str] && !this.sideEffects))
          return this.rhs = M(this.rhs, T, A), this;
      }
      get names() {
        const T = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
        return G(T, this.rhs);
      }
    }
    class c extends o {
      constructor(T, A, L, b) {
        super(T, L, b), this.op = A;
      }
      render({ _n: T }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + T;
      }
    }
    class u extends a {
      constructor(T) {
        super(), this.label = T, this.names = {};
      }
      render({ _n: T }) {
        return `${this.label}:` + T;
      }
    }
    class l extends a {
      constructor(T) {
        super(), this.label = T, this.names = {};
      }
      render({ _n: T }) {
        return `break${this.label ? ` ${this.label}` : ""};` + T;
      }
    }
    class d extends a {
      constructor(T) {
        super(), this.error = T;
      }
      render({ _n: T }) {
        return `throw ${this.error};` + T;
      }
      get names() {
        return this.error.names;
      }
    }
    class f extends a {
      constructor(T) {
        super(), this.code = T;
      }
      render({ _n: T }) {
        return `${this.code};` + T;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(T, A) {
        return this.code = M(this.code, T, A), this;
      }
      get names() {
        return this.code instanceof t._CodeOrName ? this.code.names : {};
      }
    }
    class p extends a {
      constructor(T = []) {
        super(), this.nodes = T;
      }
      render(T) {
        return this.nodes.reduce((A, L) => A + L.render(T), "");
      }
      optimizeNodes() {
        const { nodes: T } = this;
        let A = T.length;
        for (; A--; ) {
          const L = T[A].optimizeNodes();
          Array.isArray(L) ? T.splice(A, 1, ...L) : L ? T[A] = L : T.splice(A, 1);
        }
        return T.length > 0 ? this : void 0;
      }
      optimizeNames(T, A) {
        const { nodes: L } = this;
        let b = L.length;
        for (; b--; ) {
          const P = L[b];
          P.optimizeNames(T, A) || (V(T, P.names), L.splice(b, 1));
        }
        return L.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((T, A) => U(T, A.names), {});
      }
    }
    class v extends p {
      render(T) {
        return "{" + T._n + super.render(T) + "}" + T._n;
      }
    }
    class m extends p {
    }
    class h extends v {
    }
    h.kind = "else";
    class _ extends v {
      constructor(T, A) {
        super(A), this.condition = T;
      }
      render(T) {
        let A = `if(${this.condition})` + super.render(T);
        return this.else && (A += "else " + this.else.render(T)), A;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const T = this.condition;
        if (T === !0)
          return this.nodes;
        let A = this.else;
        if (A) {
          const L = A.optimizeNodes();
          A = this.else = Array.isArray(L) ? new h(L) : L;
        }
        if (A)
          return T === !1 ? A instanceof _ ? A : A.nodes : this.nodes.length ? this : new _(ie(T), A instanceof _ ? [A] : A.nodes);
        if (!(T === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(T, A) {
        var L;
        if (this.else = (L = this.else) === null || L === void 0 ? void 0 : L.optimizeNames(T, A), !!(super.optimizeNames(T, A) || this.else))
          return this.condition = M(this.condition, T, A), this;
      }
      get names() {
        const T = super.names;
        return G(T, this.condition), this.else && U(T, this.else.names), T;
      }
    }
    _.kind = "if";
    class g extends v {
    }
    g.kind = "for";
    class y extends g {
      constructor(T) {
        super(), this.iteration = T;
      }
      render(T) {
        return `for(${this.iteration})` + super.render(T);
      }
      optimizeNames(T, A) {
        if (super.optimizeNames(T, A))
          return this.iteration = M(this.iteration, T, A), this;
      }
      get names() {
        return U(super.names, this.iteration.names);
      }
    }
    class x extends g {
      constructor(T, A, L, b) {
        super(), this.varKind = T, this.name = A, this.from = L, this.to = b;
      }
      render(T) {
        const A = T.es5 ? r.varKinds.var : this.varKind, { name: L, from: b, to: P } = this;
        return `for(${A} ${L}=${b}; ${L}<${P}; ${L}++)` + super.render(T);
      }
      get names() {
        const T = G(super.names, this.from);
        return G(T, this.to);
      }
    }
    class S extends g {
      constructor(T, A, L, b) {
        super(), this.loop = T, this.varKind = A, this.name = L, this.iterable = b;
      }
      render(T) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(T);
      }
      optimizeNames(T, A) {
        if (super.optimizeNames(T, A))
          return this.iterable = M(this.iterable, T, A), this;
      }
      get names() {
        return U(super.names, this.iterable.names);
      }
    }
    class w extends v {
      constructor(T, A, L) {
        super(), this.name = T, this.args = A, this.async = L;
      }
      render(T) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(T);
      }
    }
    w.kind = "func";
    class E extends p {
      render(T) {
        return "return " + super.render(T);
      }
    }
    E.kind = "return";
    class R extends v {
      render(T) {
        let A = "try" + super.render(T);
        return this.catch && (A += this.catch.render(T)), this.finally && (A += this.finally.render(T)), A;
      }
      optimizeNodes() {
        var T, A;
        return super.optimizeNodes(), (T = this.catch) === null || T === void 0 || T.optimizeNodes(), (A = this.finally) === null || A === void 0 || A.optimizeNodes(), this;
      }
      optimizeNames(T, A) {
        var L, b;
        return super.optimizeNames(T, A), (L = this.catch) === null || L === void 0 || L.optimizeNames(T, A), (b = this.finally) === null || b === void 0 || b.optimizeNames(T, A), this;
      }
      get names() {
        const T = super.names;
        return this.catch && U(T, this.catch.names), this.finally && U(T, this.finally.names), T;
      }
    }
    class N extends v {
      constructor(T) {
        super(), this.error = T;
      }
      render(T) {
        return `catch(${this.error})` + super.render(T);
      }
    }
    N.kind = "catch";
    class B extends v {
      render(T) {
        return "finally" + super.render(T);
      }
    }
    B.kind = "finally";
    class F {
      constructor(T, A = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...A, _n: A.lines ? `
` : "" }, this._extScope = T, this._scope = new r.Scope({ parent: T }), this._nodes = [new m()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(T) {
        return this._scope.name(T);
      }
      // reserves unique name in the external scope
      scopeName(T) {
        return this._extScope.name(T);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(T, A) {
        const L = this._extScope.value(T, A);
        return (this._values[L.prefix] || (this._values[L.prefix] = /* @__PURE__ */ new Set())).add(L), L;
      }
      getScopeValue(T, A) {
        return this._extScope.getValue(T, A);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(T) {
        return this._extScope.scopeRefs(T, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(T, A, L, b) {
        const P = this._scope.toName(A);
        return L !== void 0 && b && (this._constants[P.str] = L), this._leafNode(new s(T, P, L)), P;
      }
      // `const` declaration (`var` in es5 mode)
      const(T, A, L) {
        return this._def(r.varKinds.const, T, A, L);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(T, A, L) {
        return this._def(r.varKinds.let, T, A, L);
      }
      // `var` declaration with optional assignment
      var(T, A, L) {
        return this._def(r.varKinds.var, T, A, L);
      }
      // assignment code
      assign(T, A, L) {
        return this._leafNode(new o(T, A, L));
      }
      // `+=` code
      add(T, A) {
        return this._leafNode(new c(T, e.operators.ADD, A));
      }
      // appends passed SafeExpr to code or executes Block
      code(T) {
        return typeof T == "function" ? T() : T !== t.nil && this._leafNode(new f(T)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...T) {
        const A = ["{"];
        for (const [L, b] of T)
          A.length > 1 && A.push(","), A.push(L), (L !== b || this.opts.es5) && (A.push(":"), (0, t.addCodeArg)(A, b));
        return A.push("}"), new t._Code(A);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(T, A, L) {
        if (this._blockNode(new _(T)), A && L)
          this.code(A).else().code(L).endIf();
        else if (A)
          this.code(A).endIf();
        else if (L)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(T) {
        return this._elseNode(new _(T));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new h());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(_, h);
      }
      _for(T, A) {
        return this._blockNode(T), A && this.code(A).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(T, A) {
        return this._for(new y(T), A);
      }
      // `for` statement for a range of values
      forRange(T, A, L, b, P = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
        const te = this._scope.toName(T);
        return this._for(new x(P, te, A, L), () => b(te));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(T, A, L, b = r.varKinds.const) {
        const P = this._scope.toName(T);
        if (this.opts.es5) {
          const te = A instanceof t.Name ? A : this.var("_arr", A);
          return this.forRange("_i", 0, (0, t._)`${te}.length`, (H) => {
            this.var(P, (0, t._)`${te}[${H}]`), L(P);
          });
        }
        return this._for(new S("of", b, P, A), () => L(P));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(T, A, L, b = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(T, (0, t._)`Object.keys(${A})`, L);
        const P = this._scope.toName(T);
        return this._for(new S("in", b, P, A), () => L(P));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(g);
      }
      // `label` statement
      label(T) {
        return this._leafNode(new u(T));
      }
      // `break` statement
      break(T) {
        return this._leafNode(new l(T));
      }
      // `return` statement
      return(T) {
        const A = new E();
        if (this._blockNode(A), this.code(T), A.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(E);
      }
      // `try` statement
      try(T, A, L) {
        if (!A && !L)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const b = new R();
        if (this._blockNode(b), this.code(T), A) {
          const P = this.name("e");
          this._currNode = b.catch = new N(P), A(P);
        }
        return L && (this._currNode = b.finally = new B(), this.code(L)), this._endBlockNode(N, B);
      }
      // `throw` statement
      throw(T) {
        return this._leafNode(new d(T));
      }
      // start self-balancing block
      block(T, A) {
        return this._blockStarts.push(this._nodes.length), T && this.code(T).endBlock(A), this;
      }
      // end the current self-balancing block
      endBlock(T) {
        const A = this._blockStarts.pop();
        if (A === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const L = this._nodes.length - A;
        if (L < 0 || T !== void 0 && L !== T)
          throw new Error(`CodeGen: wrong number of nodes: ${L} vs ${T} expected`);
        return this._nodes.length = A, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(T, A = t.nil, L, b) {
        return this._blockNode(new w(T, A, L)), b && this.code(b).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(w);
      }
      optimize(T = 1) {
        for (; T-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(T) {
        return this._currNode.nodes.push(T), this;
      }
      _blockNode(T) {
        this._currNode.nodes.push(T), this._nodes.push(T);
      }
      _endBlockNode(T, A) {
        const L = this._currNode;
        if (L instanceof T || A && L instanceof A)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${A ? `${T.kind}/${A.kind}` : T.kind}"`);
      }
      _elseNode(T) {
        const A = this._currNode;
        if (!(A instanceof _))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = A.else = T, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const T = this._nodes;
        return T[T.length - 1];
      }
      set _currNode(T) {
        const A = this._nodes;
        A[A.length - 1] = T;
      }
    }
    e.CodeGen = F;
    function U(C, T) {
      for (const A in T)
        C[A] = (C[A] || 0) + (T[A] || 0);
      return C;
    }
    function G(C, T) {
      return T instanceof t._CodeOrName ? U(C, T.names) : C;
    }
    function M(C, T, A) {
      if (C instanceof t.Name)
        return L(C);
      if (!b(C))
        return C;
      return new t._Code(C._items.reduce((P, te) => (te instanceof t.Name && (te = L(te)), te instanceof t._Code ? P.push(...te._items) : P.push(te), P), []));
      function L(P) {
        const te = A[P.str];
        return te === void 0 || T[P.str] !== 1 ? P : (delete T[P.str], te);
      }
      function b(P) {
        return P instanceof t._Code && P._items.some((te) => te instanceof t.Name && T[te.str] === 1 && A[te.str] !== void 0);
      }
    }
    function V(C, T) {
      for (const A in T)
        C[A] = (C[A] || 0) - (T[A] || 0);
    }
    function ie(C) {
      return typeof C == "boolean" || typeof C == "number" || C === null ? !C : (0, t._)`!${I(C)}`;
    }
    e.not = ie;
    const W = k(e.operators.AND);
    function ae(...C) {
      return C.reduce(W);
    }
    e.and = ae;
    const se = k(e.operators.OR);
    function X(...C) {
      return C.reduce(se);
    }
    e.or = X;
    function k(C) {
      return (T, A) => T === t.nil ? A : A === t.nil ? T : (0, t._)`${I(T)} ${C} ${I(A)}`;
    }
    function I(C) {
      return C instanceof t.Name ? C : (0, t._)`(${C})`;
    }
  })(Lf)), Lf;
}
var tt = {}, b1;
function st() {
  if (b1) return tt;
  b1 = 1, Object.defineProperty(tt, "__esModule", { value: !0 }), tt.checkStrictMode = tt.getErrorPath = tt.Type = tt.useFunc = tt.setEvaluated = tt.evaluatedPropsToName = tt.mergeEvaluated = tt.eachItem = tt.unescapeJsonPointer = tt.escapeJsonPointer = tt.escapeFragment = tt.unescapeFragment = tt.schemaRefOrVal = tt.schemaHasRulesButRef = tt.schemaHasRules = tt.checkUnknownRules = tt.alwaysValidSchema = tt.toHash = void 0;
  const e = Ze(), t = Nc();
  function r(S) {
    const w = {};
    for (const E of S)
      w[E] = !0;
    return w;
  }
  tt.toHash = r;
  function n(S, w) {
    return typeof w == "boolean" ? w : Object.keys(w).length === 0 ? !0 : (i(S, w), !a(w, S.self.RULES.all));
  }
  tt.alwaysValidSchema = n;
  function i(S, w = S.schema) {
    const { opts: E, self: R } = S;
    if (!E.strictSchema || typeof w == "boolean")
      return;
    const N = R.RULES.keywords;
    for (const B in w)
      N[B] || x(S, `unknown keyword: "${B}"`);
  }
  tt.checkUnknownRules = i;
  function a(S, w) {
    if (typeof S == "boolean")
      return !S;
    for (const E in S)
      if (w[E])
        return !0;
    return !1;
  }
  tt.schemaHasRules = a;
  function s(S, w) {
    if (typeof S == "boolean")
      return !S;
    for (const E in S)
      if (E !== "$ref" && w.all[E])
        return !0;
    return !1;
  }
  tt.schemaHasRulesButRef = s;
  function o({ topSchemaRef: S, schemaPath: w }, E, R, N) {
    if (!N) {
      if (typeof E == "number" || typeof E == "boolean")
        return E;
      if (typeof E == "string")
        return (0, e._)`${E}`;
    }
    return (0, e._)`${S}${w}${(0, e.getProperty)(R)}`;
  }
  tt.schemaRefOrVal = o;
  function c(S) {
    return d(decodeURIComponent(S));
  }
  tt.unescapeFragment = c;
  function u(S) {
    return encodeURIComponent(l(S));
  }
  tt.escapeFragment = u;
  function l(S) {
    return typeof S == "number" ? `${S}` : S.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  tt.escapeJsonPointer = l;
  function d(S) {
    return S.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  tt.unescapeJsonPointer = d;
  function f(S, w) {
    if (Array.isArray(S))
      for (const E of S)
        w(E);
    else
      w(S);
  }
  tt.eachItem = f;
  function p({ mergeNames: S, mergeToName: w, mergeValues: E, resultToName: R }) {
    return (N, B, F, U) => {
      const G = F === void 0 ? B : F instanceof e.Name ? (B instanceof e.Name ? S(N, B, F) : w(N, B, F), F) : B instanceof e.Name ? (w(N, F, B), B) : E(B, F);
      return U === e.Name && !(G instanceof e.Name) ? R(N, G) : G;
    };
  }
  tt.mergeEvaluated = {
    props: p({
      mergeNames: (S, w, E) => S.if((0, e._)`${E} !== true && ${w} !== undefined`, () => {
        S.if((0, e._)`${w} === true`, () => S.assign(E, !0), () => S.assign(E, (0, e._)`${E} || {}`).code((0, e._)`Object.assign(${E}, ${w})`));
      }),
      mergeToName: (S, w, E) => S.if((0, e._)`${E} !== true`, () => {
        w === !0 ? S.assign(E, !0) : (S.assign(E, (0, e._)`${E} || {}`), m(S, E, w));
      }),
      mergeValues: (S, w) => S === !0 ? !0 : { ...S, ...w },
      resultToName: v
    }),
    items: p({
      mergeNames: (S, w, E) => S.if((0, e._)`${E} !== true && ${w} !== undefined`, () => S.assign(E, (0, e._)`${w} === true ? true : ${E} > ${w} ? ${E} : ${w}`)),
      mergeToName: (S, w, E) => S.if((0, e._)`${E} !== true`, () => S.assign(E, w === !0 ? !0 : (0, e._)`${E} > ${w} ? ${E} : ${w}`)),
      mergeValues: (S, w) => S === !0 ? !0 : Math.max(S, w),
      resultToName: (S, w) => S.var("items", w)
    })
  };
  function v(S, w) {
    if (w === !0)
      return S.var("props", !0);
    const E = S.var("props", (0, e._)`{}`);
    return w !== void 0 && m(S, E, w), E;
  }
  tt.evaluatedPropsToName = v;
  function m(S, w, E) {
    Object.keys(E).forEach((R) => S.assign((0, e._)`${w}${(0, e.getProperty)(R)}`, !0));
  }
  tt.setEvaluated = m;
  const h = {};
  function _(S, w) {
    return S.scopeValue("func", {
      ref: w,
      code: h[w.code] || (h[w.code] = new t._Code(w.code))
    });
  }
  tt.useFunc = _;
  var g;
  (function(S) {
    S[S.Num = 0] = "Num", S[S.Str = 1] = "Str";
  })(g || (tt.Type = g = {}));
  function y(S, w, E) {
    if (S instanceof e.Name) {
      const R = w === g.Num;
      return E ? R ? (0, e._)`"[" + ${S} + "]"` : (0, e._)`"['" + ${S} + "']"` : R ? (0, e._)`"/" + ${S}` : (0, e._)`"/" + ${S}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return E ? (0, e.getProperty)(S).toString() : "/" + l(S);
  }
  tt.getErrorPath = y;
  function x(S, w, E = S.opts.strictSchema) {
    if (E) {
      if (w = `strict mode: ${w}`, E === !0)
        throw new Error(w);
      S.self.logger.warn(w);
    }
  }
  return tt.checkStrictMode = x, tt;
}
var Fs = {}, F1;
function Qr() {
  if (F1) return Fs;
  F1 = 1, Object.defineProperty(Fs, "__esModule", { value: !0 });
  const e = Ze(), t = {
    // validation function arguments
    data: new e.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new e.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new e.Name("instancePath"),
    parentData: new e.Name("parentData"),
    parentDataProperty: new e.Name("parentDataProperty"),
    rootData: new e.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new e.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new e.Name("vErrors"),
    // null or array of validation errors
    errors: new e.Name("errors"),
    // counter of validation errors
    this: new e.Name("this"),
    // "globals"
    self: new e.Name("self"),
    scope: new e.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new e.Name("json"),
    jsonPos: new e.Name("jsonPos"),
    jsonLen: new e.Name("jsonLen"),
    jsonPart: new e.Name("jsonPart")
  };
  return Fs.default = t, Fs;
}
var D1;
function al() {
  return D1 || (D1 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
    const t = Ze(), r = st(), n = Qr();
    e.keywordError = {
      message: ({ keyword: h }) => (0, t.str)`must pass "${h}" keyword validation`
    }, e.keyword$DataError = {
      message: ({ keyword: h, schemaType: _ }) => _ ? (0, t.str)`"${h}" keyword must be ${_} ($data)` : (0, t.str)`"${h}" keyword is invalid ($data)`
    };
    function i(h, _ = e.keywordError, g, y) {
      const { it: x } = h, { gen: S, compositeRule: w, allErrors: E } = x, R = d(h, _, g);
      y ?? (w || E) ? c(S, R) : u(x, (0, t._)`[${R}]`);
    }
    e.reportError = i;
    function a(h, _ = e.keywordError, g) {
      const { it: y } = h, { gen: x, compositeRule: S, allErrors: w } = y, E = d(h, _, g);
      c(x, E), S || w || u(y, n.default.vErrors);
    }
    e.reportExtraError = a;
    function s(h, _) {
      h.assign(n.default.errors, _), h.if((0, t._)`${n.default.vErrors} !== null`, () => h.if(_, () => h.assign((0, t._)`${n.default.vErrors}.length`, _), () => h.assign(n.default.vErrors, null)));
    }
    e.resetErrorsCount = s;
    function o({ gen: h, keyword: _, schemaValue: g, data: y, errsCount: x, it: S }) {
      if (x === void 0)
        throw new Error("ajv implementation error");
      const w = h.name("err");
      h.forRange("i", x, n.default.errors, (E) => {
        h.const(w, (0, t._)`${n.default.vErrors}[${E}]`), h.if((0, t._)`${w}.instancePath === undefined`, () => h.assign((0, t._)`${w}.instancePath`, (0, t.strConcat)(n.default.instancePath, S.errorPath))), h.assign((0, t._)`${w}.schemaPath`, (0, t.str)`${S.errSchemaPath}/${_}`), S.opts.verbose && (h.assign((0, t._)`${w}.schema`, g), h.assign((0, t._)`${w}.data`, y));
      });
    }
    e.extendErrors = o;
    function c(h, _) {
      const g = h.const("err", _);
      h.if((0, t._)`${n.default.vErrors} === null`, () => h.assign(n.default.vErrors, (0, t._)`[${g}]`), (0, t._)`${n.default.vErrors}.push(${g})`), h.code((0, t._)`${n.default.errors}++`);
    }
    function u(h, _) {
      const { gen: g, validateName: y, schemaEnv: x } = h;
      x.$async ? g.throw((0, t._)`new ${h.ValidationError}(${_})`) : (g.assign((0, t._)`${y}.errors`, _), g.return(!1));
    }
    const l = {
      keyword: new t.Name("keyword"),
      schemaPath: new t.Name("schemaPath"),
      // also used in JTD errors
      params: new t.Name("params"),
      propertyName: new t.Name("propertyName"),
      message: new t.Name("message"),
      schema: new t.Name("schema"),
      parentSchema: new t.Name("parentSchema")
    };
    function d(h, _, g) {
      const { createErrors: y } = h.it;
      return y === !1 ? (0, t._)`{}` : f(h, _, g);
    }
    function f(h, _, g = {}) {
      const { gen: y, it: x } = h, S = [
        p(x, g),
        v(h, g)
      ];
      return m(h, _, S), y.object(...S);
    }
    function p({ errorPath: h }, { instancePath: _ }) {
      const g = _ ? (0, t.str)`${h}${(0, r.getErrorPath)(_, r.Type.Str)}` : h;
      return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, g)];
    }
    function v({ keyword: h, it: { errSchemaPath: _ } }, { schemaPath: g, parentSchema: y }) {
      let x = y ? _ : (0, t.str)`${_}/${h}`;
      return g && (x = (0, t.str)`${x}${(0, r.getErrorPath)(g, r.Type.Str)}`), [l.schemaPath, x];
    }
    function m(h, { params: _, message: g }, y) {
      const { keyword: x, data: S, schemaValue: w, it: E } = h, { opts: R, propertyName: N, topSchemaRef: B, schemaPath: F } = E;
      y.push([l.keyword, x], [l.params, typeof _ == "function" ? _(h) : _ || (0, t._)`{}`]), R.messages && y.push([l.message, typeof g == "function" ? g(h) : g]), R.verbose && y.push([l.schema, w], [l.parentSchema, (0, t._)`${B}${F}`], [n.default.data, S]), N && y.push([l.propertyName, N]);
    }
  })(kf)), kf;
}
var k1;
function f2() {
  if (k1) return ai;
  k1 = 1, Object.defineProperty(ai, "__esModule", { value: !0 }), ai.boolOrEmptySchema = ai.topBoolOrEmptySchema = void 0;
  const e = al(), t = Ze(), r = Qr(), n = {
    message: "boolean schema is false"
  };
  function i(o) {
    const { gen: c, schema: u, validateName: l } = o;
    u === !1 ? s(o, !1) : typeof u == "object" && u.$async === !0 ? c.return(r.default.data) : (c.assign((0, t._)`${l}.errors`, null), c.return(!0));
  }
  ai.topBoolOrEmptySchema = i;
  function a(o, c) {
    const { gen: u, schema: l } = o;
    l === !1 ? (u.var(c, !1), s(o)) : u.var(c, !0);
  }
  ai.boolOrEmptySchema = a;
  function s(o, c) {
    const { gen: u, data: l } = o, d = {
      gen: u,
      keyword: "false schema",
      data: l,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: o
    };
    (0, e.reportError)(d, n, void 0, c);
  }
  return ai;
}
var Vt = {}, si = {}, L1;
function UE() {
  if (L1) return si;
  L1 = 1, Object.defineProperty(si, "__esModule", { value: !0 }), si.getRules = si.isJSONType = void 0;
  const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
  function r(i) {
    return typeof i == "string" && t.has(i);
  }
  si.isJSONType = r;
  function n() {
    const i = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...i, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, i.number, i.string, i.array, i.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return si.getRules = n, si;
}
var mn = {}, M1;
function qE() {
  if (M1) return mn;
  M1 = 1, Object.defineProperty(mn, "__esModule", { value: !0 }), mn.shouldUseRule = mn.shouldUseGroup = mn.schemaHasRulesForType = void 0;
  function e({ schema: n, self: i }, a) {
    const s = i.RULES.types[a];
    return s && s !== !0 && t(n, s);
  }
  mn.schemaHasRulesForType = e;
  function t(n, i) {
    return i.rules.some((a) => r(n, a));
  }
  mn.shouldUseGroup = t;
  function r(n, i) {
    var a;
    return n[i.keyword] !== void 0 || ((a = i.definition.implements) === null || a === void 0 ? void 0 : a.some((s) => n[s] !== void 0));
  }
  return mn.shouldUseRule = r, mn;
}
var U1;
function Pc() {
  if (U1) return Vt;
  U1 = 1, Object.defineProperty(Vt, "__esModule", { value: !0 }), Vt.reportTypeError = Vt.checkDataTypes = Vt.checkDataType = Vt.coerceAndCheckDataType = Vt.getJSONTypes = Vt.getSchemaTypes = Vt.DataType = void 0;
  const e = UE(), t = qE(), r = al(), n = Ze(), i = st();
  var a;
  (function(g) {
    g[g.Correct = 0] = "Correct", g[g.Wrong = 1] = "Wrong";
  })(a || (Vt.DataType = a = {}));
  function s(g) {
    const y = o(g.type);
    if (y.includes("null")) {
      if (g.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!y.length && g.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      g.nullable === !0 && y.push("null");
    }
    return y;
  }
  Vt.getSchemaTypes = s;
  function o(g) {
    const y = Array.isArray(g) ? g : g ? [g] : [];
    if (y.every(e.isJSONType))
      return y;
    throw new Error("type must be JSONType or JSONType[]: " + y.join(","));
  }
  Vt.getJSONTypes = o;
  function c(g, y) {
    const { gen: x, data: S, opts: w } = g, E = l(y, w.coerceTypes), R = y.length > 0 && !(E.length === 0 && y.length === 1 && (0, t.schemaHasRulesForType)(g, y[0]));
    if (R) {
      const N = v(y, S, w.strictNumbers, a.Wrong);
      x.if(N, () => {
        E.length ? d(g, y, E) : h(g);
      });
    }
    return R;
  }
  Vt.coerceAndCheckDataType = c;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function l(g, y) {
    return y ? g.filter((x) => u.has(x) || y === "array" && x === "array") : [];
  }
  function d(g, y, x) {
    const { gen: S, data: w, opts: E } = g, R = S.let("dataType", (0, n._)`typeof ${w}`), N = S.let("coerced", (0, n._)`undefined`);
    E.coerceTypes === "array" && S.if((0, n._)`${R} == 'object' && Array.isArray(${w}) && ${w}.length == 1`, () => S.assign(w, (0, n._)`${w}[0]`).assign(R, (0, n._)`typeof ${w}`).if(v(y, w, E.strictNumbers), () => S.assign(N, w))), S.if((0, n._)`${N} !== undefined`);
    for (const F of x)
      (u.has(F) || F === "array" && E.coerceTypes === "array") && B(F);
    S.else(), h(g), S.endIf(), S.if((0, n._)`${N} !== undefined`, () => {
      S.assign(w, N), f(g, N);
    });
    function B(F) {
      switch (F) {
        case "string":
          S.elseIf((0, n._)`${R} == "number" || ${R} == "boolean"`).assign(N, (0, n._)`"" + ${w}`).elseIf((0, n._)`${w} === null`).assign(N, (0, n._)`""`);
          return;
        case "number":
          S.elseIf((0, n._)`${R} == "boolean" || ${w} === null
              || (${R} == "string" && ${w} && ${w} == +${w})`).assign(N, (0, n._)`+${w}`);
          return;
        case "integer":
          S.elseIf((0, n._)`${R} === "boolean" || ${w} === null
              || (${R} === "string" && ${w} && ${w} == +${w} && !(${w} % 1))`).assign(N, (0, n._)`+${w}`);
          return;
        case "boolean":
          S.elseIf((0, n._)`${w} === "false" || ${w} === 0 || ${w} === null`).assign(N, !1).elseIf((0, n._)`${w} === "true" || ${w} === 1`).assign(N, !0);
          return;
        case "null":
          S.elseIf((0, n._)`${w} === "" || ${w} === 0 || ${w} === false`), S.assign(N, null);
          return;
        case "array":
          S.elseIf((0, n._)`${R} === "string" || ${R} === "number"
              || ${R} === "boolean" || ${w} === null`).assign(N, (0, n._)`[${w}]`);
      }
    }
  }
  function f({ gen: g, parentData: y, parentDataProperty: x }, S) {
    g.if((0, n._)`${y} !== undefined`, () => g.assign((0, n._)`${y}[${x}]`, S));
  }
  function p(g, y, x, S = a.Correct) {
    const w = S === a.Correct ? n.operators.EQ : n.operators.NEQ;
    let E;
    switch (g) {
      case "null":
        return (0, n._)`${y} ${w} null`;
      case "array":
        E = (0, n._)`Array.isArray(${y})`;
        break;
      case "object":
        E = (0, n._)`${y} && typeof ${y} == "object" && !Array.isArray(${y})`;
        break;
      case "integer":
        E = R((0, n._)`!(${y} % 1) && !isNaN(${y})`);
        break;
      case "number":
        E = R();
        break;
      default:
        return (0, n._)`typeof ${y} ${w} ${g}`;
    }
    return S === a.Correct ? E : (0, n.not)(E);
    function R(N = n.nil) {
      return (0, n.and)((0, n._)`typeof ${y} == "number"`, N, x ? (0, n._)`isFinite(${y})` : n.nil);
    }
  }
  Vt.checkDataType = p;
  function v(g, y, x, S) {
    if (g.length === 1)
      return p(g[0], y, x, S);
    let w;
    const E = (0, i.toHash)(g);
    if (E.array && E.object) {
      const R = (0, n._)`typeof ${y} != "object"`;
      w = E.null ? R : (0, n._)`!${y} || ${R}`, delete E.null, delete E.array, delete E.object;
    } else
      w = n.nil;
    E.number && delete E.integer;
    for (const R in E)
      w = (0, n.and)(w, p(R, y, x, S));
    return w;
  }
  Vt.checkDataTypes = v;
  const m = {
    message: ({ schema: g }) => `must be ${g}`,
    params: ({ schema: g, schemaValue: y }) => typeof g == "string" ? (0, n._)`{type: ${g}}` : (0, n._)`{type: ${y}}`
  };
  function h(g) {
    const y = _(g);
    (0, r.reportError)(y, m);
  }
  Vt.reportTypeError = h;
  function _(g) {
    const { gen: y, data: x, schema: S } = g, w = (0, i.schemaRefOrVal)(g, S, "type");
    return {
      gen: y,
      keyword: "type",
      data: x,
      schema: S.type,
      schemaCode: w,
      schemaValue: w,
      parentSchema: S,
      params: {},
      it: g
    };
  }
  return Vt;
}
var ba = {}, q1;
function d2() {
  if (q1) return ba;
  q1 = 1, Object.defineProperty(ba, "__esModule", { value: !0 }), ba.assignDefaults = void 0;
  const e = Ze(), t = st();
  function r(i, a) {
    const { properties: s, items: o } = i.schema;
    if (a === "object" && s)
      for (const c in s)
        n(i, c, s[c].default);
    else a === "array" && Array.isArray(o) && o.forEach((c, u) => n(i, u, c.default));
  }
  ba.assignDefaults = r;
  function n(i, a, s) {
    const { gen: o, compositeRule: c, data: u, opts: l } = i;
    if (s === void 0)
      return;
    const d = (0, e._)`${u}${(0, e.getProperty)(a)}`;
    if (c) {
      (0, t.checkStrictMode)(i, `default is ignored for: ${d}`);
      return;
    }
    let f = (0, e._)`${d} === undefined`;
    l.useDefaults === "empty" && (f = (0, e._)`${f} || ${d} === null || ${d} === ""`), o.if(f, (0, e._)`${d} = ${(0, e.stringify)(s)}`);
  }
  return ba;
}
var Br = {}, dt = {}, B1;
function Zr() {
  if (B1) return dt;
  B1 = 1, Object.defineProperty(dt, "__esModule", { value: !0 }), dt.validateUnion = dt.validateArray = dt.usePattern = dt.callValidateCode = dt.schemaProperties = dt.allSchemaProperties = dt.noPropertyInData = dt.propertyInData = dt.isOwnProperty = dt.hasPropFunc = dt.reportMissingProp = dt.checkMissingProp = dt.checkReportMissingProp = void 0;
  const e = Ze(), t = st(), r = Qr(), n = st();
  function i(g, y) {
    const { gen: x, data: S, it: w } = g;
    x.if(l(x, S, y, w.opts.ownProperties), () => {
      g.setParams({ missingProperty: (0, e._)`${y}` }, !0), g.error();
    });
  }
  dt.checkReportMissingProp = i;
  function a({ gen: g, data: y, it: { opts: x } }, S, w) {
    return (0, e.or)(...S.map((E) => (0, e.and)(l(g, y, E, x.ownProperties), (0, e._)`${w} = ${E}`)));
  }
  dt.checkMissingProp = a;
  function s(g, y) {
    g.setParams({ missingProperty: y }, !0), g.error();
  }
  dt.reportMissingProp = s;
  function o(g) {
    return g.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, e._)`Object.prototype.hasOwnProperty`
    });
  }
  dt.hasPropFunc = o;
  function c(g, y, x) {
    return (0, e._)`${o(g)}.call(${y}, ${x})`;
  }
  dt.isOwnProperty = c;
  function u(g, y, x, S) {
    const w = (0, e._)`${y}${(0, e.getProperty)(x)} !== undefined`;
    return S ? (0, e._)`${w} && ${c(g, y, x)}` : w;
  }
  dt.propertyInData = u;
  function l(g, y, x, S) {
    const w = (0, e._)`${y}${(0, e.getProperty)(x)} === undefined`;
    return S ? (0, e.or)(w, (0, e.not)(c(g, y, x))) : w;
  }
  dt.noPropertyInData = l;
  function d(g) {
    return g ? Object.keys(g).filter((y) => y !== "__proto__") : [];
  }
  dt.allSchemaProperties = d;
  function f(g, y) {
    return d(y).filter((x) => !(0, t.alwaysValidSchema)(g, y[x]));
  }
  dt.schemaProperties = f;
  function p({ schemaCode: g, data: y, it: { gen: x, topSchemaRef: S, schemaPath: w, errorPath: E }, it: R }, N, B, F) {
    const U = F ? (0, e._)`${g}, ${y}, ${S}${w}` : y, G = [
      [r.default.instancePath, (0, e.strConcat)(r.default.instancePath, E)],
      [r.default.parentData, R.parentData],
      [r.default.parentDataProperty, R.parentDataProperty],
      [r.default.rootData, r.default.rootData]
    ];
    R.opts.dynamicRef && G.push([r.default.dynamicAnchors, r.default.dynamicAnchors]);
    const M = (0, e._)`${U}, ${x.object(...G)}`;
    return B !== e.nil ? (0, e._)`${N}.call(${B}, ${M})` : (0, e._)`${N}(${M})`;
  }
  dt.callValidateCode = p;
  const v = (0, e._)`new RegExp`;
  function m({ gen: g, it: { opts: y } }, x) {
    const S = y.unicodeRegExp ? "u" : "", { regExp: w } = y.code, E = w(x, S);
    return g.scopeValue("pattern", {
      key: E.toString(),
      ref: E,
      code: (0, e._)`${w.code === "new RegExp" ? v : (0, n.useFunc)(g, w)}(${x}, ${S})`
    });
  }
  dt.usePattern = m;
  function h(g) {
    const { gen: y, data: x, keyword: S, it: w } = g, E = y.name("valid");
    if (w.allErrors) {
      const N = y.let("valid", !0);
      return R(() => y.assign(N, !1)), N;
    }
    return y.var(E, !0), R(() => y.break()), E;
    function R(N) {
      const B = y.const("len", (0, e._)`${x}.length`);
      y.forRange("i", 0, B, (F) => {
        g.subschema({
          keyword: S,
          dataProp: F,
          dataPropType: t.Type.Num
        }, E), y.if((0, e.not)(E), N);
      });
    }
  }
  dt.validateArray = h;
  function _(g) {
    const { gen: y, schema: x, keyword: S, it: w } = g;
    if (!Array.isArray(x))
      throw new Error("ajv implementation error");
    if (x.some((B) => (0, t.alwaysValidSchema)(w, B)) && !w.opts.unevaluated)
      return;
    const R = y.let("valid", !1), N = y.name("_valid");
    y.block(() => x.forEach((B, F) => {
      const U = g.subschema({
        keyword: S,
        schemaProp: F,
        compositeRule: !0
      }, N);
      y.assign(R, (0, e._)`${R} || ${N}`), g.mergeValidEvaluated(U, N) || y.if((0, e.not)(R));
    })), g.result(R, () => g.reset(), () => g.error(!0));
  }
  return dt.validateUnion = _, dt;
}
var j1;
function h2() {
  if (j1) return Br;
  j1 = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.validateKeywordUsage = Br.validSchemaType = Br.funcKeywordCode = Br.macroKeywordCode = void 0;
  const e = Ze(), t = Qr(), r = Zr(), n = al();
  function i(f, p) {
    const { gen: v, keyword: m, schema: h, parentSchema: _, it: g } = f, y = p.macro.call(g.self, h, _, g), x = u(v, m, y);
    g.opts.validateSchema !== !1 && g.self.validateSchema(y, !0);
    const S = v.name("valid");
    f.subschema({
      schema: y,
      schemaPath: e.nil,
      errSchemaPath: `${g.errSchemaPath}/${m}`,
      topSchemaRef: x,
      compositeRule: !0
    }, S), f.pass(S, () => f.error(!0));
  }
  Br.macroKeywordCode = i;
  function a(f, p) {
    var v;
    const { gen: m, keyword: h, schema: _, parentSchema: g, $data: y, it: x } = f;
    c(x, p);
    const S = !y && p.compile ? p.compile.call(x.self, _, g, x) : p.validate, w = u(m, h, S), E = m.let("valid");
    f.block$data(E, R), f.ok((v = p.valid) !== null && v !== void 0 ? v : E);
    function R() {
      if (p.errors === !1)
        F(), p.modifying && s(f), U(() => f.error());
      else {
        const G = p.async ? N() : B();
        p.modifying && s(f), U(() => o(f, G));
      }
    }
    function N() {
      const G = m.let("ruleErrs", null);
      return m.try(() => F((0, e._)`await `), (M) => m.assign(E, !1).if((0, e._)`${M} instanceof ${x.ValidationError}`, () => m.assign(G, (0, e._)`${M}.errors`), () => m.throw(M))), G;
    }
    function B() {
      const G = (0, e._)`${w}.errors`;
      return m.assign(G, null), F(e.nil), G;
    }
    function F(G = p.async ? (0, e._)`await ` : e.nil) {
      const M = x.opts.passContext ? t.default.this : t.default.self, V = !("compile" in p && !y || p.schema === !1);
      m.assign(E, (0, e._)`${G}${(0, r.callValidateCode)(f, w, M, V)}`, p.modifying);
    }
    function U(G) {
      var M;
      m.if((0, e.not)((M = p.valid) !== null && M !== void 0 ? M : E), G);
    }
  }
  Br.funcKeywordCode = a;
  function s(f) {
    const { gen: p, data: v, it: m } = f;
    p.if(m.parentData, () => p.assign(v, (0, e._)`${m.parentData}[${m.parentDataProperty}]`));
  }
  function o(f, p) {
    const { gen: v } = f;
    v.if((0, e._)`Array.isArray(${p})`, () => {
      v.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${p} : ${t.default.vErrors}.concat(${p})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, n.extendErrors)(f);
    }, () => f.error());
  }
  function c({ schemaEnv: f }, p) {
    if (p.async && !f.$async)
      throw new Error("async keyword in sync schema");
  }
  function u(f, p, v) {
    if (v === void 0)
      throw new Error(`keyword "${p}" failed to compile`);
    return f.scopeValue("keyword", typeof v == "function" ? { ref: v } : { ref: v, code: (0, e.stringify)(v) });
  }
  function l(f, p, v = !1) {
    return !p.length || p.some((m) => m === "array" ? Array.isArray(f) : m === "object" ? f && typeof f == "object" && !Array.isArray(f) : typeof f == m || v && typeof f > "u");
  }
  Br.validSchemaType = l;
  function d({ schema: f, opts: p, self: v, errSchemaPath: m }, h, _) {
    if (Array.isArray(h.keyword) ? !h.keyword.includes(_) : h.keyword !== _)
      throw new Error("ajv implementation error");
    const g = h.dependencies;
    if (g?.some((y) => !Object.prototype.hasOwnProperty.call(f, y)))
      throw new Error(`parent schema must have dependencies of ${_}: ${g.join(",")}`);
    if (h.validateSchema && !h.validateSchema(f[_])) {
      const x = `keyword "${_}" value is invalid at path "${m}": ` + v.errorsText(h.validateSchema.errors);
      if (p.validateSchema === "log")
        v.logger.error(x);
      else
        throw new Error(x);
    }
  }
  return Br.validateKeywordUsage = d, Br;
}
var gn = {}, V1;
function p2() {
  if (V1) return gn;
  V1 = 1, Object.defineProperty(gn, "__esModule", { value: !0 }), gn.extendSubschemaMode = gn.extendSubschemaData = gn.getSubschema = void 0;
  const e = Ze(), t = st();
  function r(a, { keyword: s, schemaProp: o, schema: c, schemaPath: u, errSchemaPath: l, topSchemaRef: d }) {
    if (s !== void 0 && c !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (s !== void 0) {
      const f = a.schema[s];
      return o === void 0 ? {
        schema: f,
        schemaPath: (0, e._)`${a.schemaPath}${(0, e.getProperty)(s)}`,
        errSchemaPath: `${a.errSchemaPath}/${s}`
      } : {
        schema: f[o],
        schemaPath: (0, e._)`${a.schemaPath}${(0, e.getProperty)(s)}${(0, e.getProperty)(o)}`,
        errSchemaPath: `${a.errSchemaPath}/${s}/${(0, t.escapeFragment)(o)}`
      };
    }
    if (c !== void 0) {
      if (u === void 0 || l === void 0 || d === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: c,
        schemaPath: u,
        topSchemaRef: d,
        errSchemaPath: l
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  gn.getSubschema = r;
  function n(a, s, { dataProp: o, dataPropType: c, data: u, dataTypes: l, propertyName: d }) {
    if (u !== void 0 && o !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: f } = s;
    if (o !== void 0) {
      const { errorPath: v, dataPathArr: m, opts: h } = s, _ = f.let("data", (0, e._)`${s.data}${(0, e.getProperty)(o)}`, !0);
      p(_), a.errorPath = (0, e.str)`${v}${(0, t.getErrorPath)(o, c, h.jsPropertySyntax)}`, a.parentDataProperty = (0, e._)`${o}`, a.dataPathArr = [...m, a.parentDataProperty];
    }
    if (u !== void 0) {
      const v = u instanceof e.Name ? u : f.let("data", u, !0);
      p(v), d !== void 0 && (a.propertyName = d);
    }
    l && (a.dataTypes = l);
    function p(v) {
      a.data = v, a.dataLevel = s.dataLevel + 1, a.dataTypes = [], s.definedProperties = /* @__PURE__ */ new Set(), a.parentData = s.data, a.dataNames = [...s.dataNames, v];
    }
  }
  gn.extendSubschemaData = n;
  function i(a, { jtdDiscriminator: s, jtdMetadata: o, compositeRule: c, createErrors: u, allErrors: l }) {
    c !== void 0 && (a.compositeRule = c), u !== void 0 && (a.createErrors = u), l !== void 0 && (a.allErrors = l), a.jtdDiscriminator = s, a.jtdMetadata = o;
  }
  return gn.extendSubschemaMode = i, gn;
}
var or = {}, qf, H1;
function sl() {
  return H1 || (H1 = 1, qf = function e(t, r) {
    if (t === r) return !0;
    if (t && r && typeof t == "object" && typeof r == "object") {
      if (t.constructor !== r.constructor) return !1;
      var n, i, a;
      if (Array.isArray(t)) {
        if (n = t.length, n != r.length) return !1;
        for (i = n; i-- !== 0; )
          if (!e(t[i], r[i])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
      if (a = Object.keys(t), n = a.length, n !== Object.keys(r).length) return !1;
      for (i = n; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, a[i])) return !1;
      for (i = n; i-- !== 0; ) {
        var s = a[i];
        if (!e(t[s], r[s])) return !1;
      }
      return !0;
    }
    return t !== t && r !== r;
  }), qf;
}
var Bf = { exports: {} }, G1;
function m2() {
  if (G1) return Bf.exports;
  G1 = 1;
  var e = Bf.exports = function(n, i, a) {
    typeof i == "function" && (a = i, i = {}), a = i.cb || a;
    var s = typeof a == "function" ? a : a.pre || function() {
    }, o = a.post || function() {
    };
    t(i, s, o, n, "", n);
  };
  e.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, e.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, e.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, e.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function t(n, i, a, s, o, c, u, l, d, f) {
    if (s && typeof s == "object" && !Array.isArray(s)) {
      i(s, o, c, u, l, d, f);
      for (var p in s) {
        var v = s[p];
        if (Array.isArray(v)) {
          if (p in e.arrayKeywords)
            for (var m = 0; m < v.length; m++)
              t(n, i, a, v[m], o + "/" + p + "/" + m, c, o, p, s, m);
        } else if (p in e.propsKeywords) {
          if (v && typeof v == "object")
            for (var h in v)
              t(n, i, a, v[h], o + "/" + p + "/" + r(h), c, o, p, s, h);
        } else (p in e.keywords || n.allKeys && !(p in e.skipKeywords)) && t(n, i, a, v, o + "/" + p, c, o, p, s);
      }
      a(s, o, c, u, l, d, f);
    }
  }
  function r(n) {
    return n.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return Bf.exports;
}
var z1;
function ol() {
  if (z1) return or;
  z1 = 1, Object.defineProperty(or, "__esModule", { value: !0 }), or.getSchemaRefs = or.resolveUrl = or.normalizeId = or._getFullPath = or.getFullPath = or.inlineRef = void 0;
  const e = st(), t = sl(), r = m2(), n = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function i(m, h = !0) {
    return typeof m == "boolean" ? !0 : h === !0 ? !s(m) : h ? o(m) <= h : !1;
  }
  or.inlineRef = i;
  const a = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function s(m) {
    for (const h in m) {
      if (a.has(h))
        return !0;
      const _ = m[h];
      if (Array.isArray(_) && _.some(s) || typeof _ == "object" && s(_))
        return !0;
    }
    return !1;
  }
  function o(m) {
    let h = 0;
    for (const _ in m) {
      if (_ === "$ref")
        return 1 / 0;
      if (h++, !n.has(_) && (typeof m[_] == "object" && (0, e.eachItem)(m[_], (g) => h += o(g)), h === 1 / 0))
        return 1 / 0;
    }
    return h;
  }
  function c(m, h = "", _) {
    _ !== !1 && (h = d(h));
    const g = m.parse(h);
    return u(m, g);
  }
  or.getFullPath = c;
  function u(m, h) {
    return m.serialize(h).split("#")[0] + "#";
  }
  or._getFullPath = u;
  const l = /#\/?$/;
  function d(m) {
    return m ? m.replace(l, "") : "";
  }
  or.normalizeId = d;
  function f(m, h, _) {
    return _ = d(_), m.resolve(h, _);
  }
  or.resolveUrl = f;
  const p = /^[a-z_][-a-z0-9._]*$/i;
  function v(m, h) {
    if (typeof m == "boolean")
      return {};
    const { schemaId: _, uriResolver: g } = this.opts, y = d(m[_] || h), x = { "": y }, S = c(g, y, !1), w = {}, E = /* @__PURE__ */ new Set();
    return r(m, { allKeys: !0 }, (B, F, U, G) => {
      if (G === void 0)
        return;
      const M = S + F;
      let V = x[G];
      typeof B[_] == "string" && (V = ie.call(this, B[_])), W.call(this, B.$anchor), W.call(this, B.$dynamicAnchor), x[F] = V;
      function ie(ae) {
        const se = this.opts.uriResolver.resolve;
        if (ae = d(V ? se(V, ae) : ae), E.has(ae))
          throw N(ae);
        E.add(ae);
        let X = this.refs[ae];
        return typeof X == "string" && (X = this.refs[X]), typeof X == "object" ? R(B, X.schema, ae) : ae !== d(M) && (ae[0] === "#" ? (R(B, w[ae], ae), w[ae] = B) : this.refs[ae] = M), ae;
      }
      function W(ae) {
        if (typeof ae == "string") {
          if (!p.test(ae))
            throw new Error(`invalid anchor "${ae}"`);
          ie.call(this, `#${ae}`);
        }
      }
    }), w;
    function R(B, F, U) {
      if (F !== void 0 && !t(B, F))
        throw N(U);
    }
    function N(B) {
      return new Error(`reference "${B}" resolves to more than one schema`);
    }
  }
  return or.getSchemaRefs = v, or;
}
var W1;
function cl() {
  if (W1) return pn;
  W1 = 1, Object.defineProperty(pn, "__esModule", { value: !0 }), pn.getData = pn.KeywordCxt = pn.validateFunctionCode = void 0;
  const e = f2(), t = Pc(), r = qE(), n = Pc(), i = d2(), a = h2(), s = p2(), o = Ze(), c = Qr(), u = ol(), l = st(), d = al();
  function f(D) {
    if (S(D) && (E(D), x(D))) {
      h(D);
      return;
    }
    p(D, () => (0, e.topBoolOrEmptySchema)(D));
  }
  pn.validateFunctionCode = f;
  function p({ gen: D, validateName: q, schema: J, schemaEnv: ne, opts: ce }, Ee) {
    ce.code.es5 ? D.func(q, (0, o._)`${c.default.data}, ${c.default.valCxt}`, ne.$async, () => {
      D.code((0, o._)`"use strict"; ${g(J, ce)}`), m(D, ce), D.code(Ee);
    }) : D.func(q, (0, o._)`${c.default.data}, ${v(ce)}`, ne.$async, () => D.code(g(J, ce)).code(Ee));
  }
  function v(D) {
    return (0, o._)`{${c.default.instancePath}="", ${c.default.parentData}, ${c.default.parentDataProperty}, ${c.default.rootData}=${c.default.data}${D.dynamicRef ? (0, o._)`, ${c.default.dynamicAnchors}={}` : o.nil}}={}`;
  }
  function m(D, q) {
    D.if(c.default.valCxt, () => {
      D.var(c.default.instancePath, (0, o._)`${c.default.valCxt}.${c.default.instancePath}`), D.var(c.default.parentData, (0, o._)`${c.default.valCxt}.${c.default.parentData}`), D.var(c.default.parentDataProperty, (0, o._)`${c.default.valCxt}.${c.default.parentDataProperty}`), D.var(c.default.rootData, (0, o._)`${c.default.valCxt}.${c.default.rootData}`), q.dynamicRef && D.var(c.default.dynamicAnchors, (0, o._)`${c.default.valCxt}.${c.default.dynamicAnchors}`);
    }, () => {
      D.var(c.default.instancePath, (0, o._)`""`), D.var(c.default.parentData, (0, o._)`undefined`), D.var(c.default.parentDataProperty, (0, o._)`undefined`), D.var(c.default.rootData, c.default.data), q.dynamicRef && D.var(c.default.dynamicAnchors, (0, o._)`{}`);
    });
  }
  function h(D) {
    const { schema: q, opts: J, gen: ne } = D;
    p(D, () => {
      J.$comment && q.$comment && G(D), B(D), ne.let(c.default.vErrors, null), ne.let(c.default.errors, 0), J.unevaluated && _(D), R(D), M(D);
    });
  }
  function _(D) {
    const { gen: q, validateName: J } = D;
    D.evaluated = q.const("evaluated", (0, o._)`${J}.evaluated`), q.if((0, o._)`${D.evaluated}.dynamicProps`, () => q.assign((0, o._)`${D.evaluated}.props`, (0, o._)`undefined`)), q.if((0, o._)`${D.evaluated}.dynamicItems`, () => q.assign((0, o._)`${D.evaluated}.items`, (0, o._)`undefined`));
  }
  function g(D, q) {
    const J = typeof D == "object" && D[q.schemaId];
    return J && (q.code.source || q.code.process) ? (0, o._)`/*# sourceURL=${J} */` : o.nil;
  }
  function y(D, q) {
    if (S(D) && (E(D), x(D))) {
      w(D, q);
      return;
    }
    (0, e.boolOrEmptySchema)(D, q);
  }
  function x({ schema: D, self: q }) {
    if (typeof D == "boolean")
      return !D;
    for (const J in D)
      if (q.RULES.all[J])
        return !0;
    return !1;
  }
  function S(D) {
    return typeof D.schema != "boolean";
  }
  function w(D, q) {
    const { schema: J, gen: ne, opts: ce } = D;
    ce.$comment && J.$comment && G(D), F(D), U(D);
    const Ee = ne.const("_errs", c.default.errors);
    R(D, Ee), ne.var(q, (0, o._)`${Ee} === ${c.default.errors}`);
  }
  function E(D) {
    (0, l.checkUnknownRules)(D), N(D);
  }
  function R(D, q) {
    if (D.opts.jtd)
      return ie(D, [], !1, q);
    const J = (0, t.getSchemaTypes)(D.schema), ne = (0, t.coerceAndCheckDataType)(D, J);
    ie(D, J, !ne, q);
  }
  function N(D) {
    const { schema: q, errSchemaPath: J, opts: ne, self: ce } = D;
    q.$ref && ne.ignoreKeywordsWithRef && (0, l.schemaHasRulesButRef)(q, ce.RULES) && ce.logger.warn(`$ref: keywords ignored in schema at path "${J}"`);
  }
  function B(D) {
    const { schema: q, opts: J } = D;
    q.default !== void 0 && J.useDefaults && J.strictSchema && (0, l.checkStrictMode)(D, "default is ignored in the schema root");
  }
  function F(D) {
    const q = D.schema[D.opts.schemaId];
    q && (D.baseId = (0, u.resolveUrl)(D.opts.uriResolver, D.baseId, q));
  }
  function U(D) {
    if (D.schema.$async && !D.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function G({ gen: D, schemaEnv: q, schema: J, errSchemaPath: ne, opts: ce }) {
    const Ee = J.$comment;
    if (ce.$comment === !0)
      D.code((0, o._)`${c.default.self}.logger.log(${Ee})`);
    else if (typeof ce.$comment == "function") {
      const ge = (0, o.str)`${ne}/$comment`, Ge = D.scopeValue("root", { ref: q.root });
      D.code((0, o._)`${c.default.self}.opts.$comment(${Ee}, ${ge}, ${Ge}.schema)`);
    }
  }
  function M(D) {
    const { gen: q, schemaEnv: J, validateName: ne, ValidationError: ce, opts: Ee } = D;
    J.$async ? q.if((0, o._)`${c.default.errors} === 0`, () => q.return(c.default.data), () => q.throw((0, o._)`new ${ce}(${c.default.vErrors})`)) : (q.assign((0, o._)`${ne}.errors`, c.default.vErrors), Ee.unevaluated && V(D), q.return((0, o._)`${c.default.errors} === 0`));
  }
  function V({ gen: D, evaluated: q, props: J, items: ne }) {
    J instanceof o.Name && D.assign((0, o._)`${q}.props`, J), ne instanceof o.Name && D.assign((0, o._)`${q}.items`, ne);
  }
  function ie(D, q, J, ne) {
    const { gen: ce, schema: Ee, data: ge, allErrors: Ge, opts: ze, self: Xe } = D, { RULES: He } = Xe;
    if (Ee.$ref && (ze.ignoreKeywordsWithRef || !(0, l.schemaHasRulesButRef)(Ee, He))) {
      ce.block(() => b(D, "$ref", He.all.$ref.definition));
      return;
    }
    ze.jtd || ae(D, q), ce.block(() => {
      for (const le of He.rules)
        O(le);
      O(He.post);
    });
    function O(le) {
      (0, r.shouldUseGroup)(Ee, le) && (le.type ? (ce.if((0, n.checkDataType)(le.type, ge, ze.strictNumbers)), W(D, le), q.length === 1 && q[0] === le.type && J && (ce.else(), (0, n.reportTypeError)(D)), ce.endIf()) : W(D, le), Ge || ce.if((0, o._)`${c.default.errors} === ${ne || 0}`));
    }
  }
  function W(D, q) {
    const { gen: J, schema: ne, opts: { useDefaults: ce } } = D;
    ce && (0, i.assignDefaults)(D, q.type), J.block(() => {
      for (const Ee of q.rules)
        (0, r.shouldUseRule)(ne, Ee) && b(D, Ee.keyword, Ee.definition, q.type);
    });
  }
  function ae(D, q) {
    D.schemaEnv.meta || !D.opts.strictTypes || (se(D, q), D.opts.allowUnionTypes || X(D, q), k(D, D.dataTypes));
  }
  function se(D, q) {
    if (q.length) {
      if (!D.dataTypes.length) {
        D.dataTypes = q;
        return;
      }
      q.forEach((J) => {
        C(D.dataTypes, J) || A(D, `type "${J}" not allowed by context "${D.dataTypes.join(",")}"`);
      }), T(D, q);
    }
  }
  function X(D, q) {
    q.length > 1 && !(q.length === 2 && q.includes("null")) && A(D, "use allowUnionTypes to allow union type keyword");
  }
  function k(D, q) {
    const J = D.self.RULES.all;
    for (const ne in J) {
      const ce = J[ne];
      if (typeof ce == "object" && (0, r.shouldUseRule)(D.schema, ce)) {
        const { type: Ee } = ce.definition;
        Ee.length && !Ee.some((ge) => I(q, ge)) && A(D, `missing type "${Ee.join(",")}" for keyword "${ne}"`);
      }
    }
  }
  function I(D, q) {
    return D.includes(q) || q === "number" && D.includes("integer");
  }
  function C(D, q) {
    return D.includes(q) || q === "integer" && D.includes("number");
  }
  function T(D, q) {
    const J = [];
    for (const ne of D.dataTypes)
      C(q, ne) ? J.push(ne) : q.includes("integer") && ne === "number" && J.push("integer");
    D.dataTypes = J;
  }
  function A(D, q) {
    const J = D.schemaEnv.baseId + D.errSchemaPath;
    q += ` at "${J}" (strictTypes)`, (0, l.checkStrictMode)(D, q, D.opts.strictTypes);
  }
  class L {
    constructor(q, J, ne) {
      if ((0, a.validateKeywordUsage)(q, J, ne), this.gen = q.gen, this.allErrors = q.allErrors, this.keyword = ne, this.data = q.data, this.schema = q.schema[ne], this.$data = J.$data && q.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, l.schemaRefOrVal)(q, this.schema, ne, this.$data), this.schemaType = J.schemaType, this.parentSchema = q.schema, this.params = {}, this.it = q, this.def = J, this.$data)
        this.schemaCode = q.gen.const("vSchema", H(this.$data, q));
      else if (this.schemaCode = this.schemaValue, !(0, a.validSchemaType)(this.schema, J.schemaType, J.allowUndefined))
        throw new Error(`${ne} value must be ${JSON.stringify(J.schemaType)}`);
      ("code" in J ? J.trackErrors : J.errors !== !1) && (this.errsCount = q.gen.const("_errs", c.default.errors));
    }
    result(q, J, ne) {
      this.failResult((0, o.not)(q), J, ne);
    }
    failResult(q, J, ne) {
      this.gen.if(q), ne ? ne() : this.error(), J ? (this.gen.else(), J(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(q, J) {
      this.failResult((0, o.not)(q), void 0, J);
    }
    fail(q) {
      if (q === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(q), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(q) {
      if (!this.$data)
        return this.fail(q);
      const { schemaCode: J } = this;
      this.fail((0, o._)`${J} !== undefined && (${(0, o.or)(this.invalid$data(), q)})`);
    }
    error(q, J, ne) {
      if (J) {
        this.setParams(J), this._error(q, ne), this.setParams({});
        return;
      }
      this._error(q, ne);
    }
    _error(q, J) {
      (q ? d.reportExtraError : d.reportError)(this, this.def.error, J);
    }
    $dataError() {
      (0, d.reportError)(this, this.def.$dataError || d.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, d.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(q) {
      this.allErrors || this.gen.if(q);
    }
    setParams(q, J) {
      J ? Object.assign(this.params, q) : this.params = q;
    }
    block$data(q, J, ne = o.nil) {
      this.gen.block(() => {
        this.check$data(q, ne), J();
      });
    }
    check$data(q = o.nil, J = o.nil) {
      if (!this.$data)
        return;
      const { gen: ne, schemaCode: ce, schemaType: Ee, def: ge } = this;
      ne.if((0, o.or)((0, o._)`${ce} === undefined`, J)), q !== o.nil && ne.assign(q, !0), (Ee.length || ge.validateSchema) && (ne.elseIf(this.invalid$data()), this.$dataError(), q !== o.nil && ne.assign(q, !1)), ne.else();
    }
    invalid$data() {
      const { gen: q, schemaCode: J, schemaType: ne, def: ce, it: Ee } = this;
      return (0, o.or)(ge(), Ge());
      function ge() {
        if (ne.length) {
          if (!(J instanceof o.Name))
            throw new Error("ajv implementation error");
          const ze = Array.isArray(ne) ? ne : [ne];
          return (0, o._)`${(0, n.checkDataTypes)(ze, J, Ee.opts.strictNumbers, n.DataType.Wrong)}`;
        }
        return o.nil;
      }
      function Ge() {
        if (ce.validateSchema) {
          const ze = q.scopeValue("validate$data", { ref: ce.validateSchema });
          return (0, o._)`!${ze}(${J})`;
        }
        return o.nil;
      }
    }
    subschema(q, J) {
      const ne = (0, s.getSubschema)(this.it, q);
      (0, s.extendSubschemaData)(ne, this.it, q), (0, s.extendSubschemaMode)(ne, q);
      const ce = { ...this.it, ...ne, items: void 0, props: void 0 };
      return y(ce, J), ce;
    }
    mergeEvaluated(q, J) {
      const { it: ne, gen: ce } = this;
      ne.opts.unevaluated && (ne.props !== !0 && q.props !== void 0 && (ne.props = l.mergeEvaluated.props(ce, q.props, ne.props, J)), ne.items !== !0 && q.items !== void 0 && (ne.items = l.mergeEvaluated.items(ce, q.items, ne.items, J)));
    }
    mergeValidEvaluated(q, J) {
      const { it: ne, gen: ce } = this;
      if (ne.opts.unevaluated && (ne.props !== !0 || ne.items !== !0))
        return ce.if(J, () => this.mergeEvaluated(q, o.Name)), !0;
    }
  }
  pn.KeywordCxt = L;
  function b(D, q, J, ne) {
    const ce = new L(D, J, q);
    "code" in J ? J.code(ce, ne) : ce.$data && J.validate ? (0, a.funcKeywordCode)(ce, J) : "macro" in J ? (0, a.macroKeywordCode)(ce, J) : (J.compile || J.validate) && (0, a.funcKeywordCode)(ce, J);
  }
  const P = /^\/(?:[^~]|~0|~1)*$/, te = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function H(D, { dataLevel: q, dataNames: J, dataPathArr: ne }) {
    let ce, Ee;
    if (D === "")
      return c.default.rootData;
    if (D[0] === "/") {
      if (!P.test(D))
        throw new Error(`Invalid JSON-pointer: ${D}`);
      ce = D, Ee = c.default.rootData;
    } else {
      const Xe = te.exec(D);
      if (!Xe)
        throw new Error(`Invalid JSON-pointer: ${D}`);
      const He = +Xe[1];
      if (ce = Xe[2], ce === "#") {
        if (He >= q)
          throw new Error(ze("property/index", He));
        return ne[q - He];
      }
      if (He > q)
        throw new Error(ze("data", He));
      if (Ee = J[q - He], !ce)
        return Ee;
    }
    let ge = Ee;
    const Ge = ce.split("/");
    for (const Xe of Ge)
      Xe && (Ee = (0, o._)`${Ee}${(0, o.getProperty)((0, l.unescapeJsonPointer)(Xe))}`, ge = (0, o._)`${ge} && ${Ee}`);
    return ge;
    function ze(Xe, He) {
      return `Cannot access ${Xe} ${He} levels up, current level is ${q}`;
    }
  }
  return pn.getData = H, pn;
}
var Ds = {}, X1;
function P0() {
  if (X1) return Ds;
  X1 = 1, Object.defineProperty(Ds, "__esModule", { value: !0 });
  class e extends Error {
    constructor(r) {
      super("validation failed"), this.errors = r, this.ajv = this.validation = !0;
    }
  }
  return Ds.default = e, Ds;
}
var ks = {}, K1;
function ll() {
  if (K1) return ks;
  K1 = 1, Object.defineProperty(ks, "__esModule", { value: !0 });
  const e = ol();
  class t extends Error {
    constructor(n, i, a, s) {
      super(s || `can't resolve reference ${a} from id ${i}`), this.missingRef = (0, e.resolveUrl)(n, i, a), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(n, this.missingRef));
    }
  }
  return ks.default = t, ks;
}
var Sr = {}, Y1;
function ul() {
  if (Y1) return Sr;
  Y1 = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.resolveSchema = Sr.getCompilingSchema = Sr.resolveRef = Sr.compileSchema = Sr.SchemaEnv = void 0;
  const e = Ze(), t = P0(), r = Qr(), n = ol(), i = st(), a = cl();
  class s {
    constructor(_) {
      var g;
      this.refs = {}, this.dynamicAnchors = {};
      let y;
      typeof _.schema == "object" && (y = _.schema), this.schema = _.schema, this.schemaId = _.schemaId, this.root = _.root || this, this.baseId = (g = _.baseId) !== null && g !== void 0 ? g : (0, n.normalizeId)(y?.[_.schemaId || "$id"]), this.schemaPath = _.schemaPath, this.localRefs = _.localRefs, this.meta = _.meta, this.$async = y?.$async, this.refs = {};
    }
  }
  Sr.SchemaEnv = s;
  function o(h) {
    const _ = l.call(this, h);
    if (_)
      return _;
    const g = (0, n.getFullPath)(this.opts.uriResolver, h.root.baseId), { es5: y, lines: x } = this.opts.code, { ownProperties: S } = this.opts, w = new e.CodeGen(this.scope, { es5: y, lines: x, ownProperties: S });
    let E;
    h.$async && (E = w.scopeValue("Error", {
      ref: t.default,
      code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const R = w.scopeName("validate");
    h.validateName = R;
    const N = {
      gen: w,
      allErrors: this.opts.allErrors,
      data: r.default.data,
      parentData: r.default.parentData,
      parentDataProperty: r.default.parentDataProperty,
      dataNames: [r.default.data],
      dataPathArr: [e.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: w.scopeValue("schema", this.opts.code.source === !0 ? { ref: h.schema, code: (0, e.stringify)(h.schema) } : { ref: h.schema }),
      validateName: R,
      ValidationError: E,
      schema: h.schema,
      schemaEnv: h,
      rootId: g,
      baseId: h.baseId || g,
      schemaPath: e.nil,
      errSchemaPath: h.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, e._)`""`,
      opts: this.opts,
      self: this
    };
    let B;
    try {
      this._compilations.add(h), (0, a.validateFunctionCode)(N), w.optimize(this.opts.code.optimize);
      const F = w.toString();
      B = `${w.scopeRefs(r.default.scope)}return ${F}`, this.opts.code.process && (B = this.opts.code.process(B, h));
      const G = new Function(`${r.default.self}`, `${r.default.scope}`, B)(this, this.scope.get());
      if (this.scope.value(R, { ref: G }), G.errors = null, G.schema = h.schema, G.schemaEnv = h, h.$async && (G.$async = !0), this.opts.code.source === !0 && (G.source = { validateName: R, validateCode: F, scopeValues: w._values }), this.opts.unevaluated) {
        const { props: M, items: V } = N;
        G.evaluated = {
          props: M instanceof e.Name ? void 0 : M,
          items: V instanceof e.Name ? void 0 : V,
          dynamicProps: M instanceof e.Name,
          dynamicItems: V instanceof e.Name
        }, G.source && (G.source.evaluated = (0, e.stringify)(G.evaluated));
      }
      return h.validate = G, h;
    } catch (F) {
      throw delete h.validate, delete h.validateName, B && this.logger.error("Error compiling schema, function code:", B), F;
    } finally {
      this._compilations.delete(h);
    }
  }
  Sr.compileSchema = o;
  function c(h, _, g) {
    var y;
    g = (0, n.resolveUrl)(this.opts.uriResolver, _, g);
    const x = h.refs[g];
    if (x)
      return x;
    let S = f.call(this, h, g);
    if (S === void 0) {
      const w = (y = h.localRefs) === null || y === void 0 ? void 0 : y[g], { schemaId: E } = this.opts;
      w && (S = new s({ schema: w, schemaId: E, root: h, baseId: _ }));
    }
    if (S !== void 0)
      return h.refs[g] = u.call(this, S);
  }
  Sr.resolveRef = c;
  function u(h) {
    return (0, n.inlineRef)(h.schema, this.opts.inlineRefs) ? h.schema : h.validate ? h : o.call(this, h);
  }
  function l(h) {
    for (const _ of this._compilations)
      if (d(_, h))
        return _;
  }
  Sr.getCompilingSchema = l;
  function d(h, _) {
    return h.schema === _.schema && h.root === _.root && h.baseId === _.baseId;
  }
  function f(h, _) {
    let g;
    for (; typeof (g = this.refs[_]) == "string"; )
      _ = g;
    return g || this.schemas[_] || p.call(this, h, _);
  }
  function p(h, _) {
    const g = this.opts.uriResolver.parse(_), y = (0, n._getFullPath)(this.opts.uriResolver, g);
    let x = (0, n.getFullPath)(this.opts.uriResolver, h.baseId, void 0);
    if (Object.keys(h.schema).length > 0 && y === x)
      return m.call(this, g, h);
    const S = (0, n.normalizeId)(y), w = this.refs[S] || this.schemas[S];
    if (typeof w == "string") {
      const E = p.call(this, h, w);
      return typeof E?.schema != "object" ? void 0 : m.call(this, g, E);
    }
    if (typeof w?.schema == "object") {
      if (w.validate || o.call(this, w), S === (0, n.normalizeId)(_)) {
        const { schema: E } = w, { schemaId: R } = this.opts, N = E[R];
        return N && (x = (0, n.resolveUrl)(this.opts.uriResolver, x, N)), new s({ schema: E, schemaId: R, root: h, baseId: x });
      }
      return m.call(this, g, w);
    }
  }
  Sr.resolveSchema = p;
  const v = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function m(h, { baseId: _, schema: g, root: y }) {
    var x;
    if (((x = h.fragment) === null || x === void 0 ? void 0 : x[0]) !== "/")
      return;
    for (const E of h.fragment.slice(1).split("/")) {
      if (typeof g == "boolean")
        return;
      const R = g[(0, i.unescapeFragment)(E)];
      if (R === void 0)
        return;
      g = R;
      const N = typeof g == "object" && g[this.opts.schemaId];
      !v.has(E) && N && (_ = (0, n.resolveUrl)(this.opts.uriResolver, _, N));
    }
    let S;
    if (typeof g != "boolean" && g.$ref && !(0, i.schemaHasRulesButRef)(g, this.RULES)) {
      const E = (0, n.resolveUrl)(this.opts.uriResolver, _, g.$ref);
      S = p.call(this, y, E);
    }
    const { schemaId: w } = this.opts;
    if (S = S || new s({ schema: g, schemaId: w, root: y, baseId: _ }), S.schema !== S.root.schema)
      return S;
  }
  return Sr;
}
const g2 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", v2 = "Meta-schema for $data reference (JSON AnySchema extension proposal)", _2 = "object", y2 = ["$data"], E2 = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, w2 = !1, x2 = {
  $id: g2,
  description: v2,
  type: _2,
  required: y2,
  properties: E2,
  additionalProperties: w2
};
var Ls = {}, Fa = { exports: {} }, jf, J1;
function BE() {
  if (J1) return jf;
  J1 = 1;
  const e = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), t = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function r(f) {
    let p = "", v = 0, m = 0;
    for (m = 0; m < f.length; m++)
      if (v = f[m].charCodeAt(0), v !== 48) {
        if (!(v >= 48 && v <= 57 || v >= 65 && v <= 70 || v >= 97 && v <= 102))
          return "";
        p += f[m];
        break;
      }
    for (m += 1; m < f.length; m++) {
      if (v = f[m].charCodeAt(0), !(v >= 48 && v <= 57 || v >= 65 && v <= 70 || v >= 97 && v <= 102))
        return "";
      p += f[m];
    }
    return p;
  }
  const n = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function i(f) {
    return f.length = 0, !0;
  }
  function a(f, p, v) {
    if (f.length) {
      const m = r(f);
      if (m !== "")
        p.push(m);
      else
        return v.error = !0, !1;
      f.length = 0;
    }
    return !0;
  }
  function s(f) {
    let p = 0;
    const v = { error: !1, address: "", zone: "" }, m = [], h = [];
    let _ = !1, g = !1, y = a;
    for (let x = 0; x < f.length; x++) {
      const S = f[x];
      if (!(S === "[" || S === "]"))
        if (S === ":") {
          if (_ === !0 && (g = !0), !y(h, m, v))
            break;
          if (++p > 7) {
            v.error = !0;
            break;
          }
          x > 0 && f[x - 1] === ":" && (_ = !0), m.push(":");
          continue;
        } else if (S === "%") {
          if (!y(h, m, v))
            break;
          y = i;
        } else {
          h.push(S);
          continue;
        }
    }
    return h.length && (y === i ? v.zone = h.join("") : g ? m.push(h.join("")) : m.push(r(h))), v.address = m.join(""), v;
  }
  function o(f) {
    if (c(f, ":") < 2)
      return { host: f, isIPV6: !1 };
    const p = s(f);
    if (p.error)
      return { host: f, isIPV6: !1 };
    {
      let v = p.address, m = p.address;
      return p.zone && (v += "%" + p.zone, m += "%25" + p.zone), { host: v, isIPV6: !0, escapedHost: m };
    }
  }
  function c(f, p) {
    let v = 0;
    for (let m = 0; m < f.length; m++)
      f[m] === p && v++;
    return v;
  }
  function u(f) {
    let p = f;
    const v = [];
    let m = -1, h = 0;
    for (; h = p.length; ) {
      if (h === 1) {
        if (p === ".")
          break;
        if (p === "/") {
          v.push("/");
          break;
        } else {
          v.push(p);
          break;
        }
      } else if (h === 2) {
        if (p[0] === ".") {
          if (p[1] === ".")
            break;
          if (p[1] === "/") {
            p = p.slice(2);
            continue;
          }
        } else if (p[0] === "/" && (p[1] === "." || p[1] === "/")) {
          v.push("/");
          break;
        }
      } else if (h === 3 && p === "/..") {
        v.length !== 0 && v.pop(), v.push("/");
        break;
      }
      if (p[0] === ".") {
        if (p[1] === ".") {
          if (p[2] === "/") {
            p = p.slice(3);
            continue;
          }
        } else if (p[1] === "/") {
          p = p.slice(2);
          continue;
        }
      } else if (p[0] === "/" && p[1] === ".") {
        if (p[2] === "/") {
          p = p.slice(2);
          continue;
        } else if (p[2] === "." && p[3] === "/") {
          p = p.slice(3), v.length !== 0 && v.pop();
          continue;
        }
      }
      if ((m = p.indexOf("/", 1)) === -1) {
        v.push(p);
        break;
      } else
        v.push(p.slice(0, m)), p = p.slice(m);
    }
    return v.join("");
  }
  function l(f, p) {
    const v = p !== !0 ? escape : unescape;
    return f.scheme !== void 0 && (f.scheme = v(f.scheme)), f.userinfo !== void 0 && (f.userinfo = v(f.userinfo)), f.host !== void 0 && (f.host = v(f.host)), f.path !== void 0 && (f.path = v(f.path)), f.query !== void 0 && (f.query = v(f.query)), f.fragment !== void 0 && (f.fragment = v(f.fragment)), f;
  }
  function d(f) {
    const p = [];
    if (f.userinfo !== void 0 && (p.push(f.userinfo), p.push("@")), f.host !== void 0) {
      let v = unescape(f.host);
      if (!t(v)) {
        const m = o(v);
        m.isIPV6 === !0 ? v = `[${m.escapedHost}]` : v = f.host;
      }
      p.push(v);
    }
    return (typeof f.port == "number" || typeof f.port == "string") && (p.push(":"), p.push(String(f.port))), p.length ? p.join("") : void 0;
  }
  return jf = {
    nonSimpleDomain: n,
    recomposeAuthority: d,
    normalizeComponentEncoding: l,
    removeDotSegments: u,
    isIPv4: t,
    isUUID: e,
    normalizeIPv6: o,
    stringArrayToHexStripped: r
  }, jf;
}
var Vf, Q1;
function T2() {
  if (Q1) return Vf;
  Q1 = 1;
  const { isUUID: e } = BE(), t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, r = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function n(S) {
    return r.indexOf(
      /** @type {*} */
      S
    ) !== -1;
  }
  function i(S) {
    return S.secure === !0 ? !0 : S.secure === !1 ? !1 : S.scheme ? S.scheme.length === 3 && (S.scheme[0] === "w" || S.scheme[0] === "W") && (S.scheme[1] === "s" || S.scheme[1] === "S") && (S.scheme[2] === "s" || S.scheme[2] === "S") : !1;
  }
  function a(S) {
    return S.host || (S.error = S.error || "HTTP URIs must have a host."), S;
  }
  function s(S) {
    const w = String(S.scheme).toLowerCase() === "https";
    return (S.port === (w ? 443 : 80) || S.port === "") && (S.port = void 0), S.path || (S.path = "/"), S;
  }
  function o(S) {
    return S.secure = i(S), S.resourceName = (S.path || "/") + (S.query ? "?" + S.query : ""), S.path = void 0, S.query = void 0, S;
  }
  function c(S) {
    if ((S.port === (i(S) ? 443 : 80) || S.port === "") && (S.port = void 0), typeof S.secure == "boolean" && (S.scheme = S.secure ? "wss" : "ws", S.secure = void 0), S.resourceName) {
      const [w, E] = S.resourceName.split("?");
      S.path = w && w !== "/" ? w : void 0, S.query = E, S.resourceName = void 0;
    }
    return S.fragment = void 0, S;
  }
  function u(S, w) {
    if (!S.path)
      return S.error = "URN can not be parsed", S;
    const E = S.path.match(t);
    if (E) {
      const R = w.scheme || S.scheme || "urn";
      S.nid = E[1].toLowerCase(), S.nss = E[2];
      const N = `${R}:${w.nid || S.nid}`, B = x(N);
      S.path = void 0, B && (S = B.parse(S, w));
    } else
      S.error = S.error || "URN can not be parsed.";
    return S;
  }
  function l(S, w) {
    if (S.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const E = w.scheme || S.scheme || "urn", R = S.nid.toLowerCase(), N = `${E}:${w.nid || R}`, B = x(N);
    B && (S = B.serialize(S, w));
    const F = S, U = S.nss;
    return F.path = `${R || w.nid}:${U}`, w.skipEscape = !0, F;
  }
  function d(S, w) {
    const E = S;
    return E.uuid = E.nss, E.nss = void 0, !w.tolerant && (!E.uuid || !e(E.uuid)) && (E.error = E.error || "UUID is not valid."), E;
  }
  function f(S) {
    const w = S;
    return w.nss = (S.uuid || "").toLowerCase(), w;
  }
  const p = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: a,
      serialize: s
    }
  ), v = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: p.domainHost,
      parse: a,
      serialize: s
    }
  ), m = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: o,
      serialize: c
    }
  ), h = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: m.domainHost,
      parse: m.parse,
      serialize: m.serialize
    }
  ), y = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: p,
      https: v,
      ws: m,
      wss: h,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: u,
          serialize: l,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: d,
          serialize: f,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(y, null);
  function x(S) {
    return S && (y[
      /** @type {SchemeName} */
      S
    ] || y[
      /** @type {SchemeName} */
      S.toLowerCase()
    ]) || void 0;
  }
  return Vf = {
    wsIsSecure: i,
    SCHEMES: y,
    isValidSchemeName: n,
    getSchemeHandler: x
  }, Vf;
}
var Z1;
function jE() {
  if (Z1) return Fa.exports;
  Z1 = 1;
  const { normalizeIPv6: e, removeDotSegments: t, recomposeAuthority: r, normalizeComponentEncoding: n, isIPv4: i, nonSimpleDomain: a } = BE(), { SCHEMES: s, getSchemeHandler: o } = T2();
  function c(h, _) {
    return typeof h == "string" ? h = /** @type {T} */
    f(v(h, _), _) : typeof h == "object" && (h = /** @type {T} */
    v(f(h, _), _)), h;
  }
  function u(h, _, g) {
    const y = g ? Object.assign({ scheme: "null" }, g) : { scheme: "null" }, x = l(v(h, y), v(_, y), y, !0);
    return y.skipEscape = !0, f(x, y);
  }
  function l(h, _, g, y) {
    const x = {};
    return y || (h = v(f(h, g), g), _ = v(f(_, g), g)), g = g || {}, !g.tolerant && _.scheme ? (x.scheme = _.scheme, x.userinfo = _.userinfo, x.host = _.host, x.port = _.port, x.path = t(_.path || ""), x.query = _.query) : (_.userinfo !== void 0 || _.host !== void 0 || _.port !== void 0 ? (x.userinfo = _.userinfo, x.host = _.host, x.port = _.port, x.path = t(_.path || ""), x.query = _.query) : (_.path ? (_.path[0] === "/" ? x.path = t(_.path) : ((h.userinfo !== void 0 || h.host !== void 0 || h.port !== void 0) && !h.path ? x.path = "/" + _.path : h.path ? x.path = h.path.slice(0, h.path.lastIndexOf("/") + 1) + _.path : x.path = _.path, x.path = t(x.path)), x.query = _.query) : (x.path = h.path, _.query !== void 0 ? x.query = _.query : x.query = h.query), x.userinfo = h.userinfo, x.host = h.host, x.port = h.port), x.scheme = h.scheme), x.fragment = _.fragment, x;
  }
  function d(h, _, g) {
    return typeof h == "string" ? (h = unescape(h), h = f(n(v(h, g), !0), { ...g, skipEscape: !0 })) : typeof h == "object" && (h = f(n(h, !0), { ...g, skipEscape: !0 })), typeof _ == "string" ? (_ = unescape(_), _ = f(n(v(_, g), !0), { ...g, skipEscape: !0 })) : typeof _ == "object" && (_ = f(n(_, !0), { ...g, skipEscape: !0 })), h.toLowerCase() === _.toLowerCase();
  }
  function f(h, _) {
    const g = {
      host: h.host,
      scheme: h.scheme,
      userinfo: h.userinfo,
      port: h.port,
      path: h.path,
      query: h.query,
      nid: h.nid,
      nss: h.nss,
      uuid: h.uuid,
      fragment: h.fragment,
      reference: h.reference,
      resourceName: h.resourceName,
      secure: h.secure,
      error: ""
    }, y = Object.assign({}, _), x = [], S = o(y.scheme || g.scheme);
    S && S.serialize && S.serialize(g, y), g.path !== void 0 && (y.skipEscape ? g.path = unescape(g.path) : (g.path = escape(g.path), g.scheme !== void 0 && (g.path = g.path.split("%3A").join(":")))), y.reference !== "suffix" && g.scheme && x.push(g.scheme, ":");
    const w = r(g);
    if (w !== void 0 && (y.reference !== "suffix" && x.push("//"), x.push(w), g.path && g.path[0] !== "/" && x.push("/")), g.path !== void 0) {
      let E = g.path;
      !y.absolutePath && (!S || !S.absolutePath) && (E = t(E)), w === void 0 && E[0] === "/" && E[1] === "/" && (E = "/%2F" + E.slice(2)), x.push(E);
    }
    return g.query !== void 0 && x.push("?", g.query), g.fragment !== void 0 && x.push("#", g.fragment), x.join("");
  }
  const p = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function v(h, _) {
    const g = Object.assign({}, _), y = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let x = !1;
    g.reference === "suffix" && (g.scheme ? h = g.scheme + ":" + h : h = "//" + h);
    const S = h.match(p);
    if (S) {
      if (y.scheme = S[1], y.userinfo = S[3], y.host = S[4], y.port = parseInt(S[5], 10), y.path = S[6] || "", y.query = S[7], y.fragment = S[8], isNaN(y.port) && (y.port = S[5]), y.host)
        if (i(y.host) === !1) {
          const R = e(y.host);
          y.host = R.host.toLowerCase(), x = R.isIPV6;
        } else
          x = !0;
      y.scheme === void 0 && y.userinfo === void 0 && y.host === void 0 && y.port === void 0 && y.query === void 0 && !y.path ? y.reference = "same-document" : y.scheme === void 0 ? y.reference = "relative" : y.fragment === void 0 ? y.reference = "absolute" : y.reference = "uri", g.reference && g.reference !== "suffix" && g.reference !== y.reference && (y.error = y.error || "URI is not a " + g.reference + " reference.");
      const w = o(g.scheme || y.scheme);
      if (!g.unicodeSupport && (!w || !w.unicodeSupport) && y.host && (g.domainHost || w && w.domainHost) && x === !1 && a(y.host))
        try {
          y.host = URL.domainToASCII(y.host.toLowerCase());
        } catch (E) {
          y.error = y.error || "Host's domain name can not be converted to ASCII: " + E;
        }
      (!w || w && !w.skipNormalize) && (h.indexOf("%") !== -1 && (y.scheme !== void 0 && (y.scheme = unescape(y.scheme)), y.host !== void 0 && (y.host = unescape(y.host))), y.path && (y.path = escape(unescape(y.path))), y.fragment && (y.fragment = encodeURI(decodeURIComponent(y.fragment)))), w && w.parse && w.parse(y, g);
    } else
      y.error = y.error || "URI can not be parsed.";
    return y;
  }
  const m = {
    SCHEMES: s,
    normalize: c,
    resolve: u,
    resolveComponent: l,
    equal: d,
    serialize: f,
    parse: v
  };
  return Fa.exports = m, Fa.exports.default = m, Fa.exports.fastUri = m, Fa.exports;
}
var eg;
function S2() {
  if (eg) return Ls;
  eg = 1, Object.defineProperty(Ls, "__esModule", { value: !0 });
  const e = jE();
  return e.code = 'require("ajv/dist/runtime/uri").default', Ls.default = e, Ls;
}
var tg;
function A2() {
  return tg || (tg = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
    var t = cl();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return t.KeywordCxt;
    } });
    var r = Ze();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return r.CodeGen;
    } });
    const n = P0(), i = ll(), a = UE(), s = ul(), o = Ze(), c = ol(), u = Pc(), l = st(), d = x2, f = S2(), p = (X, k) => new RegExp(X, k);
    p.code = "new RegExp";
    const v = ["removeAdditional", "useDefaults", "coerceTypes"], m = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), h = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, _ = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, g = 200;
    function y(X) {
      var k, I, C, T, A, L, b, P, te, H, D, q, J, ne, ce, Ee, ge, Ge, ze, Xe, He, O, le, me, Ne;
      const _e = X.strict, $e = (k = X.code) === null || k === void 0 ? void 0 : k.optimize, Ae = $e === !0 || $e === void 0 ? 1 : $e || 0, De = (C = (I = X.code) === null || I === void 0 ? void 0 : I.regExp) !== null && C !== void 0 ? C : p, Me = (T = X.uriResolver) !== null && T !== void 0 ? T : f.default;
      return {
        strictSchema: (L = (A = X.strictSchema) !== null && A !== void 0 ? A : _e) !== null && L !== void 0 ? L : !0,
        strictNumbers: (P = (b = X.strictNumbers) !== null && b !== void 0 ? b : _e) !== null && P !== void 0 ? P : !0,
        strictTypes: (H = (te = X.strictTypes) !== null && te !== void 0 ? te : _e) !== null && H !== void 0 ? H : "log",
        strictTuples: (q = (D = X.strictTuples) !== null && D !== void 0 ? D : _e) !== null && q !== void 0 ? q : "log",
        strictRequired: (ne = (J = X.strictRequired) !== null && J !== void 0 ? J : _e) !== null && ne !== void 0 ? ne : !1,
        code: X.code ? { ...X.code, optimize: Ae, regExp: De } : { optimize: Ae, regExp: De },
        loopRequired: (ce = X.loopRequired) !== null && ce !== void 0 ? ce : g,
        loopEnum: (Ee = X.loopEnum) !== null && Ee !== void 0 ? Ee : g,
        meta: (ge = X.meta) !== null && ge !== void 0 ? ge : !0,
        messages: (Ge = X.messages) !== null && Ge !== void 0 ? Ge : !0,
        inlineRefs: (ze = X.inlineRefs) !== null && ze !== void 0 ? ze : !0,
        schemaId: (Xe = X.schemaId) !== null && Xe !== void 0 ? Xe : "$id",
        addUsedSchema: (He = X.addUsedSchema) !== null && He !== void 0 ? He : !0,
        validateSchema: (O = X.validateSchema) !== null && O !== void 0 ? O : !0,
        validateFormats: (le = X.validateFormats) !== null && le !== void 0 ? le : !0,
        unicodeRegExp: (me = X.unicodeRegExp) !== null && me !== void 0 ? me : !0,
        int32range: (Ne = X.int32range) !== null && Ne !== void 0 ? Ne : !0,
        uriResolver: Me
      };
    }
    class x {
      constructor(k = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), k = this.opts = { ...k, ...y(k) };
        const { es5: I, lines: C } = this.opts.code;
        this.scope = new o.ValueScope({ scope: {}, prefixes: m, es5: I, lines: C }), this.logger = U(k.logger);
        const T = k.validateFormats;
        k.validateFormats = !1, this.RULES = (0, a.getRules)(), S.call(this, h, k, "NOT SUPPORTED"), S.call(this, _, k, "DEPRECATED", "warn"), this._metaOpts = B.call(this), k.formats && R.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), k.keywords && N.call(this, k.keywords), typeof k.meta == "object" && this.addMetaSchema(k.meta), E.call(this), k.validateFormats = T;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: k, meta: I, schemaId: C } = this.opts;
        let T = d;
        C === "id" && (T = { ...d }, T.id = T.$id, delete T.$id), I && k && this.addMetaSchema(T, T[C], !1);
      }
      defaultMeta() {
        const { meta: k, schemaId: I } = this.opts;
        return this.opts.defaultMeta = typeof k == "object" ? k[I] || k : void 0;
      }
      validate(k, I) {
        let C;
        if (typeof k == "string") {
          if (C = this.getSchema(k), !C)
            throw new Error(`no schema with key or ref "${k}"`);
        } else
          C = this.compile(k);
        const T = C(I);
        return "$async" in C || (this.errors = C.errors), T;
      }
      compile(k, I) {
        const C = this._addSchema(k, I);
        return C.validate || this._compileSchemaEnv(C);
      }
      compileAsync(k, I) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: C } = this.opts;
        return T.call(this, k, I);
        async function T(H, D) {
          await A.call(this, H.$schema);
          const q = this._addSchema(H, D);
          return q.validate || L.call(this, q);
        }
        async function A(H) {
          H && !this.getSchema(H) && await T.call(this, { $ref: H }, !0);
        }
        async function L(H) {
          try {
            return this._compileSchemaEnv(H);
          } catch (D) {
            if (!(D instanceof i.default))
              throw D;
            return b.call(this, D), await P.call(this, D.missingSchema), L.call(this, H);
          }
        }
        function b({ missingSchema: H, missingRef: D }) {
          if (this.refs[H])
            throw new Error(`AnySchema ${H} is loaded but ${D} cannot be resolved`);
        }
        async function P(H) {
          const D = await te.call(this, H);
          this.refs[H] || await A.call(this, D.$schema), this.refs[H] || this.addSchema(D, H, I);
        }
        async function te(H) {
          const D = this._loading[H];
          if (D)
            return D;
          try {
            return await (this._loading[H] = C(H));
          } finally {
            delete this._loading[H];
          }
        }
      }
      // Adds schema to the instance
      addSchema(k, I, C, T = this.opts.validateSchema) {
        if (Array.isArray(k)) {
          for (const L of k)
            this.addSchema(L, void 0, C, T);
          return this;
        }
        let A;
        if (typeof k == "object") {
          const { schemaId: L } = this.opts;
          if (A = k[L], A !== void 0 && typeof A != "string")
            throw new Error(`schema ${L} must be string`);
        }
        return I = (0, c.normalizeId)(I || A), this._checkUnique(I), this.schemas[I] = this._addSchema(k, C, I, T, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(k, I, C = this.opts.validateSchema) {
        return this.addSchema(k, I, !0, C), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(k, I) {
        if (typeof k == "boolean")
          return !0;
        let C;
        if (C = k.$schema, C !== void 0 && typeof C != "string")
          throw new Error("$schema must be a string");
        if (C = C || this.opts.defaultMeta || this.defaultMeta(), !C)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const T = this.validate(C, k);
        if (!T && I) {
          const A = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(A);
          else
            throw new Error(A);
        }
        return T;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(k) {
        let I;
        for (; typeof (I = w.call(this, k)) == "string"; )
          k = I;
        if (I === void 0) {
          const { schemaId: C } = this.opts, T = new s.SchemaEnv({ schema: {}, schemaId: C });
          if (I = s.resolveSchema.call(this, T, k), !I)
            return;
          this.refs[k] = I;
        }
        return I.validate || this._compileSchemaEnv(I);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(k) {
        if (k instanceof RegExp)
          return this._removeAllSchemas(this.schemas, k), this._removeAllSchemas(this.refs, k), this;
        switch (typeof k) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const I = w.call(this, k);
            return typeof I == "object" && this._cache.delete(I.schema), delete this.schemas[k], delete this.refs[k], this;
          }
          case "object": {
            const I = k;
            this._cache.delete(I);
            let C = k[this.opts.schemaId];
            return C && (C = (0, c.normalizeId)(C), delete this.schemas[C], delete this.refs[C]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(k) {
        for (const I of k)
          this.addKeyword(I);
        return this;
      }
      addKeyword(k, I) {
        let C;
        if (typeof k == "string")
          C = k, typeof I == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), I.keyword = C);
        else if (typeof k == "object" && I === void 0) {
          if (I = k, C = I.keyword, Array.isArray(C) && !C.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (M.call(this, C, I), !I)
          return (0, l.eachItem)(C, (A) => V.call(this, A)), this;
        W.call(this, I);
        const T = {
          ...I,
          type: (0, u.getJSONTypes)(I.type),
          schemaType: (0, u.getJSONTypes)(I.schemaType)
        };
        return (0, l.eachItem)(C, T.type.length === 0 ? (A) => V.call(this, A, T) : (A) => T.type.forEach((L) => V.call(this, A, T, L))), this;
      }
      getKeyword(k) {
        const I = this.RULES.all[k];
        return typeof I == "object" ? I.definition : !!I;
      }
      // Remove keyword
      removeKeyword(k) {
        const { RULES: I } = this;
        delete I.keywords[k], delete I.all[k];
        for (const C of I.rules) {
          const T = C.rules.findIndex((A) => A.keyword === k);
          T >= 0 && C.rules.splice(T, 1);
        }
        return this;
      }
      // Add format
      addFormat(k, I) {
        return typeof I == "string" && (I = new RegExp(I)), this.formats[k] = I, this;
      }
      errorsText(k = this.errors, { separator: I = ", ", dataVar: C = "data" } = {}) {
        return !k || k.length === 0 ? "No errors" : k.map((T) => `${C}${T.instancePath} ${T.message}`).reduce((T, A) => T + I + A);
      }
      $dataMetaSchema(k, I) {
        const C = this.RULES.all;
        k = JSON.parse(JSON.stringify(k));
        for (const T of I) {
          const A = T.split("/").slice(1);
          let L = k;
          for (const b of A)
            L = L[b];
          for (const b in C) {
            const P = C[b];
            if (typeof P != "object")
              continue;
            const { $data: te } = P.definition, H = L[b];
            te && H && (L[b] = se(H));
          }
        }
        return k;
      }
      _removeAllSchemas(k, I) {
        for (const C in k) {
          const T = k[C];
          (!I || I.test(C)) && (typeof T == "string" ? delete k[C] : T && !T.meta && (this._cache.delete(T.schema), delete k[C]));
        }
      }
      _addSchema(k, I, C, T = this.opts.validateSchema, A = this.opts.addUsedSchema) {
        let L;
        const { schemaId: b } = this.opts;
        if (typeof k == "object")
          L = k[b];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof k != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let P = this._cache.get(k);
        if (P !== void 0)
          return P;
        C = (0, c.normalizeId)(L || C);
        const te = c.getSchemaRefs.call(this, k, C);
        return P = new s.SchemaEnv({ schema: k, schemaId: b, meta: I, baseId: C, localRefs: te }), this._cache.set(P.schema, P), A && !C.startsWith("#") && (C && this._checkUnique(C), this.refs[C] = P), T && this.validateSchema(k, !0), P;
      }
      _checkUnique(k) {
        if (this.schemas[k] || this.refs[k])
          throw new Error(`schema with key or id "${k}" already exists`);
      }
      _compileSchemaEnv(k) {
        if (k.meta ? this._compileMetaSchema(k) : s.compileSchema.call(this, k), !k.validate)
          throw new Error("ajv implementation error");
        return k.validate;
      }
      _compileMetaSchema(k) {
        const I = this.opts;
        this.opts = this._metaOpts;
        try {
          s.compileSchema.call(this, k);
        } finally {
          this.opts = I;
        }
      }
    }
    x.ValidationError = n.default, x.MissingRefError = i.default, e.default = x;
    function S(X, k, I, C = "error") {
      for (const T in X) {
        const A = T;
        A in k && this.logger[C](`${I}: option ${T}. ${X[A]}`);
      }
    }
    function w(X) {
      return X = (0, c.normalizeId)(X), this.schemas[X] || this.refs[X];
    }
    function E() {
      const X = this.opts.schemas;
      if (X)
        if (Array.isArray(X))
          this.addSchema(X);
        else
          for (const k in X)
            this.addSchema(X[k], k);
    }
    function R() {
      for (const X in this.opts.formats) {
        const k = this.opts.formats[X];
        k && this.addFormat(X, k);
      }
    }
    function N(X) {
      if (Array.isArray(X)) {
        this.addVocabulary(X);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const k in X) {
        const I = X[k];
        I.keyword || (I.keyword = k), this.addKeyword(I);
      }
    }
    function B() {
      const X = { ...this.opts };
      for (const k of v)
        delete X[k];
      return X;
    }
    const F = { log() {
    }, warn() {
    }, error() {
    } };
    function U(X) {
      if (X === !1)
        return F;
      if (X === void 0)
        return console;
      if (X.log && X.warn && X.error)
        return X;
      throw new Error("logger must implement log, warn and error methods");
    }
    const G = /^[a-z_$][a-z0-9_$:-]*$/i;
    function M(X, k) {
      const { RULES: I } = this;
      if ((0, l.eachItem)(X, (C) => {
        if (I.keywords[C])
          throw new Error(`Keyword ${C} is already defined`);
        if (!G.test(C))
          throw new Error(`Keyword ${C} has invalid name`);
      }), !!k && k.$data && !("code" in k || "validate" in k))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function V(X, k, I) {
      var C;
      const T = k?.post;
      if (I && T)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: A } = this;
      let L = T ? A.post : A.rules.find(({ type: P }) => P === I);
      if (L || (L = { type: I, rules: [] }, A.rules.push(L)), A.keywords[X] = !0, !k)
        return;
      const b = {
        keyword: X,
        definition: {
          ...k,
          type: (0, u.getJSONTypes)(k.type),
          schemaType: (0, u.getJSONTypes)(k.schemaType)
        }
      };
      k.before ? ie.call(this, L, b, k.before) : L.rules.push(b), A.all[X] = b, (C = k.implements) === null || C === void 0 || C.forEach((P) => this.addKeyword(P));
    }
    function ie(X, k, I) {
      const C = X.rules.findIndex((T) => T.keyword === I);
      C >= 0 ? X.rules.splice(C, 0, k) : (X.rules.push(k), this.logger.warn(`rule ${I} is not defined`));
    }
    function W(X) {
      let { metaSchema: k } = X;
      k !== void 0 && (X.$data && this.opts.$data && (k = se(k)), X.validateSchema = this.compile(k, !0));
    }
    const ae = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function se(X) {
      return { anyOf: [X, ae] };
    }
  })(Df)), Df;
}
var Ms = {}, Us = {}, qs = {}, rg;
function R2() {
  if (rg) return qs;
  rg = 1, Object.defineProperty(qs, "__esModule", { value: !0 });
  const e = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return qs.default = e, qs;
}
var Dn = {}, ng;
function C0() {
  if (ng) return Dn;
  ng = 1, Object.defineProperty(Dn, "__esModule", { value: !0 }), Dn.callRef = Dn.getValidate = void 0;
  const e = ll(), t = Zr(), r = Ze(), n = Qr(), i = ul(), a = st(), s = {
    keyword: "$ref",
    schemaType: "string",
    code(u) {
      const { gen: l, schema: d, it: f } = u, { baseId: p, schemaEnv: v, validateName: m, opts: h, self: _ } = f, { root: g } = v;
      if ((d === "#" || d === "#/") && p === g.baseId)
        return x();
      const y = i.resolveRef.call(_, g, p, d);
      if (y === void 0)
        throw new e.default(f.opts.uriResolver, p, d);
      if (y instanceof i.SchemaEnv)
        return S(y);
      return w(y);
      function x() {
        if (v === g)
          return c(u, m, v, v.$async);
        const E = l.scopeValue("root", { ref: g });
        return c(u, (0, r._)`${E}.validate`, g, g.$async);
      }
      function S(E) {
        const R = o(u, E);
        c(u, R, E, E.$async);
      }
      function w(E) {
        const R = l.scopeValue("schema", h.code.source === !0 ? { ref: E, code: (0, r.stringify)(E) } : { ref: E }), N = l.name("valid"), B = u.subschema({
          schema: E,
          dataTypes: [],
          schemaPath: r.nil,
          topSchemaRef: R,
          errSchemaPath: d
        }, N);
        u.mergeEvaluated(B), u.ok(N);
      }
    }
  };
  function o(u, l) {
    const { gen: d } = u;
    return l.validate ? d.scopeValue("validate", { ref: l.validate }) : (0, r._)`${d.scopeValue("wrapper", { ref: l })}.validate`;
  }
  Dn.getValidate = o;
  function c(u, l, d, f) {
    const { gen: p, it: v } = u, { allErrors: m, schemaEnv: h, opts: _ } = v, g = _.passContext ? n.default.this : r.nil;
    f ? y() : x();
    function y() {
      if (!h.$async)
        throw new Error("async schema referenced by sync schema");
      const E = p.let("valid");
      p.try(() => {
        p.code((0, r._)`await ${(0, t.callValidateCode)(u, l, g)}`), w(l), m || p.assign(E, !0);
      }, (R) => {
        p.if((0, r._)`!(${R} instanceof ${v.ValidationError})`, () => p.throw(R)), S(R), m || p.assign(E, !1);
      }), u.ok(E);
    }
    function x() {
      u.result((0, t.callValidateCode)(u, l, g), () => w(l), () => S(l));
    }
    function S(E) {
      const R = (0, r._)`${E}.errors`;
      p.assign(n.default.vErrors, (0, r._)`${n.default.vErrors} === null ? ${R} : ${n.default.vErrors}.concat(${R})`), p.assign(n.default.errors, (0, r._)`${n.default.vErrors}.length`);
    }
    function w(E) {
      var R;
      if (!v.opts.unevaluated)
        return;
      const N = (R = d?.validate) === null || R === void 0 ? void 0 : R.evaluated;
      if (v.props !== !0)
        if (N && !N.dynamicProps)
          N.props !== void 0 && (v.props = a.mergeEvaluated.props(p, N.props, v.props));
        else {
          const B = p.var("props", (0, r._)`${E}.evaluated.props`);
          v.props = a.mergeEvaluated.props(p, B, v.props, r.Name);
        }
      if (v.items !== !0)
        if (N && !N.dynamicItems)
          N.items !== void 0 && (v.items = a.mergeEvaluated.items(p, N.items, v.items));
        else {
          const B = p.var("items", (0, r._)`${E}.evaluated.items`);
          v.items = a.mergeEvaluated.items(p, B, v.items, r.Name);
        }
    }
  }
  return Dn.callRef = c, Dn.default = s, Dn;
}
var ig;
function $2() {
  if (ig) return Us;
  ig = 1, Object.defineProperty(Us, "__esModule", { value: !0 });
  const e = R2(), t = C0(), r = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    e.default,
    t.default
  ];
  return Us.default = r, Us;
}
var Bs = {}, js = {}, ag;
function O2() {
  if (ag) return js;
  ag = 1, Object.defineProperty(js, "__esModule", { value: !0 });
  const e = Ze(), t = e.operators, r = {
    maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
    minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
    exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
    exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
  }, n = {
    message: ({ keyword: a, schemaCode: s }) => (0, e.str)`must be ${r[a].okStr} ${s}`,
    params: ({ keyword: a, schemaCode: s }) => (0, e._)`{comparison: ${r[a].okStr}, limit: ${s}}`
  }, i = {
    keyword: Object.keys(r),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: n,
    code(a) {
      const { keyword: s, data: o, schemaCode: c } = a;
      a.fail$data((0, e._)`${o} ${r[s].fail} ${c} || isNaN(${o})`);
    }
  };
  return js.default = i, js;
}
var Vs = {}, sg;
function N2() {
  if (sg) return Vs;
  sg = 1, Object.defineProperty(Vs, "__esModule", { value: !0 });
  const e = Ze(), r = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, e._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: i, data: a, schemaCode: s, it: o } = n, c = o.opts.multipleOfPrecision, u = i.let("res"), l = c ? (0, e._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${c}` : (0, e._)`${u} !== parseInt(${u})`;
      n.fail$data((0, e._)`(${s} === 0 || (${u} = ${a}/${s}, ${l}))`);
    }
  };
  return Vs.default = r, Vs;
}
var Hs = {}, Gs = {}, og;
function P2() {
  if (og) return Gs;
  og = 1, Object.defineProperty(Gs, "__esModule", { value: !0 });
  function e(t) {
    const r = t.length;
    let n = 0, i = 0, a;
    for (; i < r; )
      n++, a = t.charCodeAt(i++), a >= 55296 && a <= 56319 && i < r && (a = t.charCodeAt(i), (a & 64512) === 56320 && i++);
    return n;
  }
  return Gs.default = e, e.code = 'require("ajv/dist/runtime/ucs2length").default', Gs;
}
var cg;
function C2() {
  if (cg) return Hs;
  cg = 1, Object.defineProperty(Hs, "__esModule", { value: !0 });
  const e = Ze(), t = st(), r = P2(), i = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: a, schemaCode: s }) {
        const o = a === "maxLength" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${o} than ${s} characters`;
      },
      params: ({ schemaCode: a }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { keyword: s, data: o, schemaCode: c, it: u } = a, l = s === "maxLength" ? e.operators.GT : e.operators.LT, d = u.opts.unicode === !1 ? (0, e._)`${o}.length` : (0, e._)`${(0, t.useFunc)(a.gen, r.default)}(${o})`;
      a.fail$data((0, e._)`${d} ${l} ${c}`);
    }
  };
  return Hs.default = i, Hs;
}
var zs = {}, lg;
function I2() {
  if (lg) return zs;
  lg = 1, Object.defineProperty(zs, "__esModule", { value: !0 });
  const e = Zr(), t = Ze(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: i }) => (0, t.str)`must match pattern "${i}"`,
      params: ({ schemaCode: i }) => (0, t._)`{pattern: ${i}}`
    },
    code(i) {
      const { data: a, $data: s, schema: o, schemaCode: c, it: u } = i, l = u.opts.unicodeRegExp ? "u" : "", d = s ? (0, t._)`(new RegExp(${c}, ${l}))` : (0, e.usePattern)(i, o);
      i.fail$data((0, t._)`!${d}.test(${a})`);
    }
  };
  return zs.default = n, zs;
}
var Ws = {}, ug;
function b2() {
  if (ug) return Ws;
  ug = 1, Object.defineProperty(Ws, "__esModule", { value: !0 });
  const e = Ze(), r = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: i }) {
        const a = n === "maxProperties" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${i} properties`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: i, data: a, schemaCode: s } = n, o = i === "maxProperties" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`Object.keys(${a}).length ${o} ${s}`);
    }
  };
  return Ws.default = r, Ws;
}
var Xs = {}, fg;
function F2() {
  if (fg) return Xs;
  fg = 1, Object.defineProperty(Xs, "__esModule", { value: !0 });
  const e = Zr(), t = Ze(), r = st(), i = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: a } }) => (0, t.str)`must have required property '${a}'`,
      params: ({ params: { missingProperty: a } }) => (0, t._)`{missingProperty: ${a}}`
    },
    code(a) {
      const { gen: s, schema: o, schemaCode: c, data: u, $data: l, it: d } = a, { opts: f } = d;
      if (!l && o.length === 0)
        return;
      const p = o.length >= f.loopRequired;
      if (d.allErrors ? v() : m(), f.strictRequired) {
        const g = a.parentSchema.properties, { definedProperties: y } = a.it;
        for (const x of o)
          if (g?.[x] === void 0 && !y.has(x)) {
            const S = d.schemaEnv.baseId + d.errSchemaPath, w = `required property "${x}" is not defined at "${S}" (strictRequired)`;
            (0, r.checkStrictMode)(d, w, d.opts.strictRequired);
          }
      }
      function v() {
        if (p || l)
          a.block$data(t.nil, h);
        else
          for (const g of o)
            (0, e.checkReportMissingProp)(a, g);
      }
      function m() {
        const g = s.let("missing");
        if (p || l) {
          const y = s.let("valid", !0);
          a.block$data(y, () => _(g, y)), a.ok(y);
        } else
          s.if((0, e.checkMissingProp)(a, o, g)), (0, e.reportMissingProp)(a, g), s.else();
      }
      function h() {
        s.forOf("prop", c, (g) => {
          a.setParams({ missingProperty: g }), s.if((0, e.noPropertyInData)(s, u, g, f.ownProperties), () => a.error());
        });
      }
      function _(g, y) {
        a.setParams({ missingProperty: g }), s.forOf(g, c, () => {
          s.assign(y, (0, e.propertyInData)(s, u, g, f.ownProperties)), s.if((0, t.not)(y), () => {
            a.error(), s.break();
          });
        }, t.nil);
      }
    }
  };
  return Xs.default = i, Xs;
}
var Ks = {}, dg;
function D2() {
  if (dg) return Ks;
  dg = 1, Object.defineProperty(Ks, "__esModule", { value: !0 });
  const e = Ze(), r = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: i }) {
        const a = n === "maxItems" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${i} items`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: i, data: a, schemaCode: s } = n, o = i === "maxItems" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`${a}.length ${o} ${s}`);
    }
  };
  return Ks.default = r, Ks;
}
var Ys = {}, Js = {}, hg;
function I0() {
  if (hg) return Js;
  hg = 1, Object.defineProperty(Js, "__esModule", { value: !0 });
  const e = sl();
  return e.code = 'require("ajv/dist/runtime/equal").default', Js.default = e, Js;
}
var pg;
function k2() {
  if (pg) return Ys;
  pg = 1, Object.defineProperty(Ys, "__esModule", { value: !0 });
  const e = Pc(), t = Ze(), r = st(), n = I0(), a = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: s, j: o } }) => (0, t.str)`must NOT have duplicate items (items ## ${o} and ${s} are identical)`,
      params: ({ params: { i: s, j: o } }) => (0, t._)`{i: ${s}, j: ${o}}`
    },
    code(s) {
      const { gen: o, data: c, $data: u, schema: l, parentSchema: d, schemaCode: f, it: p } = s;
      if (!u && !l)
        return;
      const v = o.let("valid"), m = d.items ? (0, e.getSchemaTypes)(d.items) : [];
      s.block$data(v, h, (0, t._)`${f} === false`), s.ok(v);
      function h() {
        const x = o.let("i", (0, t._)`${c}.length`), S = o.let("j");
        s.setParams({ i: x, j: S }), o.assign(v, !0), o.if((0, t._)`${x} > 1`, () => (_() ? g : y)(x, S));
      }
      function _() {
        return m.length > 0 && !m.some((x) => x === "object" || x === "array");
      }
      function g(x, S) {
        const w = o.name("item"), E = (0, e.checkDataTypes)(m, w, p.opts.strictNumbers, e.DataType.Wrong), R = o.const("indices", (0, t._)`{}`);
        o.for((0, t._)`;${x}--;`, () => {
          o.let(w, (0, t._)`${c}[${x}]`), o.if(E, (0, t._)`continue`), m.length > 1 && o.if((0, t._)`typeof ${w} == "string"`, (0, t._)`${w} += "_"`), o.if((0, t._)`typeof ${R}[${w}] == "number"`, () => {
            o.assign(S, (0, t._)`${R}[${w}]`), s.error(), o.assign(v, !1).break();
          }).code((0, t._)`${R}[${w}] = ${x}`);
        });
      }
      function y(x, S) {
        const w = (0, r.useFunc)(o, n.default), E = o.name("outer");
        o.label(E).for((0, t._)`;${x}--;`, () => o.for((0, t._)`${S} = ${x}; ${S}--;`, () => o.if((0, t._)`${w}(${c}[${x}], ${c}[${S}])`, () => {
          s.error(), o.assign(v, !1).break(E);
        })));
      }
    }
  };
  return Ys.default = a, Ys;
}
var Qs = {}, mg;
function L2() {
  if (mg) return Qs;
  mg = 1, Object.defineProperty(Qs, "__esModule", { value: !0 });
  const e = Ze(), t = st(), r = I0(), i = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValue: ${a}}`
    },
    code(a) {
      const { gen: s, data: o, $data: c, schemaCode: u, schema: l } = a;
      c || l && typeof l == "object" ? a.fail$data((0, e._)`!${(0, t.useFunc)(s, r.default)}(${o}, ${u})`) : a.fail((0, e._)`${l} !== ${o}`);
    }
  };
  return Qs.default = i, Qs;
}
var Zs = {}, gg;
function M2() {
  if (gg) return Zs;
  gg = 1, Object.defineProperty(Zs, "__esModule", { value: !0 });
  const e = Ze(), t = st(), r = I0(), i = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValues: ${a}}`
    },
    code(a) {
      const { gen: s, data: o, $data: c, schema: u, schemaCode: l, it: d } = a;
      if (!c && u.length === 0)
        throw new Error("enum must have non-empty array");
      const f = u.length >= d.opts.loopEnum;
      let p;
      const v = () => p ?? (p = (0, t.useFunc)(s, r.default));
      let m;
      if (f || c)
        m = s.let("valid"), a.block$data(m, h);
      else {
        if (!Array.isArray(u))
          throw new Error("ajv implementation error");
        const g = s.const("vSchema", l);
        m = (0, e.or)(...u.map((y, x) => _(g, x)));
      }
      a.pass(m);
      function h() {
        s.assign(m, !1), s.forOf("v", l, (g) => s.if((0, e._)`${v()}(${o}, ${g})`, () => s.assign(m, !0).break()));
      }
      function _(g, y) {
        const x = u[y];
        return typeof x == "object" && x !== null ? (0, e._)`${v()}(${o}, ${g}[${y}])` : (0, e._)`${o} === ${x}`;
      }
    }
  };
  return Zs.default = i, Zs;
}
var vg;
function U2() {
  if (vg) return Bs;
  vg = 1, Object.defineProperty(Bs, "__esModule", { value: !0 });
  const e = O2(), t = N2(), r = C2(), n = I2(), i = b2(), a = F2(), s = D2(), o = k2(), c = L2(), u = M2(), l = [
    // number
    e.default,
    t.default,
    // string
    r.default,
    n.default,
    // object
    i.default,
    a.default,
    // array
    s.default,
    o.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    c.default,
    u.default
  ];
  return Bs.default = l, Bs;
}
var eo = {}, Ci = {}, _g;
function VE() {
  if (_g) return Ci;
  _g = 1, Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.validateAdditionalItems = void 0;
  const e = Ze(), t = st(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: a } }) => (0, e.str)`must NOT have more than ${a} items`,
      params: ({ params: { len: a } }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { parentSchema: s, it: o } = a, { items: c } = s;
      if (!Array.isArray(c)) {
        (0, t.checkStrictMode)(o, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      i(a, c);
    }
  };
  function i(a, s) {
    const { gen: o, schema: c, data: u, keyword: l, it: d } = a;
    d.items = !0;
    const f = o.const("len", (0, e._)`${u}.length`);
    if (c === !1)
      a.setParams({ len: s.length }), a.pass((0, e._)`${f} <= ${s.length}`);
    else if (typeof c == "object" && !(0, t.alwaysValidSchema)(d, c)) {
      const v = o.var("valid", (0, e._)`${f} <= ${s.length}`);
      o.if((0, e.not)(v), () => p(v)), a.ok(v);
    }
    function p(v) {
      o.forRange("i", s.length, f, (m) => {
        a.subschema({ keyword: l, dataProp: m, dataPropType: t.Type.Num }, v), d.allErrors || o.if((0, e.not)(v), () => o.break());
      });
    }
  }
  return Ci.validateAdditionalItems = i, Ci.default = n, Ci;
}
var to = {}, Ii = {}, yg;
function HE() {
  if (yg) return Ii;
  yg = 1, Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.validateTuple = void 0;
  const e = Ze(), t = st(), r = Zr(), n = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(a) {
      const { schema: s, it: o } = a;
      if (Array.isArray(s))
        return i(a, "additionalItems", s);
      o.items = !0, !(0, t.alwaysValidSchema)(o, s) && a.ok((0, r.validateArray)(a));
    }
  };
  function i(a, s, o = a.schema) {
    const { gen: c, parentSchema: u, data: l, keyword: d, it: f } = a;
    m(u), f.opts.unevaluated && o.length && f.items !== !0 && (f.items = t.mergeEvaluated.items(c, o.length, f.items));
    const p = c.name("valid"), v = c.const("len", (0, e._)`${l}.length`);
    o.forEach((h, _) => {
      (0, t.alwaysValidSchema)(f, h) || (c.if((0, e._)`${v} > ${_}`, () => a.subschema({
        keyword: d,
        schemaProp: _,
        dataProp: _
      }, p)), a.ok(p));
    });
    function m(h) {
      const { opts: _, errSchemaPath: g } = f, y = o.length, x = y === h.minItems && (y === h.maxItems || h[s] === !1);
      if (_.strictTuples && !x) {
        const S = `"${d}" is ${y}-tuple, but minItems or maxItems/${s} are not specified or different at path "${g}"`;
        (0, t.checkStrictMode)(f, S, _.strictTuples);
      }
    }
  }
  return Ii.validateTuple = i, Ii.default = n, Ii;
}
var Eg;
function q2() {
  if (Eg) return to;
  Eg = 1, Object.defineProperty(to, "__esModule", { value: !0 });
  const e = HE(), t = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (r) => (0, e.validateTuple)(r, "items")
  };
  return to.default = t, to;
}
var ro = {}, wg;
function B2() {
  if (wg) return ro;
  wg = 1, Object.defineProperty(ro, "__esModule", { value: !0 });
  const e = Ze(), t = st(), r = Zr(), n = VE(), a = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: s } }) => (0, e.str)`must NOT have more than ${s} items`,
      params: ({ params: { len: s } }) => (0, e._)`{limit: ${s}}`
    },
    code(s) {
      const { schema: o, parentSchema: c, it: u } = s, { prefixItems: l } = c;
      u.items = !0, !(0, t.alwaysValidSchema)(u, o) && (l ? (0, n.validateAdditionalItems)(s, l) : s.ok((0, r.validateArray)(s)));
    }
  };
  return ro.default = a, ro;
}
var no = {}, xg;
function j2() {
  if (xg) return no;
  xg = 1, Object.defineProperty(no, "__esModule", { value: !0 });
  const e = Ze(), t = st(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: i, max: a } }) => a === void 0 ? (0, e.str)`must contain at least ${i} valid item(s)` : (0, e.str)`must contain at least ${i} and no more than ${a} valid item(s)`,
      params: ({ params: { min: i, max: a } }) => a === void 0 ? (0, e._)`{minContains: ${i}}` : (0, e._)`{minContains: ${i}, maxContains: ${a}}`
    },
    code(i) {
      const { gen: a, schema: s, parentSchema: o, data: c, it: u } = i;
      let l, d;
      const { minContains: f, maxContains: p } = o;
      u.opts.next ? (l = f === void 0 ? 1 : f, d = p) : l = 1;
      const v = a.const("len", (0, e._)`${c}.length`);
      if (i.setParams({ min: l, max: d }), d === void 0 && l === 0) {
        (0, t.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (d !== void 0 && l > d) {
        (0, t.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), i.fail();
        return;
      }
      if ((0, t.alwaysValidSchema)(u, s)) {
        let y = (0, e._)`${v} >= ${l}`;
        d !== void 0 && (y = (0, e._)`${y} && ${v} <= ${d}`), i.pass(y);
        return;
      }
      u.items = !0;
      const m = a.name("valid");
      d === void 0 && l === 1 ? _(m, () => a.if(m, () => a.break())) : l === 0 ? (a.let(m, !0), d !== void 0 && a.if((0, e._)`${c}.length > 0`, h)) : (a.let(m, !1), h()), i.result(m, () => i.reset());
      function h() {
        const y = a.name("_valid"), x = a.let("count", 0);
        _(y, () => a.if(y, () => g(x)));
      }
      function _(y, x) {
        a.forRange("i", 0, v, (S) => {
          i.subschema({
            keyword: "contains",
            dataProp: S,
            dataPropType: t.Type.Num,
            compositeRule: !0
          }, y), x();
        });
      }
      function g(y) {
        a.code((0, e._)`${y}++`), d === void 0 ? a.if((0, e._)`${y} >= ${l}`, () => a.assign(m, !0).break()) : (a.if((0, e._)`${y} > ${d}`, () => a.assign(m, !1).break()), l === 1 ? a.assign(m, !0) : a.if((0, e._)`${y} >= ${l}`, () => a.assign(m, !0)));
      }
    }
  };
  return no.default = n, no;
}
var Hf = {}, Tg;
function b0() {
  return Tg || (Tg = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
    const t = Ze(), r = st(), n = Zr();
    e.error = {
      message: ({ params: { property: c, depsCount: u, deps: l } }) => {
        const d = u === 1 ? "property" : "properties";
        return (0, t.str)`must have ${d} ${l} when property ${c} is present`;
      },
      params: ({ params: { property: c, depsCount: u, deps: l, missingProperty: d } }) => (0, t._)`{property: ${c},
    missingProperty: ${d},
    depsCount: ${u},
    deps: ${l}}`
      // TODO change to reference
    };
    const i = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: e.error,
      code(c) {
        const [u, l] = a(c);
        s(c, u), o(c, l);
      }
    };
    function a({ schema: c }) {
      const u = {}, l = {};
      for (const d in c) {
        if (d === "__proto__")
          continue;
        const f = Array.isArray(c[d]) ? u : l;
        f[d] = c[d];
      }
      return [u, l];
    }
    function s(c, u = c.schema) {
      const { gen: l, data: d, it: f } = c;
      if (Object.keys(u).length === 0)
        return;
      const p = l.let("missing");
      for (const v in u) {
        const m = u[v];
        if (m.length === 0)
          continue;
        const h = (0, n.propertyInData)(l, d, v, f.opts.ownProperties);
        c.setParams({
          property: v,
          depsCount: m.length,
          deps: m.join(", ")
        }), f.allErrors ? l.if(h, () => {
          for (const _ of m)
            (0, n.checkReportMissingProp)(c, _);
        }) : (l.if((0, t._)`${h} && (${(0, n.checkMissingProp)(c, m, p)})`), (0, n.reportMissingProp)(c, p), l.else());
      }
    }
    e.validatePropertyDeps = s;
    function o(c, u = c.schema) {
      const { gen: l, data: d, keyword: f, it: p } = c, v = l.name("valid");
      for (const m in u)
        (0, r.alwaysValidSchema)(p, u[m]) || (l.if(
          (0, n.propertyInData)(l, d, m, p.opts.ownProperties),
          () => {
            const h = c.subschema({ keyword: f, schemaProp: m }, v);
            c.mergeValidEvaluated(h, v);
          },
          () => l.var(v, !0)
          // TODO var
        ), c.ok(v));
    }
    e.validateSchemaDeps = o, e.default = i;
  })(Hf)), Hf;
}
var io = {}, Sg;
function V2() {
  if (Sg) return io;
  Sg = 1, Object.defineProperty(io, "__esModule", { value: !0 });
  const e = Ze(), t = st(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: i }) => (0, e._)`{propertyName: ${i.propertyName}}`
    },
    code(i) {
      const { gen: a, schema: s, data: o, it: c } = i;
      if ((0, t.alwaysValidSchema)(c, s))
        return;
      const u = a.name("valid");
      a.forIn("key", o, (l) => {
        i.setParams({ propertyName: l }), i.subschema({
          keyword: "propertyNames",
          data: l,
          dataTypes: ["string"],
          propertyName: l,
          compositeRule: !0
        }, u), a.if((0, e.not)(u), () => {
          i.error(!0), c.allErrors || a.break();
        });
      }), i.ok(u);
    }
  };
  return io.default = n, io;
}
var ao = {}, Ag;
function GE() {
  if (Ag) return ao;
  Ag = 1, Object.defineProperty(ao, "__esModule", { value: !0 });
  const e = Zr(), t = Ze(), r = Qr(), n = st(), a = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: s }) => (0, t._)`{additionalProperty: ${s.additionalProperty}}`
    },
    code(s) {
      const { gen: o, schema: c, parentSchema: u, data: l, errsCount: d, it: f } = s;
      if (!d)
        throw new Error("ajv implementation error");
      const { allErrors: p, opts: v } = f;
      if (f.props = !0, v.removeAdditional !== "all" && (0, n.alwaysValidSchema)(f, c))
        return;
      const m = (0, e.allSchemaProperties)(u.properties), h = (0, e.allSchemaProperties)(u.patternProperties);
      _(), s.ok((0, t._)`${d} === ${r.default.errors}`);
      function _() {
        o.forIn("key", l, (w) => {
          !m.length && !h.length ? x(w) : o.if(g(w), () => x(w));
        });
      }
      function g(w) {
        let E;
        if (m.length > 8) {
          const R = (0, n.schemaRefOrVal)(f, u.properties, "properties");
          E = (0, e.isOwnProperty)(o, R, w);
        } else m.length ? E = (0, t.or)(...m.map((R) => (0, t._)`${w} === ${R}`)) : E = t.nil;
        return h.length && (E = (0, t.or)(E, ...h.map((R) => (0, t._)`${(0, e.usePattern)(s, R)}.test(${w})`))), (0, t.not)(E);
      }
      function y(w) {
        o.code((0, t._)`delete ${l}[${w}]`);
      }
      function x(w) {
        if (v.removeAdditional === "all" || v.removeAdditional && c === !1) {
          y(w);
          return;
        }
        if (c === !1) {
          s.setParams({ additionalProperty: w }), s.error(), p || o.break();
          return;
        }
        if (typeof c == "object" && !(0, n.alwaysValidSchema)(f, c)) {
          const E = o.name("valid");
          v.removeAdditional === "failing" ? (S(w, E, !1), o.if((0, t.not)(E), () => {
            s.reset(), y(w);
          })) : (S(w, E), p || o.if((0, t.not)(E), () => o.break()));
        }
      }
      function S(w, E, R) {
        const N = {
          keyword: "additionalProperties",
          dataProp: w,
          dataPropType: n.Type.Str
        };
        R === !1 && Object.assign(N, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), s.subschema(N, E);
      }
    }
  };
  return ao.default = a, ao;
}
var so = {}, Rg;
function H2() {
  if (Rg) return so;
  Rg = 1, Object.defineProperty(so, "__esModule", { value: !0 });
  const e = cl(), t = Zr(), r = st(), n = GE(), i = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(a) {
      const { gen: s, schema: o, parentSchema: c, data: u, it: l } = a;
      l.opts.removeAdditional === "all" && c.additionalProperties === void 0 && n.default.code(new e.KeywordCxt(l, n.default, "additionalProperties"));
      const d = (0, t.allSchemaProperties)(o);
      for (const h of d)
        l.definedProperties.add(h);
      l.opts.unevaluated && d.length && l.props !== !0 && (l.props = r.mergeEvaluated.props(s, (0, r.toHash)(d), l.props));
      const f = d.filter((h) => !(0, r.alwaysValidSchema)(l, o[h]));
      if (f.length === 0)
        return;
      const p = s.name("valid");
      for (const h of f)
        v(h) ? m(h) : (s.if((0, t.propertyInData)(s, u, h, l.opts.ownProperties)), m(h), l.allErrors || s.else().var(p, !0), s.endIf()), a.it.definedProperties.add(h), a.ok(p);
      function v(h) {
        return l.opts.useDefaults && !l.compositeRule && o[h].default !== void 0;
      }
      function m(h) {
        a.subschema({
          keyword: "properties",
          schemaProp: h,
          dataProp: h
        }, p);
      }
    }
  };
  return so.default = i, so;
}
var oo = {}, $g;
function G2() {
  if ($g) return oo;
  $g = 1, Object.defineProperty(oo, "__esModule", { value: !0 });
  const e = Zr(), t = Ze(), r = st(), n = st(), i = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(a) {
      const { gen: s, schema: o, data: c, parentSchema: u, it: l } = a, { opts: d } = l, f = (0, e.allSchemaProperties)(o), p = f.filter((x) => (0, r.alwaysValidSchema)(l, o[x]));
      if (f.length === 0 || p.length === f.length && (!l.opts.unevaluated || l.props === !0))
        return;
      const v = d.strictSchema && !d.allowMatchingProperties && u.properties, m = s.name("valid");
      l.props !== !0 && !(l.props instanceof t.Name) && (l.props = (0, n.evaluatedPropsToName)(s, l.props));
      const { props: h } = l;
      _();
      function _() {
        for (const x of f)
          v && g(x), l.allErrors ? y(x) : (s.var(m, !0), y(x), s.if(m));
      }
      function g(x) {
        for (const S in v)
          new RegExp(x).test(S) && (0, r.checkStrictMode)(l, `property ${S} matches pattern ${x} (use allowMatchingProperties)`);
      }
      function y(x) {
        s.forIn("key", c, (S) => {
          s.if((0, t._)`${(0, e.usePattern)(a, x)}.test(${S})`, () => {
            const w = p.includes(x);
            w || a.subschema({
              keyword: "patternProperties",
              schemaProp: x,
              dataProp: S,
              dataPropType: n.Type.Str
            }, m), l.opts.unevaluated && h !== !0 ? s.assign((0, t._)`${h}[${S}]`, !0) : !w && !l.allErrors && s.if((0, t.not)(m), () => s.break());
          });
        });
      }
    }
  };
  return oo.default = i, oo;
}
var co = {}, Og;
function z2() {
  if (Og) return co;
  Og = 1, Object.defineProperty(co, "__esModule", { value: !0 });
  const e = st(), t = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(r) {
      const { gen: n, schema: i, it: a } = r;
      if ((0, e.alwaysValidSchema)(a, i)) {
        r.fail();
        return;
      }
      const s = n.name("valid");
      r.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, s), r.failResult(s, () => r.reset(), () => r.error());
    },
    error: { message: "must NOT be valid" }
  };
  return co.default = t, co;
}
var lo = {}, Ng;
function W2() {
  if (Ng) return lo;
  Ng = 1, Object.defineProperty(lo, "__esModule", { value: !0 });
  const t = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: Zr().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return lo.default = t, lo;
}
var uo = {}, Pg;
function X2() {
  if (Pg) return uo;
  Pg = 1, Object.defineProperty(uo, "__esModule", { value: !0 });
  const e = Ze(), t = st(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: i }) => (0, e._)`{passingSchemas: ${i.passing}}`
    },
    code(i) {
      const { gen: a, schema: s, parentSchema: o, it: c } = i;
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      if (c.opts.discriminator && o.discriminator)
        return;
      const u = s, l = a.let("valid", !1), d = a.let("passing", null), f = a.name("_valid");
      i.setParams({ passing: d }), a.block(p), i.result(l, () => i.reset(), () => i.error(!0));
      function p() {
        u.forEach((v, m) => {
          let h;
          (0, t.alwaysValidSchema)(c, v) ? a.var(f, !0) : h = i.subschema({
            keyword: "oneOf",
            schemaProp: m,
            compositeRule: !0
          }, f), m > 0 && a.if((0, e._)`${f} && ${l}`).assign(l, !1).assign(d, (0, e._)`[${d}, ${m}]`).else(), a.if(f, () => {
            a.assign(l, !0), a.assign(d, m), h && i.mergeEvaluated(h, e.Name);
          });
        });
      }
    }
  };
  return uo.default = n, uo;
}
var fo = {}, Cg;
function K2() {
  if (Cg) return fo;
  Cg = 1, Object.defineProperty(fo, "__esModule", { value: !0 });
  const e = st(), t = {
    keyword: "allOf",
    schemaType: "array",
    code(r) {
      const { gen: n, schema: i, it: a } = r;
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const s = n.name("valid");
      i.forEach((o, c) => {
        if ((0, e.alwaysValidSchema)(a, o))
          return;
        const u = r.subschema({ keyword: "allOf", schemaProp: c }, s);
        r.ok(s), r.mergeEvaluated(u);
      });
    }
  };
  return fo.default = t, fo;
}
var ho = {}, Ig;
function Y2() {
  if (Ig) return ho;
  Ig = 1, Object.defineProperty(ho, "__esModule", { value: !0 });
  const e = Ze(), t = st(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: a }) => (0, e.str)`must match "${a.ifClause}" schema`,
      params: ({ params: a }) => (0, e._)`{failingKeyword: ${a.ifClause}}`
    },
    code(a) {
      const { gen: s, parentSchema: o, it: c } = a;
      o.then === void 0 && o.else === void 0 && (0, t.checkStrictMode)(c, '"if" without "then" and "else" is ignored');
      const u = i(c, "then"), l = i(c, "else");
      if (!u && !l)
        return;
      const d = s.let("valid", !0), f = s.name("_valid");
      if (p(), a.reset(), u && l) {
        const m = s.let("ifClause");
        a.setParams({ ifClause: m }), s.if(f, v("then", m), v("else", m));
      } else u ? s.if(f, v("then")) : s.if((0, e.not)(f), v("else"));
      a.pass(d, () => a.error(!0));
      function p() {
        const m = a.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, f);
        a.mergeEvaluated(m);
      }
      function v(m, h) {
        return () => {
          const _ = a.subschema({ keyword: m }, f);
          s.assign(d, f), a.mergeValidEvaluated(_, d), h ? s.assign(h, (0, e._)`${m}`) : a.setParams({ ifClause: m });
        };
      }
    }
  };
  function i(a, s) {
    const o = a.schema[s];
    return o !== void 0 && !(0, t.alwaysValidSchema)(a, o);
  }
  return ho.default = n, ho;
}
var po = {}, bg;
function J2() {
  if (bg) return po;
  bg = 1, Object.defineProperty(po, "__esModule", { value: !0 });
  const e = st(), t = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: r, parentSchema: n, it: i }) {
      n.if === void 0 && (0, e.checkStrictMode)(i, `"${r}" without "if" is ignored`);
    }
  };
  return po.default = t, po;
}
var Fg;
function Q2() {
  if (Fg) return eo;
  Fg = 1, Object.defineProperty(eo, "__esModule", { value: !0 });
  const e = VE(), t = q2(), r = HE(), n = B2(), i = j2(), a = b0(), s = V2(), o = GE(), c = H2(), u = G2(), l = z2(), d = W2(), f = X2(), p = K2(), v = Y2(), m = J2();
  function h(_ = !1) {
    const g = [
      // any
      l.default,
      d.default,
      f.default,
      p.default,
      v.default,
      m.default,
      // object
      s.default,
      o.default,
      a.default,
      c.default,
      u.default
    ];
    return _ ? g.push(t.default, n.default) : g.push(e.default, r.default), g.push(i.default), g;
  }
  return eo.default = h, eo;
}
var mo = {}, bi = {}, Dg;
function zE() {
  if (Dg) return bi;
  Dg = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.dynamicAnchor = void 0;
  const e = Ze(), t = Qr(), r = ul(), n = C0(), i = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (o) => a(o, o.schema)
  };
  function a(o, c) {
    const { gen: u, it: l } = o;
    l.schemaEnv.root.dynamicAnchors[c] = !0;
    const d = (0, e._)`${t.default.dynamicAnchors}${(0, e.getProperty)(c)}`, f = l.errSchemaPath === "#" ? l.validateName : s(o);
    u.if((0, e._)`!${d}`, () => u.assign(d, f));
  }
  bi.dynamicAnchor = a;
  function s(o) {
    const { schemaEnv: c, schema: u, self: l } = o.it, { root: d, baseId: f, localRefs: p, meta: v } = c.root, { schemaId: m } = l.opts, h = new r.SchemaEnv({ schema: u, schemaId: m, root: d, baseId: f, localRefs: p, meta: v });
    return r.compileSchema.call(l, h), (0, n.getValidate)(o, h);
  }
  return bi.default = i, bi;
}
var Fi = {}, kg;
function WE() {
  if (kg) return Fi;
  kg = 1, Object.defineProperty(Fi, "__esModule", { value: !0 }), Fi.dynamicRef = void 0;
  const e = Ze(), t = Qr(), r = C0(), n = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (a) => i(a, a.schema)
  };
  function i(a, s) {
    const { gen: o, keyword: c, it: u } = a;
    if (s[0] !== "#")
      throw new Error(`"${c}" only supports hash fragment reference`);
    const l = s.slice(1);
    if (u.allErrors)
      d();
    else {
      const p = o.let("valid", !1);
      d(p), a.ok(p);
    }
    function d(p) {
      if (u.schemaEnv.root.dynamicAnchors[l]) {
        const v = o.let("_v", (0, e._)`${t.default.dynamicAnchors}${(0, e.getProperty)(l)}`);
        o.if(v, f(v, p), f(u.validateName, p));
      } else
        f(u.validateName, p)();
    }
    function f(p, v) {
      return v ? () => o.block(() => {
        (0, r.callRef)(a, p), o.let(v, !0);
      }) : () => (0, r.callRef)(a, p);
    }
  }
  return Fi.dynamicRef = i, Fi.default = n, Fi;
}
var go = {}, Lg;
function Z2() {
  if (Lg) return go;
  Lg = 1, Object.defineProperty(go, "__esModule", { value: !0 });
  const e = zE(), t = st(), r = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(n) {
      n.schema ? (0, e.dynamicAnchor)(n, "") : (0, t.checkStrictMode)(n.it, "$recursiveAnchor: false is ignored");
    }
  };
  return go.default = r, go;
}
var vo = {}, Mg;
function eA() {
  if (Mg) return vo;
  Mg = 1, Object.defineProperty(vo, "__esModule", { value: !0 });
  const e = WE(), t = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (r) => (0, e.dynamicRef)(r, r.schema)
  };
  return vo.default = t, vo;
}
var Ug;
function tA() {
  if (Ug) return mo;
  Ug = 1, Object.defineProperty(mo, "__esModule", { value: !0 });
  const e = zE(), t = WE(), r = Z2(), n = eA(), i = [e.default, t.default, r.default, n.default];
  return mo.default = i, mo;
}
var _o = {}, yo = {}, qg;
function rA() {
  if (qg) return yo;
  qg = 1, Object.defineProperty(yo, "__esModule", { value: !0 });
  const e = b0(), t = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: e.error,
    code: (r) => (0, e.validatePropertyDeps)(r)
  };
  return yo.default = t, yo;
}
var Eo = {}, Bg;
function nA() {
  if (Bg) return Eo;
  Bg = 1, Object.defineProperty(Eo, "__esModule", { value: !0 });
  const e = b0(), t = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (r) => (0, e.validateSchemaDeps)(r)
  };
  return Eo.default = t, Eo;
}
var wo = {}, jg;
function iA() {
  if (jg) return wo;
  jg = 1, Object.defineProperty(wo, "__esModule", { value: !0 });
  const e = st(), t = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: r, parentSchema: n, it: i }) {
      n.contains === void 0 && (0, e.checkStrictMode)(i, `"${r}" without "contains" is ignored`);
    }
  };
  return wo.default = t, wo;
}
var Vg;
function aA() {
  if (Vg) return _o;
  Vg = 1, Object.defineProperty(_o, "__esModule", { value: !0 });
  const e = rA(), t = nA(), r = iA(), n = [e.default, t.default, r.default];
  return _o.default = n, _o;
}
var xo = {}, To = {}, Hg;
function sA() {
  if (Hg) return To;
  Hg = 1, Object.defineProperty(To, "__esModule", { value: !0 });
  const e = Ze(), t = st(), r = Qr(), i = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    trackErrors: !0,
    error: {
      message: "must NOT have unevaluated properties",
      params: ({ params: a }) => (0, e._)`{unevaluatedProperty: ${a.unevaluatedProperty}}`
    },
    code(a) {
      const { gen: s, schema: o, data: c, errsCount: u, it: l } = a;
      if (!u)
        throw new Error("ajv implementation error");
      const { allErrors: d, props: f } = l;
      f instanceof e.Name ? s.if((0, e._)`${f} !== true`, () => s.forIn("key", c, (h) => s.if(v(f, h), () => p(h)))) : f !== !0 && s.forIn("key", c, (h) => f === void 0 ? p(h) : s.if(m(f, h), () => p(h))), l.props = !0, a.ok((0, e._)`${u} === ${r.default.errors}`);
      function p(h) {
        if (o === !1) {
          a.setParams({ unevaluatedProperty: h }), a.error(), d || s.break();
          return;
        }
        if (!(0, t.alwaysValidSchema)(l, o)) {
          const _ = s.name("valid");
          a.subschema({
            keyword: "unevaluatedProperties",
            dataProp: h,
            dataPropType: t.Type.Str
          }, _), d || s.if((0, e.not)(_), () => s.break());
        }
      }
      function v(h, _) {
        return (0, e._)`!${h} || !${h}[${_}]`;
      }
      function m(h, _) {
        const g = [];
        for (const y in h)
          h[y] === !0 && g.push((0, e._)`${_} !== ${y}`);
        return (0, e.and)(...g);
      }
    }
  };
  return To.default = i, To;
}
var So = {}, Gg;
function oA() {
  if (Gg) return So;
  Gg = 1, Object.defineProperty(So, "__esModule", { value: !0 });
  const e = Ze(), t = st(), n = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error: {
      message: ({ params: { len: i } }) => (0, e.str)`must NOT have more than ${i} items`,
      params: ({ params: { len: i } }) => (0, e._)`{limit: ${i}}`
    },
    code(i) {
      const { gen: a, schema: s, data: o, it: c } = i, u = c.items || 0;
      if (u === !0)
        return;
      const l = a.const("len", (0, e._)`${o}.length`);
      if (s === !1)
        i.setParams({ len: u }), i.fail((0, e._)`${l} > ${u}`);
      else if (typeof s == "object" && !(0, t.alwaysValidSchema)(c, s)) {
        const f = a.var("valid", (0, e._)`${l} <= ${u}`);
        a.if((0, e.not)(f), () => d(f, u)), i.ok(f);
      }
      c.items = !0;
      function d(f, p) {
        a.forRange("i", p, l, (v) => {
          i.subschema({ keyword: "unevaluatedItems", dataProp: v, dataPropType: t.Type.Num }, f), c.allErrors || a.if((0, e.not)(f), () => a.break());
        });
      }
    }
  };
  return So.default = n, So;
}
var zg;
function cA() {
  if (zg) return xo;
  zg = 1, Object.defineProperty(xo, "__esModule", { value: !0 });
  const e = sA(), t = oA(), r = [e.default, t.default];
  return xo.default = r, xo;
}
var Ao = {}, Ro = {}, Wg;
function lA() {
  if (Wg) return Ro;
  Wg = 1, Object.defineProperty(Ro, "__esModule", { value: !0 });
  const e = Ze(), r = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, e._)`{format: ${n}}`
    },
    code(n, i) {
      const { gen: a, data: s, $data: o, schema: c, schemaCode: u, it: l } = n, { opts: d, errSchemaPath: f, schemaEnv: p, self: v } = l;
      if (!d.validateFormats)
        return;
      o ? m() : h();
      function m() {
        const _ = a.scopeValue("formats", {
          ref: v.formats,
          code: d.code.formats
        }), g = a.const("fDef", (0, e._)`${_}[${u}]`), y = a.let("fType"), x = a.let("format");
        a.if((0, e._)`typeof ${g} == "object" && !(${g} instanceof RegExp)`, () => a.assign(y, (0, e._)`${g}.type || "string"`).assign(x, (0, e._)`${g}.validate`), () => a.assign(y, (0, e._)`"string"`).assign(x, g)), n.fail$data((0, e.or)(S(), w()));
        function S() {
          return d.strictSchema === !1 ? e.nil : (0, e._)`${u} && !${x}`;
        }
        function w() {
          const E = p.$async ? (0, e._)`(${g}.async ? await ${x}(${s}) : ${x}(${s}))` : (0, e._)`${x}(${s})`, R = (0, e._)`(typeof ${x} == "function" ? ${E} : ${x}.test(${s}))`;
          return (0, e._)`${x} && ${x} !== true && ${y} === ${i} && !${R}`;
        }
      }
      function h() {
        const _ = v.formats[c];
        if (!_) {
          S();
          return;
        }
        if (_ === !0)
          return;
        const [g, y, x] = w(_);
        g === i && n.pass(E());
        function S() {
          if (d.strictSchema === !1) {
            v.logger.warn(R());
            return;
          }
          throw new Error(R());
          function R() {
            return `unknown format "${c}" ignored in schema at path "${f}"`;
          }
        }
        function w(R) {
          const N = R instanceof RegExp ? (0, e.regexpCode)(R) : d.code.formats ? (0, e._)`${d.code.formats}${(0, e.getProperty)(c)}` : void 0, B = a.scopeValue("formats", { key: c, ref: R, code: N });
          return typeof R == "object" && !(R instanceof RegExp) ? [R.type || "string", R.validate, (0, e._)`${B}.validate`] : ["string", R, B];
        }
        function E() {
          if (typeof _ == "object" && !(_ instanceof RegExp) && _.async) {
            if (!p.$async)
              throw new Error("async format in sync schema");
            return (0, e._)`await ${x}(${s})`;
          }
          return typeof y == "function" ? (0, e._)`${x}(${s})` : (0, e._)`${x}.test(${s})`;
        }
      }
    }
  };
  return Ro.default = r, Ro;
}
var Xg;
function uA() {
  if (Xg) return Ao;
  Xg = 1, Object.defineProperty(Ao, "__esModule", { value: !0 });
  const t = [lA().default];
  return Ao.default = t, Ao;
}
var oi = {}, Kg;
function fA() {
  return Kg || (Kg = 1, Object.defineProperty(oi, "__esModule", { value: !0 }), oi.contentVocabulary = oi.metadataVocabulary = void 0, oi.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], oi.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), oi;
}
var Yg;
function dA() {
  if (Yg) return Ms;
  Yg = 1, Object.defineProperty(Ms, "__esModule", { value: !0 });
  const e = $2(), t = U2(), r = Q2(), n = tA(), i = aA(), a = cA(), s = uA(), o = fA(), c = [
    n.default,
    e.default,
    t.default,
    (0, r.default)(!0),
    s.default,
    o.metadataVocabulary,
    o.contentVocabulary,
    i.default,
    a.default
  ];
  return Ms.default = c, Ms;
}
var $o = {}, Da = {}, Jg;
function hA() {
  if (Jg) return Da;
  Jg = 1, Object.defineProperty(Da, "__esModule", { value: !0 }), Da.DiscrError = void 0;
  var e;
  return (function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  })(e || (Da.DiscrError = e = {})), Da;
}
var Qg;
function pA() {
  if (Qg) return $o;
  Qg = 1, Object.defineProperty($o, "__esModule", { value: !0 });
  const e = Ze(), t = hA(), r = ul(), n = ll(), i = st(), s = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: o, tagName: c } }) => o === t.DiscrError.Tag ? `tag "${c}" must be string` : `value of tag "${c}" must be in oneOf`,
      params: ({ params: { discrError: o, tag: c, tagName: u } }) => (0, e._)`{error: ${o}, tag: ${u}, tagValue: ${c}}`
    },
    code(o) {
      const { gen: c, data: u, schema: l, parentSchema: d, it: f } = o, { oneOf: p } = d;
      if (!f.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const v = l.propertyName;
      if (typeof v != "string")
        throw new Error("discriminator: requires propertyName");
      if (l.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!p)
        throw new Error("discriminator: requires oneOf keyword");
      const m = c.let("valid", !1), h = c.const("tag", (0, e._)`${u}${(0, e.getProperty)(v)}`);
      c.if((0, e._)`typeof ${h} == "string"`, () => _(), () => o.error(!1, { discrError: t.DiscrError.Tag, tag: h, tagName: v })), o.ok(m);
      function _() {
        const x = y();
        c.if(!1);
        for (const S in x)
          c.elseIf((0, e._)`${h} === ${S}`), c.assign(m, g(x[S]));
        c.else(), o.error(!1, { discrError: t.DiscrError.Mapping, tag: h, tagName: v }), c.endIf();
      }
      function g(x) {
        const S = c.name("valid"), w = o.subschema({ keyword: "oneOf", schemaProp: x }, S);
        return o.mergeEvaluated(w, e.Name), S;
      }
      function y() {
        var x;
        const S = {}, w = R(d);
        let E = !0;
        for (let F = 0; F < p.length; F++) {
          let U = p[F];
          if (U?.$ref && !(0, i.schemaHasRulesButRef)(U, f.self.RULES)) {
            const M = U.$ref;
            if (U = r.resolveRef.call(f.self, f.schemaEnv.root, f.baseId, M), U instanceof r.SchemaEnv && (U = U.schema), U === void 0)
              throw new n.default(f.opts.uriResolver, f.baseId, M);
          }
          const G = (x = U?.properties) === null || x === void 0 ? void 0 : x[v];
          if (typeof G != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${v}"`);
          E = E && (w || R(U)), N(G, F);
        }
        if (!E)
          throw new Error(`discriminator: "${v}" must be required`);
        return S;
        function R({ required: F }) {
          return Array.isArray(F) && F.includes(v);
        }
        function N(F, U) {
          if (F.const)
            B(F.const, U);
          else if (F.enum)
            for (const G of F.enum)
              B(G, U);
          else
            throw new Error(`discriminator: "properties/${v}" must have "const" or "enum"`);
        }
        function B(F, U) {
          if (typeof F != "string" || F in S)
            throw new Error(`discriminator: "${v}" values must be unique strings`);
          S[F] = U;
        }
      }
    }
  };
  return $o.default = s, $o;
}
var Oo = {};
const mA = "https://json-schema.org/draft/2020-12/schema", gA = "https://json-schema.org/draft/2020-12/schema", vA = { "https://json-schema.org/draft/2020-12/vocab/core": !0, "https://json-schema.org/draft/2020-12/vocab/applicator": !0, "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0, "https://json-schema.org/draft/2020-12/vocab/validation": !0, "https://json-schema.org/draft/2020-12/vocab/meta-data": !0, "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0, "https://json-schema.org/draft/2020-12/vocab/content": !0 }, _A = "meta", yA = "Core and Validation specifications meta-schema", EA = [{ $ref: "meta/core" }, { $ref: "meta/applicator" }, { $ref: "meta/unevaluated" }, { $ref: "meta/validation" }, { $ref: "meta/meta-data" }, { $ref: "meta/format-annotation" }, { $ref: "meta/content" }], wA = ["object", "boolean"], xA = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", TA = { definitions: { $comment: '"definitions" has been replaced by "$defs".', type: "object", additionalProperties: { $dynamicRef: "#meta" }, deprecated: !0, default: {} }, dependencies: { $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.', type: "object", additionalProperties: { anyOf: [{ $dynamicRef: "#meta" }, { $ref: "meta/validation#/$defs/stringArray" }] }, deprecated: !0, default: {} }, $recursiveAnchor: { $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".', $ref: "meta/core#/$defs/anchorString", deprecated: !0 }, $recursiveRef: { $comment: '"$recursiveRef" has been replaced by "$dynamicRef".', $ref: "meta/core#/$defs/uriReferenceString", deprecated: !0 } }, SA = {
  $schema: mA,
  $id: gA,
  $vocabulary: vA,
  $dynamicAnchor: _A,
  title: yA,
  allOf: EA,
  type: wA,
  $comment: xA,
  properties: TA
}, AA = "https://json-schema.org/draft/2020-12/schema", RA = "https://json-schema.org/draft/2020-12/meta/applicator", $A = { "https://json-schema.org/draft/2020-12/vocab/applicator": !0 }, OA = "meta", NA = "Applicator vocabulary meta-schema", PA = ["object", "boolean"], CA = { prefixItems: { $ref: "#/$defs/schemaArray" }, items: { $dynamicRef: "#meta" }, contains: { $dynamicRef: "#meta" }, additionalProperties: { $dynamicRef: "#meta" }, properties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, propertyNames: { format: "regex" }, default: {} }, dependentSchemas: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, propertyNames: { $dynamicRef: "#meta" }, if: { $dynamicRef: "#meta" }, then: { $dynamicRef: "#meta" }, else: { $dynamicRef: "#meta" }, allOf: { $ref: "#/$defs/schemaArray" }, anyOf: { $ref: "#/$defs/schemaArray" }, oneOf: { $ref: "#/$defs/schemaArray" }, not: { $dynamicRef: "#meta" } }, IA = { schemaArray: { type: "array", minItems: 1, items: { $dynamicRef: "#meta" } } }, bA = {
  $schema: AA,
  $id: RA,
  $vocabulary: $A,
  $dynamicAnchor: OA,
  title: NA,
  type: PA,
  properties: CA,
  $defs: IA
}, FA = "https://json-schema.org/draft/2020-12/schema", DA = "https://json-schema.org/draft/2020-12/meta/unevaluated", kA = { "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0 }, LA = "meta", MA = "Unevaluated applicator vocabulary meta-schema", UA = ["object", "boolean"], qA = { unevaluatedItems: { $dynamicRef: "#meta" }, unevaluatedProperties: { $dynamicRef: "#meta" } }, BA = {
  $schema: FA,
  $id: DA,
  $vocabulary: kA,
  $dynamicAnchor: LA,
  title: MA,
  type: UA,
  properties: qA
}, jA = "https://json-schema.org/draft/2020-12/schema", VA = "https://json-schema.org/draft/2020-12/meta/content", HA = { "https://json-schema.org/draft/2020-12/vocab/content": !0 }, GA = "meta", zA = "Content vocabulary meta-schema", WA = ["object", "boolean"], XA = { contentEncoding: { type: "string" }, contentMediaType: { type: "string" }, contentSchema: { $dynamicRef: "#meta" } }, KA = {
  $schema: jA,
  $id: VA,
  $vocabulary: HA,
  $dynamicAnchor: GA,
  title: zA,
  type: WA,
  properties: XA
}, YA = "https://json-schema.org/draft/2020-12/schema", JA = "https://json-schema.org/draft/2020-12/meta/core", QA = { "https://json-schema.org/draft/2020-12/vocab/core": !0 }, ZA = "meta", eR = "Core vocabulary meta-schema", tR = ["object", "boolean"], rR = { $id: { $ref: "#/$defs/uriReferenceString", $comment: "Non-empty fragments not allowed.", pattern: "^[^#]*#?$" }, $schema: { $ref: "#/$defs/uriString" }, $ref: { $ref: "#/$defs/uriReferenceString" }, $anchor: { $ref: "#/$defs/anchorString" }, $dynamicRef: { $ref: "#/$defs/uriReferenceString" }, $dynamicAnchor: { $ref: "#/$defs/anchorString" }, $vocabulary: { type: "object", propertyNames: { $ref: "#/$defs/uriString" }, additionalProperties: { type: "boolean" } }, $comment: { type: "string" }, $defs: { type: "object", additionalProperties: { $dynamicRef: "#meta" } } }, nR = { anchorString: { type: "string", pattern: "^[A-Za-z_][-A-Za-z0-9._]*$" }, uriString: { type: "string", format: "uri" }, uriReferenceString: { type: "string", format: "uri-reference" } }, iR = {
  $schema: YA,
  $id: JA,
  $vocabulary: QA,
  $dynamicAnchor: ZA,
  title: eR,
  type: tR,
  properties: rR,
  $defs: nR
}, aR = "https://json-schema.org/draft/2020-12/schema", sR = "https://json-schema.org/draft/2020-12/meta/format-annotation", oR = { "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0 }, cR = "meta", lR = "Format vocabulary meta-schema for annotation results", uR = ["object", "boolean"], fR = { format: { type: "string" } }, dR = {
  $schema: aR,
  $id: sR,
  $vocabulary: oR,
  $dynamicAnchor: cR,
  title: lR,
  type: uR,
  properties: fR
}, hR = "https://json-schema.org/draft/2020-12/schema", pR = "https://json-schema.org/draft/2020-12/meta/meta-data", mR = { "https://json-schema.org/draft/2020-12/vocab/meta-data": !0 }, gR = "meta", vR = "Meta-data vocabulary meta-schema", _R = ["object", "boolean"], yR = { title: { type: "string" }, description: { type: "string" }, default: !0, deprecated: { type: "boolean", default: !1 }, readOnly: { type: "boolean", default: !1 }, writeOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 } }, ER = {
  $schema: hR,
  $id: pR,
  $vocabulary: mR,
  $dynamicAnchor: gR,
  title: vR,
  type: _R,
  properties: yR
}, wR = "https://json-schema.org/draft/2020-12/schema", xR = "https://json-schema.org/draft/2020-12/meta/validation", TR = { "https://json-schema.org/draft/2020-12/vocab/validation": !0 }, SR = "meta", AR = "Validation vocabulary meta-schema", RR = ["object", "boolean"], $R = { type: { anyOf: [{ $ref: "#/$defs/simpleTypes" }, { type: "array", items: { $ref: "#/$defs/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, const: !0, enum: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/$defs/nonNegativeInteger" }, minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, maxItems: { $ref: "#/$defs/nonNegativeInteger" }, minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, maxContains: { $ref: "#/$defs/nonNegativeInteger" }, minContains: { $ref: "#/$defs/nonNegativeInteger", default: 1 }, maxProperties: { $ref: "#/$defs/nonNegativeInteger" }, minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, required: { $ref: "#/$defs/stringArray" }, dependentRequired: { type: "object", additionalProperties: { $ref: "#/$defs/stringArray" } } }, OR = { nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { $ref: "#/$defs/nonNegativeInteger", default: 0 }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, NR = {
  $schema: wR,
  $id: xR,
  $vocabulary: TR,
  $dynamicAnchor: SR,
  title: AR,
  type: RR,
  properties: $R,
  $defs: OR
};
var Zg;
function PR() {
  if (Zg) return Oo;
  Zg = 1, Object.defineProperty(Oo, "__esModule", { value: !0 });
  const e = SA, t = bA, r = BA, n = KA, i = iR, a = dR, s = ER, o = NR, c = ["/properties"];
  function u(l) {
    return [
      e,
      t,
      r,
      n,
      i,
      d(this, a),
      s,
      d(this, o)
    ].forEach((f) => this.addMetaSchema(f, void 0, !1)), this;
    function d(f, p) {
      return l ? f.$dataMetaSchema(p, c) : p;
    }
  }
  return Oo.default = u, Oo;
}
var ev;
function CR() {
  return ev || (ev = 1, (function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv2020 = void 0;
    const r = A2(), n = dA(), i = pA(), a = PR(), s = "https://json-schema.org/draft/2020-12/schema";
    class o extends r.default {
      constructor(p = {}) {
        super({
          ...p,
          dynamicRef: !0,
          next: !0,
          unevaluated: !0
        });
      }
      _addVocabularies() {
        super._addVocabularies(), n.default.forEach((p) => this.addVocabulary(p)), this.opts.discriminator && this.addKeyword(i.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data: p, meta: v } = this.opts;
        v && (a.default.call(this, p), this.refs["http://json-schema.org/schema"] = s);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(s) ? s : void 0);
      }
    }
    t.Ajv2020 = o, e.exports = t = o, e.exports.Ajv2020 = o, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = o;
    var c = cl();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return c.KeywordCxt;
    } });
    var u = Ze();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return u._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return u.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return u.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return u.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return u.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return u.CodeGen;
    } });
    var l = P0();
    Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
      return l.default;
    } });
    var d = ll();
    Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
      return d.default;
    } });
  })(bs, bs.exports)), bs.exports;
}
var IR = CR(), No = { exports: {} }, Gf = {}, tv;
function bR() {
  return tv || (tv = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
    function t(F, U) {
      return { validate: F, compare: U };
    }
    e.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: t(a, s),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: t(c(!0), u),
      "date-time": t(f(!0), p),
      "iso-time": t(c(), l),
      "iso-date-time": t(f(), v),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: _,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex: B,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte: y,
      // signed 32 bit integer
      int32: { type: "number", validate: w },
      // signed 64 bit integer
      int64: { type: "number", validate: E },
      // C-type float
      float: { type: "number", validate: R },
      // C-type double
      double: { type: "number", validate: R },
      // hint to the UI to hide input strings
      password: !0,
      // unchecked string payload
      binary: !0
    }, e.fastFormats = {
      ...e.fullFormats,
      date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, s),
      time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, u),
      "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, p),
      "iso-time": t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, l),
      "iso-date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, v),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    }, e.formatNames = Object.keys(e.fullFormats);
    function r(F) {
      return F % 4 === 0 && (F % 100 !== 0 || F % 400 === 0);
    }
    const n = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, i = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function a(F) {
      const U = n.exec(F);
      if (!U)
        return !1;
      const G = +U[1], M = +U[2], V = +U[3];
      return M >= 1 && M <= 12 && V >= 1 && V <= (M === 2 && r(G) ? 29 : i[M]);
    }
    function s(F, U) {
      if (F && U)
        return F > U ? 1 : F < U ? -1 : 0;
    }
    const o = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function c(F) {
      return function(G) {
        const M = o.exec(G);
        if (!M)
          return !1;
        const V = +M[1], ie = +M[2], W = +M[3], ae = M[4], se = M[5] === "-" ? -1 : 1, X = +(M[6] || 0), k = +(M[7] || 0);
        if (X > 23 || k > 59 || F && !ae)
          return !1;
        if (V <= 23 && ie <= 59 && W < 60)
          return !0;
        const I = ie - k * se, C = V - X * se - (I < 0 ? 1 : 0);
        return (C === 23 || C === -1) && (I === 59 || I === -1) && W < 61;
      };
    }
    function u(F, U) {
      if (!(F && U))
        return;
      const G = (/* @__PURE__ */ new Date("2020-01-01T" + F)).valueOf(), M = (/* @__PURE__ */ new Date("2020-01-01T" + U)).valueOf();
      if (G && M)
        return G - M;
    }
    function l(F, U) {
      if (!(F && U))
        return;
      const G = o.exec(F), M = o.exec(U);
      if (G && M)
        return F = G[1] + G[2] + G[3], U = M[1] + M[2] + M[3], F > U ? 1 : F < U ? -1 : 0;
    }
    const d = /t|\s/i;
    function f(F) {
      const U = c(F);
      return function(M) {
        const V = M.split(d);
        return V.length === 2 && a(V[0]) && U(V[1]);
      };
    }
    function p(F, U) {
      if (!(F && U))
        return;
      const G = new Date(F).valueOf(), M = new Date(U).valueOf();
      if (G && M)
        return G - M;
    }
    function v(F, U) {
      if (!(F && U))
        return;
      const [G, M] = F.split(d), [V, ie] = U.split(d), W = s(G, V);
      if (W !== void 0)
        return W || u(M, ie);
    }
    const m = /\/|:/, h = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function _(F) {
      return m.test(F) && h.test(F);
    }
    const g = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function y(F) {
      return g.lastIndex = 0, g.test(F);
    }
    const x = -2147483648, S = 2 ** 31 - 1;
    function w(F) {
      return Number.isInteger(F) && F <= S && F >= x;
    }
    function E(F) {
      return Number.isInteger(F);
    }
    function R() {
      return !0;
    }
    const N = /[^\\]\\Z/;
    function B(F) {
      if (N.test(F))
        return !1;
      try {
        return new RegExp(F), !0;
      } catch {
        return !1;
      }
    }
  })(Gf)), Gf;
}
var zf = {}, Po = { exports: {} }, Wf = {}, vn = {}, ci = {}, Xf = {}, Kf = {}, Yf = {}, rv;
function Cc() {
  return rv || (rv = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
    class t {
    }
    e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class r extends t {
      constructor(g) {
        if (super(), !e.IDENTIFIER.test(g))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = g;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    e.Name = r;
    class n extends t {
      constructor(g) {
        super(), this._items = typeof g == "string" ? [g] : g;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const g = this._items[0];
        return g === "" || g === '""';
      }
      get str() {
        var g;
        return (g = this._str) !== null && g !== void 0 ? g : this._str = this._items.reduce((y, x) => `${y}${x}`, "");
      }
      get names() {
        var g;
        return (g = this._names) !== null && g !== void 0 ? g : this._names = this._items.reduce((y, x) => (x instanceof r && (y[x.str] = (y[x.str] || 0) + 1), y), {});
      }
    }
    e._Code = n, e.nil = new n("");
    function i(_, ...g) {
      const y = [_[0]];
      let x = 0;
      for (; x < g.length; )
        o(y, g[x]), y.push(_[++x]);
      return new n(y);
    }
    e._ = i;
    const a = new n("+");
    function s(_, ...g) {
      const y = [p(_[0])];
      let x = 0;
      for (; x < g.length; )
        y.push(a), o(y, g[x]), y.push(a, p(_[++x]));
      return c(y), new n(y);
    }
    e.str = s;
    function o(_, g) {
      g instanceof n ? _.push(...g._items) : g instanceof r ? _.push(g) : _.push(d(g));
    }
    e.addCodeArg = o;
    function c(_) {
      let g = 1;
      for (; g < _.length - 1; ) {
        if (_[g] === a) {
          const y = u(_[g - 1], _[g + 1]);
          if (y !== void 0) {
            _.splice(g - 1, 3, y);
            continue;
          }
          _[g++] = "+";
        }
        g++;
      }
    }
    function u(_, g) {
      if (g === '""')
        return _;
      if (_ === '""')
        return g;
      if (typeof _ == "string")
        return g instanceof r || _[_.length - 1] !== '"' ? void 0 : typeof g != "string" ? `${_.slice(0, -1)}${g}"` : g[0] === '"' ? _.slice(0, -1) + g.slice(1) : void 0;
      if (typeof g == "string" && g[0] === '"' && !(_ instanceof r))
        return `"${_}${g.slice(1)}`;
    }
    function l(_, g) {
      return g.emptyStr() ? _ : _.emptyStr() ? g : s`${_}${g}`;
    }
    e.strConcat = l;
    function d(_) {
      return typeof _ == "number" || typeof _ == "boolean" || _ === null ? _ : p(Array.isArray(_) ? _.join(",") : _);
    }
    function f(_) {
      return new n(p(_));
    }
    e.stringify = f;
    function p(_) {
      return JSON.stringify(_).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    e.safeStringify = p;
    function v(_) {
      return typeof _ == "string" && e.IDENTIFIER.test(_) ? new n(`.${_}`) : i`[${_}]`;
    }
    e.getProperty = v;
    function m(_) {
      if (typeof _ == "string" && e.IDENTIFIER.test(_))
        return new n(`${_}`);
      throw new Error(`CodeGen: invalid export name: ${_}, use explicit $id name mapping`);
    }
    e.getEsmExportName = m;
    function h(_) {
      return new n(_.toString());
    }
    e.regexpCode = h;
  })(Yf)), Yf;
}
var Jf = {}, nv;
function iv() {
  return nv || (nv = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
    const t = Cc();
    class r extends Error {
      constructor(u) {
        super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
      }
    }
    var n;
    (function(c) {
      c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
    })(n || (e.UsedValueState = n = {})), e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var")
    };
    class i {
      constructor({ prefixes: u, parent: l } = {}) {
        this._names = {}, this._prefixes = u, this._parent = l;
      }
      toName(u) {
        return u instanceof t.Name ? u : this.name(u);
      }
      name(u) {
        return new t.Name(this._newName(u));
      }
      _newName(u) {
        const l = this._names[u] || this._nameGroup(u);
        return `${u}${l.index++}`;
      }
      _nameGroup(u) {
        var l, d;
        if (!((d = (l = this._parent) === null || l === void 0 ? void 0 : l._prefixes) === null || d === void 0) && d.has(u) || this._prefixes && !this._prefixes.has(u))
          throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
        return this._names[u] = { prefix: u, index: 0 };
      }
    }
    e.Scope = i;
    class a extends t.Name {
      constructor(u, l) {
        super(l), this.prefix = u;
      }
      setValue(u, { property: l, itemIndex: d }) {
        this.value = u, this.scopePath = (0, t._)`.${new t.Name(l)}[${d}]`;
      }
    }
    e.ValueScopeName = a;
    const s = (0, t._)`\n`;
    class o extends i {
      constructor(u) {
        super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? s : t.nil };
      }
      get() {
        return this._scope;
      }
      name(u) {
        return new a(u, this._newName(u));
      }
      value(u, l) {
        var d;
        if (l.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const f = this.toName(u), { prefix: p } = f, v = (d = l.key) !== null && d !== void 0 ? d : l.ref;
        let m = this._values[p];
        if (m) {
          const g = m.get(v);
          if (g)
            return g;
        } else
          m = this._values[p] = /* @__PURE__ */ new Map();
        m.set(v, f);
        const h = this._scope[p] || (this._scope[p] = []), _ = h.length;
        return h[_] = l.ref, f.setValue(l, { property: p, itemIndex: _ }), f;
      }
      getValue(u, l) {
        const d = this._values[u];
        if (d)
          return d.get(l);
      }
      scopeRefs(u, l = this._values) {
        return this._reduceValues(l, (d) => {
          if (d.scopePath === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return (0, t._)`${u}${d.scopePath}`;
        });
      }
      scopeCode(u = this._values, l, d) {
        return this._reduceValues(u, (f) => {
          if (f.value === void 0)
            throw new Error(`CodeGen: name "${f}" has no value`);
          return f.value.code;
        }, l, d);
      }
      _reduceValues(u, l, d = {}, f) {
        let p = t.nil;
        for (const v in u) {
          const m = u[v];
          if (!m)
            continue;
          const h = d[v] = d[v] || /* @__PURE__ */ new Map();
          m.forEach((_) => {
            if (h.has(_))
              return;
            h.set(_, n.Started);
            let g = l(_);
            if (g) {
              const y = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
              p = (0, t._)`${p}${y} ${_} = ${g};${this.opts._n}`;
            } else if (g = f?.(_))
              p = (0, t._)`${p}${g}${this.opts._n}`;
            else
              throw new r(_);
            h.set(_, n.Completed);
          });
        }
        return p;
      }
    }
    e.ValueScope = o;
  })(Jf)), Jf;
}
var av;
function nt() {
  return av || (av = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
    const t = Cc(), r = iv();
    var n = Cc();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
      return n.strConcat;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
      return n.getProperty;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
      return n.regexpCode;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } });
    var i = iv();
    Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
      return i.Scope;
    } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
      return i.ValueScope;
    } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
      return i.ValueScopeName;
    } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
      return i.varKinds;
    } }), e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+")
    };
    class a {
      optimizeNodes() {
        return this;
      }
      optimizeNames(T, A) {
        return this;
      }
    }
    class s extends a {
      constructor(T, A, L) {
        super(), this.varKind = T, this.name = A, this.rhs = L;
      }
      render({ es5: T, _n: A }) {
        const L = T ? r.varKinds.var : this.varKind, b = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${L} ${this.name}${b};` + A;
      }
      optimizeNames(T, A) {
        if (T[this.name.str])
          return this.rhs && (this.rhs = M(this.rhs, T, A)), this;
      }
      get names() {
        return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
      }
    }
    class o extends a {
      constructor(T, A, L) {
        super(), this.lhs = T, this.rhs = A, this.sideEffects = L;
      }
      render({ _n: T }) {
        return `${this.lhs} = ${this.rhs};` + T;
      }
      optimizeNames(T, A) {
        if (!(this.lhs instanceof t.Name && !T[this.lhs.str] && !this.sideEffects))
          return this.rhs = M(this.rhs, T, A), this;
      }
      get names() {
        const T = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
        return G(T, this.rhs);
      }
    }
    class c extends o {
      constructor(T, A, L, b) {
        super(T, L, b), this.op = A;
      }
      render({ _n: T }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + T;
      }
    }
    class u extends a {
      constructor(T) {
        super(), this.label = T, this.names = {};
      }
      render({ _n: T }) {
        return `${this.label}:` + T;
      }
    }
    class l extends a {
      constructor(T) {
        super(), this.label = T, this.names = {};
      }
      render({ _n: T }) {
        return `break${this.label ? ` ${this.label}` : ""};` + T;
      }
    }
    class d extends a {
      constructor(T) {
        super(), this.error = T;
      }
      render({ _n: T }) {
        return `throw ${this.error};` + T;
      }
      get names() {
        return this.error.names;
      }
    }
    class f extends a {
      constructor(T) {
        super(), this.code = T;
      }
      render({ _n: T }) {
        return `${this.code};` + T;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(T, A) {
        return this.code = M(this.code, T, A), this;
      }
      get names() {
        return this.code instanceof t._CodeOrName ? this.code.names : {};
      }
    }
    class p extends a {
      constructor(T = []) {
        super(), this.nodes = T;
      }
      render(T) {
        return this.nodes.reduce((A, L) => A + L.render(T), "");
      }
      optimizeNodes() {
        const { nodes: T } = this;
        let A = T.length;
        for (; A--; ) {
          const L = T[A].optimizeNodes();
          Array.isArray(L) ? T.splice(A, 1, ...L) : L ? T[A] = L : T.splice(A, 1);
        }
        return T.length > 0 ? this : void 0;
      }
      optimizeNames(T, A) {
        const { nodes: L } = this;
        let b = L.length;
        for (; b--; ) {
          const P = L[b];
          P.optimizeNames(T, A) || (V(T, P.names), L.splice(b, 1));
        }
        return L.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((T, A) => U(T, A.names), {});
      }
    }
    class v extends p {
      render(T) {
        return "{" + T._n + super.render(T) + "}" + T._n;
      }
    }
    class m extends p {
    }
    class h extends v {
    }
    h.kind = "else";
    class _ extends v {
      constructor(T, A) {
        super(A), this.condition = T;
      }
      render(T) {
        let A = `if(${this.condition})` + super.render(T);
        return this.else && (A += "else " + this.else.render(T)), A;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const T = this.condition;
        if (T === !0)
          return this.nodes;
        let A = this.else;
        if (A) {
          const L = A.optimizeNodes();
          A = this.else = Array.isArray(L) ? new h(L) : L;
        }
        if (A)
          return T === !1 ? A instanceof _ ? A : A.nodes : this.nodes.length ? this : new _(ie(T), A instanceof _ ? [A] : A.nodes);
        if (!(T === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(T, A) {
        var L;
        if (this.else = (L = this.else) === null || L === void 0 ? void 0 : L.optimizeNames(T, A), !!(super.optimizeNames(T, A) || this.else))
          return this.condition = M(this.condition, T, A), this;
      }
      get names() {
        const T = super.names;
        return G(T, this.condition), this.else && U(T, this.else.names), T;
      }
    }
    _.kind = "if";
    class g extends v {
    }
    g.kind = "for";
    class y extends g {
      constructor(T) {
        super(), this.iteration = T;
      }
      render(T) {
        return `for(${this.iteration})` + super.render(T);
      }
      optimizeNames(T, A) {
        if (super.optimizeNames(T, A))
          return this.iteration = M(this.iteration, T, A), this;
      }
      get names() {
        return U(super.names, this.iteration.names);
      }
    }
    class x extends g {
      constructor(T, A, L, b) {
        super(), this.varKind = T, this.name = A, this.from = L, this.to = b;
      }
      render(T) {
        const A = T.es5 ? r.varKinds.var : this.varKind, { name: L, from: b, to: P } = this;
        return `for(${A} ${L}=${b}; ${L}<${P}; ${L}++)` + super.render(T);
      }
      get names() {
        const T = G(super.names, this.from);
        return G(T, this.to);
      }
    }
    class S extends g {
      constructor(T, A, L, b) {
        super(), this.loop = T, this.varKind = A, this.name = L, this.iterable = b;
      }
      render(T) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(T);
      }
      optimizeNames(T, A) {
        if (super.optimizeNames(T, A))
          return this.iterable = M(this.iterable, T, A), this;
      }
      get names() {
        return U(super.names, this.iterable.names);
      }
    }
    class w extends v {
      constructor(T, A, L) {
        super(), this.name = T, this.args = A, this.async = L;
      }
      render(T) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(T);
      }
    }
    w.kind = "func";
    class E extends p {
      render(T) {
        return "return " + super.render(T);
      }
    }
    E.kind = "return";
    class R extends v {
      render(T) {
        let A = "try" + super.render(T);
        return this.catch && (A += this.catch.render(T)), this.finally && (A += this.finally.render(T)), A;
      }
      optimizeNodes() {
        var T, A;
        return super.optimizeNodes(), (T = this.catch) === null || T === void 0 || T.optimizeNodes(), (A = this.finally) === null || A === void 0 || A.optimizeNodes(), this;
      }
      optimizeNames(T, A) {
        var L, b;
        return super.optimizeNames(T, A), (L = this.catch) === null || L === void 0 || L.optimizeNames(T, A), (b = this.finally) === null || b === void 0 || b.optimizeNames(T, A), this;
      }
      get names() {
        const T = super.names;
        return this.catch && U(T, this.catch.names), this.finally && U(T, this.finally.names), T;
      }
    }
    class N extends v {
      constructor(T) {
        super(), this.error = T;
      }
      render(T) {
        return `catch(${this.error})` + super.render(T);
      }
    }
    N.kind = "catch";
    class B extends v {
      render(T) {
        return "finally" + super.render(T);
      }
    }
    B.kind = "finally";
    class F {
      constructor(T, A = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...A, _n: A.lines ? `
` : "" }, this._extScope = T, this._scope = new r.Scope({ parent: T }), this._nodes = [new m()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(T) {
        return this._scope.name(T);
      }
      // reserves unique name in the external scope
      scopeName(T) {
        return this._extScope.name(T);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(T, A) {
        const L = this._extScope.value(T, A);
        return (this._values[L.prefix] || (this._values[L.prefix] = /* @__PURE__ */ new Set())).add(L), L;
      }
      getScopeValue(T, A) {
        return this._extScope.getValue(T, A);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(T) {
        return this._extScope.scopeRefs(T, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(T, A, L, b) {
        const P = this._scope.toName(A);
        return L !== void 0 && b && (this._constants[P.str] = L), this._leafNode(new s(T, P, L)), P;
      }
      // `const` declaration (`var` in es5 mode)
      const(T, A, L) {
        return this._def(r.varKinds.const, T, A, L);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(T, A, L) {
        return this._def(r.varKinds.let, T, A, L);
      }
      // `var` declaration with optional assignment
      var(T, A, L) {
        return this._def(r.varKinds.var, T, A, L);
      }
      // assignment code
      assign(T, A, L) {
        return this._leafNode(new o(T, A, L));
      }
      // `+=` code
      add(T, A) {
        return this._leafNode(new c(T, e.operators.ADD, A));
      }
      // appends passed SafeExpr to code or executes Block
      code(T) {
        return typeof T == "function" ? T() : T !== t.nil && this._leafNode(new f(T)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...T) {
        const A = ["{"];
        for (const [L, b] of T)
          A.length > 1 && A.push(","), A.push(L), (L !== b || this.opts.es5) && (A.push(":"), (0, t.addCodeArg)(A, b));
        return A.push("}"), new t._Code(A);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(T, A, L) {
        if (this._blockNode(new _(T)), A && L)
          this.code(A).else().code(L).endIf();
        else if (A)
          this.code(A).endIf();
        else if (L)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(T) {
        return this._elseNode(new _(T));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new h());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(_, h);
      }
      _for(T, A) {
        return this._blockNode(T), A && this.code(A).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(T, A) {
        return this._for(new y(T), A);
      }
      // `for` statement for a range of values
      forRange(T, A, L, b, P = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
        const te = this._scope.toName(T);
        return this._for(new x(P, te, A, L), () => b(te));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(T, A, L, b = r.varKinds.const) {
        const P = this._scope.toName(T);
        if (this.opts.es5) {
          const te = A instanceof t.Name ? A : this.var("_arr", A);
          return this.forRange("_i", 0, (0, t._)`${te}.length`, (H) => {
            this.var(P, (0, t._)`${te}[${H}]`), L(P);
          });
        }
        return this._for(new S("of", b, P, A), () => L(P));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(T, A, L, b = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(T, (0, t._)`Object.keys(${A})`, L);
        const P = this._scope.toName(T);
        return this._for(new S("in", b, P, A), () => L(P));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(g);
      }
      // `label` statement
      label(T) {
        return this._leafNode(new u(T));
      }
      // `break` statement
      break(T) {
        return this._leafNode(new l(T));
      }
      // `return` statement
      return(T) {
        const A = new E();
        if (this._blockNode(A), this.code(T), A.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(E);
      }
      // `try` statement
      try(T, A, L) {
        if (!A && !L)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const b = new R();
        if (this._blockNode(b), this.code(T), A) {
          const P = this.name("e");
          this._currNode = b.catch = new N(P), A(P);
        }
        return L && (this._currNode = b.finally = new B(), this.code(L)), this._endBlockNode(N, B);
      }
      // `throw` statement
      throw(T) {
        return this._leafNode(new d(T));
      }
      // start self-balancing block
      block(T, A) {
        return this._blockStarts.push(this._nodes.length), T && this.code(T).endBlock(A), this;
      }
      // end the current self-balancing block
      endBlock(T) {
        const A = this._blockStarts.pop();
        if (A === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const L = this._nodes.length - A;
        if (L < 0 || T !== void 0 && L !== T)
          throw new Error(`CodeGen: wrong number of nodes: ${L} vs ${T} expected`);
        return this._nodes.length = A, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(T, A = t.nil, L, b) {
        return this._blockNode(new w(T, A, L)), b && this.code(b).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(w);
      }
      optimize(T = 1) {
        for (; T-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(T) {
        return this._currNode.nodes.push(T), this;
      }
      _blockNode(T) {
        this._currNode.nodes.push(T), this._nodes.push(T);
      }
      _endBlockNode(T, A) {
        const L = this._currNode;
        if (L instanceof T || A && L instanceof A)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${A ? `${T.kind}/${A.kind}` : T.kind}"`);
      }
      _elseNode(T) {
        const A = this._currNode;
        if (!(A instanceof _))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = A.else = T, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const T = this._nodes;
        return T[T.length - 1];
      }
      set _currNode(T) {
        const A = this._nodes;
        A[A.length - 1] = T;
      }
    }
    e.CodeGen = F;
    function U(C, T) {
      for (const A in T)
        C[A] = (C[A] || 0) + (T[A] || 0);
      return C;
    }
    function G(C, T) {
      return T instanceof t._CodeOrName ? U(C, T.names) : C;
    }
    function M(C, T, A) {
      if (C instanceof t.Name)
        return L(C);
      if (!b(C))
        return C;
      return new t._Code(C._items.reduce((P, te) => (te instanceof t.Name && (te = L(te)), te instanceof t._Code ? P.push(...te._items) : P.push(te), P), []));
      function L(P) {
        const te = A[P.str];
        return te === void 0 || T[P.str] !== 1 ? P : (delete T[P.str], te);
      }
      function b(P) {
        return P instanceof t._Code && P._items.some((te) => te instanceof t.Name && T[te.str] === 1 && A[te.str] !== void 0);
      }
    }
    function V(C, T) {
      for (const A in T)
        C[A] = (C[A] || 0) - (T[A] || 0);
    }
    function ie(C) {
      return typeof C == "boolean" || typeof C == "number" || C === null ? !C : (0, t._)`!${I(C)}`;
    }
    e.not = ie;
    const W = k(e.operators.AND);
    function ae(...C) {
      return C.reduce(W);
    }
    e.and = ae;
    const se = k(e.operators.OR);
    function X(...C) {
      return C.reduce(se);
    }
    e.or = X;
    function k(C) {
      return (T, A) => T === t.nil ? A : A === t.nil ? T : (0, t._)`${I(T)} ${C} ${I(A)}`;
    }
    function I(C) {
      return C instanceof t.Name ? C : (0, t._)`(${C})`;
    }
  })(Kf)), Kf;
}
var rt = {}, sv;
function lt() {
  if (sv) return rt;
  sv = 1, Object.defineProperty(rt, "__esModule", { value: !0 }), rt.checkStrictMode = rt.getErrorPath = rt.Type = rt.useFunc = rt.setEvaluated = rt.evaluatedPropsToName = rt.mergeEvaluated = rt.eachItem = rt.unescapeJsonPointer = rt.escapeJsonPointer = rt.escapeFragment = rt.unescapeFragment = rt.schemaRefOrVal = rt.schemaHasRulesButRef = rt.schemaHasRules = rt.checkUnknownRules = rt.alwaysValidSchema = rt.toHash = void 0;
  const e = nt(), t = Cc();
  function r(S) {
    const w = {};
    for (const E of S)
      w[E] = !0;
    return w;
  }
  rt.toHash = r;
  function n(S, w) {
    return typeof w == "boolean" ? w : Object.keys(w).length === 0 ? !0 : (i(S, w), !a(w, S.self.RULES.all));
  }
  rt.alwaysValidSchema = n;
  function i(S, w = S.schema) {
    const { opts: E, self: R } = S;
    if (!E.strictSchema || typeof w == "boolean")
      return;
    const N = R.RULES.keywords;
    for (const B in w)
      N[B] || x(S, `unknown keyword: "${B}"`);
  }
  rt.checkUnknownRules = i;
  function a(S, w) {
    if (typeof S == "boolean")
      return !S;
    for (const E in S)
      if (w[E])
        return !0;
    return !1;
  }
  rt.schemaHasRules = a;
  function s(S, w) {
    if (typeof S == "boolean")
      return !S;
    for (const E in S)
      if (E !== "$ref" && w.all[E])
        return !0;
    return !1;
  }
  rt.schemaHasRulesButRef = s;
  function o({ topSchemaRef: S, schemaPath: w }, E, R, N) {
    if (!N) {
      if (typeof E == "number" || typeof E == "boolean")
        return E;
      if (typeof E == "string")
        return (0, e._)`${E}`;
    }
    return (0, e._)`${S}${w}${(0, e.getProperty)(R)}`;
  }
  rt.schemaRefOrVal = o;
  function c(S) {
    return d(decodeURIComponent(S));
  }
  rt.unescapeFragment = c;
  function u(S) {
    return encodeURIComponent(l(S));
  }
  rt.escapeFragment = u;
  function l(S) {
    return typeof S == "number" ? `${S}` : S.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  rt.escapeJsonPointer = l;
  function d(S) {
    return S.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  rt.unescapeJsonPointer = d;
  function f(S, w) {
    if (Array.isArray(S))
      for (const E of S)
        w(E);
    else
      w(S);
  }
  rt.eachItem = f;
  function p({ mergeNames: S, mergeToName: w, mergeValues: E, resultToName: R }) {
    return (N, B, F, U) => {
      const G = F === void 0 ? B : F instanceof e.Name ? (B instanceof e.Name ? S(N, B, F) : w(N, B, F), F) : B instanceof e.Name ? (w(N, F, B), B) : E(B, F);
      return U === e.Name && !(G instanceof e.Name) ? R(N, G) : G;
    };
  }
  rt.mergeEvaluated = {
    props: p({
      mergeNames: (S, w, E) => S.if((0, e._)`${E} !== true && ${w} !== undefined`, () => {
        S.if((0, e._)`${w} === true`, () => S.assign(E, !0), () => S.assign(E, (0, e._)`${E} || {}`).code((0, e._)`Object.assign(${E}, ${w})`));
      }),
      mergeToName: (S, w, E) => S.if((0, e._)`${E} !== true`, () => {
        w === !0 ? S.assign(E, !0) : (S.assign(E, (0, e._)`${E} || {}`), m(S, E, w));
      }),
      mergeValues: (S, w) => S === !0 ? !0 : { ...S, ...w },
      resultToName: v
    }),
    items: p({
      mergeNames: (S, w, E) => S.if((0, e._)`${E} !== true && ${w} !== undefined`, () => S.assign(E, (0, e._)`${w} === true ? true : ${E} > ${w} ? ${E} : ${w}`)),
      mergeToName: (S, w, E) => S.if((0, e._)`${E} !== true`, () => S.assign(E, w === !0 ? !0 : (0, e._)`${E} > ${w} ? ${E} : ${w}`)),
      mergeValues: (S, w) => S === !0 ? !0 : Math.max(S, w),
      resultToName: (S, w) => S.var("items", w)
    })
  };
  function v(S, w) {
    if (w === !0)
      return S.var("props", !0);
    const E = S.var("props", (0, e._)`{}`);
    return w !== void 0 && m(S, E, w), E;
  }
  rt.evaluatedPropsToName = v;
  function m(S, w, E) {
    Object.keys(E).forEach((R) => S.assign((0, e._)`${w}${(0, e.getProperty)(R)}`, !0));
  }
  rt.setEvaluated = m;
  const h = {};
  function _(S, w) {
    return S.scopeValue("func", {
      ref: w,
      code: h[w.code] || (h[w.code] = new t._Code(w.code))
    });
  }
  rt.useFunc = _;
  var g;
  (function(S) {
    S[S.Num = 0] = "Num", S[S.Str = 1] = "Str";
  })(g || (rt.Type = g = {}));
  function y(S, w, E) {
    if (S instanceof e.Name) {
      const R = w === g.Num;
      return E ? R ? (0, e._)`"[" + ${S} + "]"` : (0, e._)`"['" + ${S} + "']"` : R ? (0, e._)`"/" + ${S}` : (0, e._)`"/" + ${S}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return E ? (0, e.getProperty)(S).toString() : "/" + l(S);
  }
  rt.getErrorPath = y;
  function x(S, w, E = S.opts.strictSchema) {
    if (E) {
      if (w = `strict mode: ${w}`, E === !0)
        throw new Error(w);
      S.self.logger.warn(w);
    }
  }
  return rt.checkStrictMode = x, rt;
}
var Co = {}, ov;
function Wn() {
  if (ov) return Co;
  ov = 1, Object.defineProperty(Co, "__esModule", { value: !0 });
  const e = nt(), t = {
    // validation function arguments
    data: new e.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new e.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new e.Name("instancePath"),
    parentData: new e.Name("parentData"),
    parentDataProperty: new e.Name("parentDataProperty"),
    rootData: new e.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new e.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new e.Name("vErrors"),
    // null or array of validation errors
    errors: new e.Name("errors"),
    // counter of validation errors
    this: new e.Name("this"),
    // "globals"
    self: new e.Name("self"),
    scope: new e.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new e.Name("json"),
    jsonPos: new e.Name("jsonPos"),
    jsonLen: new e.Name("jsonLen"),
    jsonPart: new e.Name("jsonPart")
  };
  return Co.default = t, Co;
}
var cv;
function fl() {
  return cv || (cv = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
    const t = nt(), r = lt(), n = Wn();
    e.keywordError = {
      message: ({ keyword: h }) => (0, t.str)`must pass "${h}" keyword validation`
    }, e.keyword$DataError = {
      message: ({ keyword: h, schemaType: _ }) => _ ? (0, t.str)`"${h}" keyword must be ${_} ($data)` : (0, t.str)`"${h}" keyword is invalid ($data)`
    };
    function i(h, _ = e.keywordError, g, y) {
      const { it: x } = h, { gen: S, compositeRule: w, allErrors: E } = x, R = d(h, _, g);
      y ?? (w || E) ? c(S, R) : u(x, (0, t._)`[${R}]`);
    }
    e.reportError = i;
    function a(h, _ = e.keywordError, g) {
      const { it: y } = h, { gen: x, compositeRule: S, allErrors: w } = y, E = d(h, _, g);
      c(x, E), S || w || u(y, n.default.vErrors);
    }
    e.reportExtraError = a;
    function s(h, _) {
      h.assign(n.default.errors, _), h.if((0, t._)`${n.default.vErrors} !== null`, () => h.if(_, () => h.assign((0, t._)`${n.default.vErrors}.length`, _), () => h.assign(n.default.vErrors, null)));
    }
    e.resetErrorsCount = s;
    function o({ gen: h, keyword: _, schemaValue: g, data: y, errsCount: x, it: S }) {
      if (x === void 0)
        throw new Error("ajv implementation error");
      const w = h.name("err");
      h.forRange("i", x, n.default.errors, (E) => {
        h.const(w, (0, t._)`${n.default.vErrors}[${E}]`), h.if((0, t._)`${w}.instancePath === undefined`, () => h.assign((0, t._)`${w}.instancePath`, (0, t.strConcat)(n.default.instancePath, S.errorPath))), h.assign((0, t._)`${w}.schemaPath`, (0, t.str)`${S.errSchemaPath}/${_}`), S.opts.verbose && (h.assign((0, t._)`${w}.schema`, g), h.assign((0, t._)`${w}.data`, y));
      });
    }
    e.extendErrors = o;
    function c(h, _) {
      const g = h.const("err", _);
      h.if((0, t._)`${n.default.vErrors} === null`, () => h.assign(n.default.vErrors, (0, t._)`[${g}]`), (0, t._)`${n.default.vErrors}.push(${g})`), h.code((0, t._)`${n.default.errors}++`);
    }
    function u(h, _) {
      const { gen: g, validateName: y, schemaEnv: x } = h;
      x.$async ? g.throw((0, t._)`new ${h.ValidationError}(${_})`) : (g.assign((0, t._)`${y}.errors`, _), g.return(!1));
    }
    const l = {
      keyword: new t.Name("keyword"),
      schemaPath: new t.Name("schemaPath"),
      // also used in JTD errors
      params: new t.Name("params"),
      propertyName: new t.Name("propertyName"),
      message: new t.Name("message"),
      schema: new t.Name("schema"),
      parentSchema: new t.Name("parentSchema")
    };
    function d(h, _, g) {
      const { createErrors: y } = h.it;
      return y === !1 ? (0, t._)`{}` : f(h, _, g);
    }
    function f(h, _, g = {}) {
      const { gen: y, it: x } = h, S = [
        p(x, g),
        v(h, g)
      ];
      return m(h, _, S), y.object(...S);
    }
    function p({ errorPath: h }, { instancePath: _ }) {
      const g = _ ? (0, t.str)`${h}${(0, r.getErrorPath)(_, r.Type.Str)}` : h;
      return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, g)];
    }
    function v({ keyword: h, it: { errSchemaPath: _ } }, { schemaPath: g, parentSchema: y }) {
      let x = y ? _ : (0, t.str)`${_}/${h}`;
      return g && (x = (0, t.str)`${x}${(0, r.getErrorPath)(g, r.Type.Str)}`), [l.schemaPath, x];
    }
    function m(h, { params: _, message: g }, y) {
      const { keyword: x, data: S, schemaValue: w, it: E } = h, { opts: R, propertyName: N, topSchemaRef: B, schemaPath: F } = E;
      y.push([l.keyword, x], [l.params, typeof _ == "function" ? _(h) : _ || (0, t._)`{}`]), R.messages && y.push([l.message, typeof g == "function" ? g(h) : g]), R.verbose && y.push([l.schema, w], [l.parentSchema, (0, t._)`${B}${F}`], [n.default.data, S]), N && y.push([l.propertyName, N]);
    }
  })(Xf)), Xf;
}
var lv;
function FR() {
  if (lv) return ci;
  lv = 1, Object.defineProperty(ci, "__esModule", { value: !0 }), ci.boolOrEmptySchema = ci.topBoolOrEmptySchema = void 0;
  const e = fl(), t = nt(), r = Wn(), n = {
    message: "boolean schema is false"
  };
  function i(o) {
    const { gen: c, schema: u, validateName: l } = o;
    u === !1 ? s(o, !1) : typeof u == "object" && u.$async === !0 ? c.return(r.default.data) : (c.assign((0, t._)`${l}.errors`, null), c.return(!0));
  }
  ci.topBoolOrEmptySchema = i;
  function a(o, c) {
    const { gen: u, schema: l } = o;
    l === !1 ? (u.var(c, !1), s(o)) : u.var(c, !0);
  }
  ci.boolOrEmptySchema = a;
  function s(o, c) {
    const { gen: u, data: l } = o, d = {
      gen: u,
      keyword: "false schema",
      data: l,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: o
    };
    (0, e.reportError)(d, n, void 0, c);
  }
  return ci;
}
var Ht = {}, li = {}, uv;
function XE() {
  if (uv) return li;
  uv = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.getRules = li.isJSONType = void 0;
  const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
  function r(i) {
    return typeof i == "string" && t.has(i);
  }
  li.isJSONType = r;
  function n() {
    const i = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...i, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, i.number, i.string, i.array, i.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return li.getRules = n, li;
}
var _n = {}, fv;
function KE() {
  if (fv) return _n;
  fv = 1, Object.defineProperty(_n, "__esModule", { value: !0 }), _n.shouldUseRule = _n.shouldUseGroup = _n.schemaHasRulesForType = void 0;
  function e({ schema: n, self: i }, a) {
    const s = i.RULES.types[a];
    return s && s !== !0 && t(n, s);
  }
  _n.schemaHasRulesForType = e;
  function t(n, i) {
    return i.rules.some((a) => r(n, a));
  }
  _n.shouldUseGroup = t;
  function r(n, i) {
    var a;
    return n[i.keyword] !== void 0 || ((a = i.definition.implements) === null || a === void 0 ? void 0 : a.some((s) => n[s] !== void 0));
  }
  return _n.shouldUseRule = r, _n;
}
var dv;
function Ic() {
  if (dv) return Ht;
  dv = 1, Object.defineProperty(Ht, "__esModule", { value: !0 }), Ht.reportTypeError = Ht.checkDataTypes = Ht.checkDataType = Ht.coerceAndCheckDataType = Ht.getJSONTypes = Ht.getSchemaTypes = Ht.DataType = void 0;
  const e = XE(), t = KE(), r = fl(), n = nt(), i = lt();
  var a;
  (function(g) {
    g[g.Correct = 0] = "Correct", g[g.Wrong = 1] = "Wrong";
  })(a || (Ht.DataType = a = {}));
  function s(g) {
    const y = o(g.type);
    if (y.includes("null")) {
      if (g.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!y.length && g.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      g.nullable === !0 && y.push("null");
    }
    return y;
  }
  Ht.getSchemaTypes = s;
  function o(g) {
    const y = Array.isArray(g) ? g : g ? [g] : [];
    if (y.every(e.isJSONType))
      return y;
    throw new Error("type must be JSONType or JSONType[]: " + y.join(","));
  }
  Ht.getJSONTypes = o;
  function c(g, y) {
    const { gen: x, data: S, opts: w } = g, E = l(y, w.coerceTypes), R = y.length > 0 && !(E.length === 0 && y.length === 1 && (0, t.schemaHasRulesForType)(g, y[0]));
    if (R) {
      const N = v(y, S, w.strictNumbers, a.Wrong);
      x.if(N, () => {
        E.length ? d(g, y, E) : h(g);
      });
    }
    return R;
  }
  Ht.coerceAndCheckDataType = c;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function l(g, y) {
    return y ? g.filter((x) => u.has(x) || y === "array" && x === "array") : [];
  }
  function d(g, y, x) {
    const { gen: S, data: w, opts: E } = g, R = S.let("dataType", (0, n._)`typeof ${w}`), N = S.let("coerced", (0, n._)`undefined`);
    E.coerceTypes === "array" && S.if((0, n._)`${R} == 'object' && Array.isArray(${w}) && ${w}.length == 1`, () => S.assign(w, (0, n._)`${w}[0]`).assign(R, (0, n._)`typeof ${w}`).if(v(y, w, E.strictNumbers), () => S.assign(N, w))), S.if((0, n._)`${N} !== undefined`);
    for (const F of x)
      (u.has(F) || F === "array" && E.coerceTypes === "array") && B(F);
    S.else(), h(g), S.endIf(), S.if((0, n._)`${N} !== undefined`, () => {
      S.assign(w, N), f(g, N);
    });
    function B(F) {
      switch (F) {
        case "string":
          S.elseIf((0, n._)`${R} == "number" || ${R} == "boolean"`).assign(N, (0, n._)`"" + ${w}`).elseIf((0, n._)`${w} === null`).assign(N, (0, n._)`""`);
          return;
        case "number":
          S.elseIf((0, n._)`${R} == "boolean" || ${w} === null
              || (${R} == "string" && ${w} && ${w} == +${w})`).assign(N, (0, n._)`+${w}`);
          return;
        case "integer":
          S.elseIf((0, n._)`${R} === "boolean" || ${w} === null
              || (${R} === "string" && ${w} && ${w} == +${w} && !(${w} % 1))`).assign(N, (0, n._)`+${w}`);
          return;
        case "boolean":
          S.elseIf((0, n._)`${w} === "false" || ${w} === 0 || ${w} === null`).assign(N, !1).elseIf((0, n._)`${w} === "true" || ${w} === 1`).assign(N, !0);
          return;
        case "null":
          S.elseIf((0, n._)`${w} === "" || ${w} === 0 || ${w} === false`), S.assign(N, null);
          return;
        case "array":
          S.elseIf((0, n._)`${R} === "string" || ${R} === "number"
              || ${R} === "boolean" || ${w} === null`).assign(N, (0, n._)`[${w}]`);
      }
    }
  }
  function f({ gen: g, parentData: y, parentDataProperty: x }, S) {
    g.if((0, n._)`${y} !== undefined`, () => g.assign((0, n._)`${y}[${x}]`, S));
  }
  function p(g, y, x, S = a.Correct) {
    const w = S === a.Correct ? n.operators.EQ : n.operators.NEQ;
    let E;
    switch (g) {
      case "null":
        return (0, n._)`${y} ${w} null`;
      case "array":
        E = (0, n._)`Array.isArray(${y})`;
        break;
      case "object":
        E = (0, n._)`${y} && typeof ${y} == "object" && !Array.isArray(${y})`;
        break;
      case "integer":
        E = R((0, n._)`!(${y} % 1) && !isNaN(${y})`);
        break;
      case "number":
        E = R();
        break;
      default:
        return (0, n._)`typeof ${y} ${w} ${g}`;
    }
    return S === a.Correct ? E : (0, n.not)(E);
    function R(N = n.nil) {
      return (0, n.and)((0, n._)`typeof ${y} == "number"`, N, x ? (0, n._)`isFinite(${y})` : n.nil);
    }
  }
  Ht.checkDataType = p;
  function v(g, y, x, S) {
    if (g.length === 1)
      return p(g[0], y, x, S);
    let w;
    const E = (0, i.toHash)(g);
    if (E.array && E.object) {
      const R = (0, n._)`typeof ${y} != "object"`;
      w = E.null ? R : (0, n._)`!${y} || ${R}`, delete E.null, delete E.array, delete E.object;
    } else
      w = n.nil;
    E.number && delete E.integer;
    for (const R in E)
      w = (0, n.and)(w, p(R, y, x, S));
    return w;
  }
  Ht.checkDataTypes = v;
  const m = {
    message: ({ schema: g }) => `must be ${g}`,
    params: ({ schema: g, schemaValue: y }) => typeof g == "string" ? (0, n._)`{type: ${g}}` : (0, n._)`{type: ${y}}`
  };
  function h(g) {
    const y = _(g);
    (0, r.reportError)(y, m);
  }
  Ht.reportTypeError = h;
  function _(g) {
    const { gen: y, data: x, schema: S } = g, w = (0, i.schemaRefOrVal)(g, S, "type");
    return {
      gen: y,
      keyword: "type",
      data: x,
      schema: S.type,
      schemaCode: w,
      schemaValue: w,
      parentSchema: S,
      params: {},
      it: g
    };
  }
  return Ht;
}
var ka = {}, hv;
function DR() {
  if (hv) return ka;
  hv = 1, Object.defineProperty(ka, "__esModule", { value: !0 }), ka.assignDefaults = void 0;
  const e = nt(), t = lt();
  function r(i, a) {
    const { properties: s, items: o } = i.schema;
    if (a === "object" && s)
      for (const c in s)
        n(i, c, s[c].default);
    else a === "array" && Array.isArray(o) && o.forEach((c, u) => n(i, u, c.default));
  }
  ka.assignDefaults = r;
  function n(i, a, s) {
    const { gen: o, compositeRule: c, data: u, opts: l } = i;
    if (s === void 0)
      return;
    const d = (0, e._)`${u}${(0, e.getProperty)(a)}`;
    if (c) {
      (0, t.checkStrictMode)(i, `default is ignored for: ${d}`);
      return;
    }
    let f = (0, e._)`${d} === undefined`;
    l.useDefaults === "empty" && (f = (0, e._)`${f} || ${d} === null || ${d} === ""`), o.if(f, (0, e._)`${d} = ${(0, e.stringify)(s)}`);
  }
  return ka;
}
var jr = {}, ht = {}, pv;
function en() {
  if (pv) return ht;
  pv = 1, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.validateUnion = ht.validateArray = ht.usePattern = ht.callValidateCode = ht.schemaProperties = ht.allSchemaProperties = ht.noPropertyInData = ht.propertyInData = ht.isOwnProperty = ht.hasPropFunc = ht.reportMissingProp = ht.checkMissingProp = ht.checkReportMissingProp = void 0;
  const e = nt(), t = lt(), r = Wn(), n = lt();
  function i(g, y) {
    const { gen: x, data: S, it: w } = g;
    x.if(l(x, S, y, w.opts.ownProperties), () => {
      g.setParams({ missingProperty: (0, e._)`${y}` }, !0), g.error();
    });
  }
  ht.checkReportMissingProp = i;
  function a({ gen: g, data: y, it: { opts: x } }, S, w) {
    return (0, e.or)(...S.map((E) => (0, e.and)(l(g, y, E, x.ownProperties), (0, e._)`${w} = ${E}`)));
  }
  ht.checkMissingProp = a;
  function s(g, y) {
    g.setParams({ missingProperty: y }, !0), g.error();
  }
  ht.reportMissingProp = s;
  function o(g) {
    return g.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, e._)`Object.prototype.hasOwnProperty`
    });
  }
  ht.hasPropFunc = o;
  function c(g, y, x) {
    return (0, e._)`${o(g)}.call(${y}, ${x})`;
  }
  ht.isOwnProperty = c;
  function u(g, y, x, S) {
    const w = (0, e._)`${y}${(0, e.getProperty)(x)} !== undefined`;
    return S ? (0, e._)`${w} && ${c(g, y, x)}` : w;
  }
  ht.propertyInData = u;
  function l(g, y, x, S) {
    const w = (0, e._)`${y}${(0, e.getProperty)(x)} === undefined`;
    return S ? (0, e.or)(w, (0, e.not)(c(g, y, x))) : w;
  }
  ht.noPropertyInData = l;
  function d(g) {
    return g ? Object.keys(g).filter((y) => y !== "__proto__") : [];
  }
  ht.allSchemaProperties = d;
  function f(g, y) {
    return d(y).filter((x) => !(0, t.alwaysValidSchema)(g, y[x]));
  }
  ht.schemaProperties = f;
  function p({ schemaCode: g, data: y, it: { gen: x, topSchemaRef: S, schemaPath: w, errorPath: E }, it: R }, N, B, F) {
    const U = F ? (0, e._)`${g}, ${y}, ${S}${w}` : y, G = [
      [r.default.instancePath, (0, e.strConcat)(r.default.instancePath, E)],
      [r.default.parentData, R.parentData],
      [r.default.parentDataProperty, R.parentDataProperty],
      [r.default.rootData, r.default.rootData]
    ];
    R.opts.dynamicRef && G.push([r.default.dynamicAnchors, r.default.dynamicAnchors]);
    const M = (0, e._)`${U}, ${x.object(...G)}`;
    return B !== e.nil ? (0, e._)`${N}.call(${B}, ${M})` : (0, e._)`${N}(${M})`;
  }
  ht.callValidateCode = p;
  const v = (0, e._)`new RegExp`;
  function m({ gen: g, it: { opts: y } }, x) {
    const S = y.unicodeRegExp ? "u" : "", { regExp: w } = y.code, E = w(x, S);
    return g.scopeValue("pattern", {
      key: E.toString(),
      ref: E,
      code: (0, e._)`${w.code === "new RegExp" ? v : (0, n.useFunc)(g, w)}(${x}, ${S})`
    });
  }
  ht.usePattern = m;
  function h(g) {
    const { gen: y, data: x, keyword: S, it: w } = g, E = y.name("valid");
    if (w.allErrors) {
      const N = y.let("valid", !0);
      return R(() => y.assign(N, !1)), N;
    }
    return y.var(E, !0), R(() => y.break()), E;
    function R(N) {
      const B = y.const("len", (0, e._)`${x}.length`);
      y.forRange("i", 0, B, (F) => {
        g.subschema({
          keyword: S,
          dataProp: F,
          dataPropType: t.Type.Num
        }, E), y.if((0, e.not)(E), N);
      });
    }
  }
  ht.validateArray = h;
  function _(g) {
    const { gen: y, schema: x, keyword: S, it: w } = g;
    if (!Array.isArray(x))
      throw new Error("ajv implementation error");
    if (x.some((B) => (0, t.alwaysValidSchema)(w, B)) && !w.opts.unevaluated)
      return;
    const R = y.let("valid", !1), N = y.name("_valid");
    y.block(() => x.forEach((B, F) => {
      const U = g.subschema({
        keyword: S,
        schemaProp: F,
        compositeRule: !0
      }, N);
      y.assign(R, (0, e._)`${R} || ${N}`), g.mergeValidEvaluated(U, N) || y.if((0, e.not)(R));
    })), g.result(R, () => g.reset(), () => g.error(!0));
  }
  return ht.validateUnion = _, ht;
}
var mv;
function kR() {
  if (mv) return jr;
  mv = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.validateKeywordUsage = jr.validSchemaType = jr.funcKeywordCode = jr.macroKeywordCode = void 0;
  const e = nt(), t = Wn(), r = en(), n = fl();
  function i(f, p) {
    const { gen: v, keyword: m, schema: h, parentSchema: _, it: g } = f, y = p.macro.call(g.self, h, _, g), x = u(v, m, y);
    g.opts.validateSchema !== !1 && g.self.validateSchema(y, !0);
    const S = v.name("valid");
    f.subschema({
      schema: y,
      schemaPath: e.nil,
      errSchemaPath: `${g.errSchemaPath}/${m}`,
      topSchemaRef: x,
      compositeRule: !0
    }, S), f.pass(S, () => f.error(!0));
  }
  jr.macroKeywordCode = i;
  function a(f, p) {
    var v;
    const { gen: m, keyword: h, schema: _, parentSchema: g, $data: y, it: x } = f;
    c(x, p);
    const S = !y && p.compile ? p.compile.call(x.self, _, g, x) : p.validate, w = u(m, h, S), E = m.let("valid");
    f.block$data(E, R), f.ok((v = p.valid) !== null && v !== void 0 ? v : E);
    function R() {
      if (p.errors === !1)
        F(), p.modifying && s(f), U(() => f.error());
      else {
        const G = p.async ? N() : B();
        p.modifying && s(f), U(() => o(f, G));
      }
    }
    function N() {
      const G = m.let("ruleErrs", null);
      return m.try(() => F((0, e._)`await `), (M) => m.assign(E, !1).if((0, e._)`${M} instanceof ${x.ValidationError}`, () => m.assign(G, (0, e._)`${M}.errors`), () => m.throw(M))), G;
    }
    function B() {
      const G = (0, e._)`${w}.errors`;
      return m.assign(G, null), F(e.nil), G;
    }
    function F(G = p.async ? (0, e._)`await ` : e.nil) {
      const M = x.opts.passContext ? t.default.this : t.default.self, V = !("compile" in p && !y || p.schema === !1);
      m.assign(E, (0, e._)`${G}${(0, r.callValidateCode)(f, w, M, V)}`, p.modifying);
    }
    function U(G) {
      var M;
      m.if((0, e.not)((M = p.valid) !== null && M !== void 0 ? M : E), G);
    }
  }
  jr.funcKeywordCode = a;
  function s(f) {
    const { gen: p, data: v, it: m } = f;
    p.if(m.parentData, () => p.assign(v, (0, e._)`${m.parentData}[${m.parentDataProperty}]`));
  }
  function o(f, p) {
    const { gen: v } = f;
    v.if((0, e._)`Array.isArray(${p})`, () => {
      v.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${p} : ${t.default.vErrors}.concat(${p})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, n.extendErrors)(f);
    }, () => f.error());
  }
  function c({ schemaEnv: f }, p) {
    if (p.async && !f.$async)
      throw new Error("async keyword in sync schema");
  }
  function u(f, p, v) {
    if (v === void 0)
      throw new Error(`keyword "${p}" failed to compile`);
    return f.scopeValue("keyword", typeof v == "function" ? { ref: v } : { ref: v, code: (0, e.stringify)(v) });
  }
  function l(f, p, v = !1) {
    return !p.length || p.some((m) => m === "array" ? Array.isArray(f) : m === "object" ? f && typeof f == "object" && !Array.isArray(f) : typeof f == m || v && typeof f > "u");
  }
  jr.validSchemaType = l;
  function d({ schema: f, opts: p, self: v, errSchemaPath: m }, h, _) {
    if (Array.isArray(h.keyword) ? !h.keyword.includes(_) : h.keyword !== _)
      throw new Error("ajv implementation error");
    const g = h.dependencies;
    if (g?.some((y) => !Object.prototype.hasOwnProperty.call(f, y)))
      throw new Error(`parent schema must have dependencies of ${_}: ${g.join(",")}`);
    if (h.validateSchema && !h.validateSchema(f[_])) {
      const x = `keyword "${_}" value is invalid at path "${m}": ` + v.errorsText(h.validateSchema.errors);
      if (p.validateSchema === "log")
        v.logger.error(x);
      else
        throw new Error(x);
    }
  }
  return jr.validateKeywordUsage = d, jr;
}
var yn = {}, gv;
function LR() {
  if (gv) return yn;
  gv = 1, Object.defineProperty(yn, "__esModule", { value: !0 }), yn.extendSubschemaMode = yn.extendSubschemaData = yn.getSubschema = void 0;
  const e = nt(), t = lt();
  function r(a, { keyword: s, schemaProp: o, schema: c, schemaPath: u, errSchemaPath: l, topSchemaRef: d }) {
    if (s !== void 0 && c !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (s !== void 0) {
      const f = a.schema[s];
      return o === void 0 ? {
        schema: f,
        schemaPath: (0, e._)`${a.schemaPath}${(0, e.getProperty)(s)}`,
        errSchemaPath: `${a.errSchemaPath}/${s}`
      } : {
        schema: f[o],
        schemaPath: (0, e._)`${a.schemaPath}${(0, e.getProperty)(s)}${(0, e.getProperty)(o)}`,
        errSchemaPath: `${a.errSchemaPath}/${s}/${(0, t.escapeFragment)(o)}`
      };
    }
    if (c !== void 0) {
      if (u === void 0 || l === void 0 || d === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: c,
        schemaPath: u,
        topSchemaRef: d,
        errSchemaPath: l
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  yn.getSubschema = r;
  function n(a, s, { dataProp: o, dataPropType: c, data: u, dataTypes: l, propertyName: d }) {
    if (u !== void 0 && o !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: f } = s;
    if (o !== void 0) {
      const { errorPath: v, dataPathArr: m, opts: h } = s, _ = f.let("data", (0, e._)`${s.data}${(0, e.getProperty)(o)}`, !0);
      p(_), a.errorPath = (0, e.str)`${v}${(0, t.getErrorPath)(o, c, h.jsPropertySyntax)}`, a.parentDataProperty = (0, e._)`${o}`, a.dataPathArr = [...m, a.parentDataProperty];
    }
    if (u !== void 0) {
      const v = u instanceof e.Name ? u : f.let("data", u, !0);
      p(v), d !== void 0 && (a.propertyName = d);
    }
    l && (a.dataTypes = l);
    function p(v) {
      a.data = v, a.dataLevel = s.dataLevel + 1, a.dataTypes = [], s.definedProperties = /* @__PURE__ */ new Set(), a.parentData = s.data, a.dataNames = [...s.dataNames, v];
    }
  }
  yn.extendSubschemaData = n;
  function i(a, { jtdDiscriminator: s, jtdMetadata: o, compositeRule: c, createErrors: u, allErrors: l }) {
    c !== void 0 && (a.compositeRule = c), u !== void 0 && (a.createErrors = u), l !== void 0 && (a.allErrors = l), a.jtdDiscriminator = s, a.jtdMetadata = o;
  }
  return yn.extendSubschemaMode = i, yn;
}
var cr = {}, Qf = { exports: {} }, vv;
function MR() {
  if (vv) return Qf.exports;
  vv = 1;
  var e = Qf.exports = function(n, i, a) {
    typeof i == "function" && (a = i, i = {}), a = i.cb || a;
    var s = typeof a == "function" ? a : a.pre || function() {
    }, o = a.post || function() {
    };
    t(i, s, o, n, "", n);
  };
  e.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, e.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, e.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, e.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function t(n, i, a, s, o, c, u, l, d, f) {
    if (s && typeof s == "object" && !Array.isArray(s)) {
      i(s, o, c, u, l, d, f);
      for (var p in s) {
        var v = s[p];
        if (Array.isArray(v)) {
          if (p in e.arrayKeywords)
            for (var m = 0; m < v.length; m++)
              t(n, i, a, v[m], o + "/" + p + "/" + m, c, o, p, s, m);
        } else if (p in e.propsKeywords) {
          if (v && typeof v == "object")
            for (var h in v)
              t(n, i, a, v[h], o + "/" + p + "/" + r(h), c, o, p, s, h);
        } else (p in e.keywords || n.allKeys && !(p in e.skipKeywords)) && t(n, i, a, v, o + "/" + p, c, o, p, s);
      }
      a(s, o, c, u, l, d, f);
    }
  }
  function r(n) {
    return n.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return Qf.exports;
}
var _v;
function dl() {
  if (_v) return cr;
  _v = 1, Object.defineProperty(cr, "__esModule", { value: !0 }), cr.getSchemaRefs = cr.resolveUrl = cr.normalizeId = cr._getFullPath = cr.getFullPath = cr.inlineRef = void 0;
  const e = lt(), t = sl(), r = MR(), n = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function i(m, h = !0) {
    return typeof m == "boolean" ? !0 : h === !0 ? !s(m) : h ? o(m) <= h : !1;
  }
  cr.inlineRef = i;
  const a = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function s(m) {
    for (const h in m) {
      if (a.has(h))
        return !0;
      const _ = m[h];
      if (Array.isArray(_) && _.some(s) || typeof _ == "object" && s(_))
        return !0;
    }
    return !1;
  }
  function o(m) {
    let h = 0;
    for (const _ in m) {
      if (_ === "$ref")
        return 1 / 0;
      if (h++, !n.has(_) && (typeof m[_] == "object" && (0, e.eachItem)(m[_], (g) => h += o(g)), h === 1 / 0))
        return 1 / 0;
    }
    return h;
  }
  function c(m, h = "", _) {
    _ !== !1 && (h = d(h));
    const g = m.parse(h);
    return u(m, g);
  }
  cr.getFullPath = c;
  function u(m, h) {
    return m.serialize(h).split("#")[0] + "#";
  }
  cr._getFullPath = u;
  const l = /#\/?$/;
  function d(m) {
    return m ? m.replace(l, "") : "";
  }
  cr.normalizeId = d;
  function f(m, h, _) {
    return _ = d(_), m.resolve(h, _);
  }
  cr.resolveUrl = f;
  const p = /^[a-z_][-a-z0-9._]*$/i;
  function v(m, h) {
    if (typeof m == "boolean")
      return {};
    const { schemaId: _, uriResolver: g } = this.opts, y = d(m[_] || h), x = { "": y }, S = c(g, y, !1), w = {}, E = /* @__PURE__ */ new Set();
    return r(m, { allKeys: !0 }, (B, F, U, G) => {
      if (G === void 0)
        return;
      const M = S + F;
      let V = x[G];
      typeof B[_] == "string" && (V = ie.call(this, B[_])), W.call(this, B.$anchor), W.call(this, B.$dynamicAnchor), x[F] = V;
      function ie(ae) {
        const se = this.opts.uriResolver.resolve;
        if (ae = d(V ? se(V, ae) : ae), E.has(ae))
          throw N(ae);
        E.add(ae);
        let X = this.refs[ae];
        return typeof X == "string" && (X = this.refs[X]), typeof X == "object" ? R(B, X.schema, ae) : ae !== d(M) && (ae[0] === "#" ? (R(B, w[ae], ae), w[ae] = B) : this.refs[ae] = M), ae;
      }
      function W(ae) {
        if (typeof ae == "string") {
          if (!p.test(ae))
            throw new Error(`invalid anchor "${ae}"`);
          ie.call(this, `#${ae}`);
        }
      }
    }), w;
    function R(B, F, U) {
      if (F !== void 0 && !t(B, F))
        throw N(U);
    }
    function N(B) {
      return new Error(`reference "${B}" resolves to more than one schema`);
    }
  }
  return cr.getSchemaRefs = v, cr;
}
var yv;
function hl() {
  if (yv) return vn;
  yv = 1, Object.defineProperty(vn, "__esModule", { value: !0 }), vn.getData = vn.KeywordCxt = vn.validateFunctionCode = void 0;
  const e = FR(), t = Ic(), r = KE(), n = Ic(), i = DR(), a = kR(), s = LR(), o = nt(), c = Wn(), u = dl(), l = lt(), d = fl();
  function f(D) {
    if (S(D) && (E(D), x(D))) {
      h(D);
      return;
    }
    p(D, () => (0, e.topBoolOrEmptySchema)(D));
  }
  vn.validateFunctionCode = f;
  function p({ gen: D, validateName: q, schema: J, schemaEnv: ne, opts: ce }, Ee) {
    ce.code.es5 ? D.func(q, (0, o._)`${c.default.data}, ${c.default.valCxt}`, ne.$async, () => {
      D.code((0, o._)`"use strict"; ${g(J, ce)}`), m(D, ce), D.code(Ee);
    }) : D.func(q, (0, o._)`${c.default.data}, ${v(ce)}`, ne.$async, () => D.code(g(J, ce)).code(Ee));
  }
  function v(D) {
    return (0, o._)`{${c.default.instancePath}="", ${c.default.parentData}, ${c.default.parentDataProperty}, ${c.default.rootData}=${c.default.data}${D.dynamicRef ? (0, o._)`, ${c.default.dynamicAnchors}={}` : o.nil}}={}`;
  }
  function m(D, q) {
    D.if(c.default.valCxt, () => {
      D.var(c.default.instancePath, (0, o._)`${c.default.valCxt}.${c.default.instancePath}`), D.var(c.default.parentData, (0, o._)`${c.default.valCxt}.${c.default.parentData}`), D.var(c.default.parentDataProperty, (0, o._)`${c.default.valCxt}.${c.default.parentDataProperty}`), D.var(c.default.rootData, (0, o._)`${c.default.valCxt}.${c.default.rootData}`), q.dynamicRef && D.var(c.default.dynamicAnchors, (0, o._)`${c.default.valCxt}.${c.default.dynamicAnchors}`);
    }, () => {
      D.var(c.default.instancePath, (0, o._)`""`), D.var(c.default.parentData, (0, o._)`undefined`), D.var(c.default.parentDataProperty, (0, o._)`undefined`), D.var(c.default.rootData, c.default.data), q.dynamicRef && D.var(c.default.dynamicAnchors, (0, o._)`{}`);
    });
  }
  function h(D) {
    const { schema: q, opts: J, gen: ne } = D;
    p(D, () => {
      J.$comment && q.$comment && G(D), B(D), ne.let(c.default.vErrors, null), ne.let(c.default.errors, 0), J.unevaluated && _(D), R(D), M(D);
    });
  }
  function _(D) {
    const { gen: q, validateName: J } = D;
    D.evaluated = q.const("evaluated", (0, o._)`${J}.evaluated`), q.if((0, o._)`${D.evaluated}.dynamicProps`, () => q.assign((0, o._)`${D.evaluated}.props`, (0, o._)`undefined`)), q.if((0, o._)`${D.evaluated}.dynamicItems`, () => q.assign((0, o._)`${D.evaluated}.items`, (0, o._)`undefined`));
  }
  function g(D, q) {
    const J = typeof D == "object" && D[q.schemaId];
    return J && (q.code.source || q.code.process) ? (0, o._)`/*# sourceURL=${J} */` : o.nil;
  }
  function y(D, q) {
    if (S(D) && (E(D), x(D))) {
      w(D, q);
      return;
    }
    (0, e.boolOrEmptySchema)(D, q);
  }
  function x({ schema: D, self: q }) {
    if (typeof D == "boolean")
      return !D;
    for (const J in D)
      if (q.RULES.all[J])
        return !0;
    return !1;
  }
  function S(D) {
    return typeof D.schema != "boolean";
  }
  function w(D, q) {
    const { schema: J, gen: ne, opts: ce } = D;
    ce.$comment && J.$comment && G(D), F(D), U(D);
    const Ee = ne.const("_errs", c.default.errors);
    R(D, Ee), ne.var(q, (0, o._)`${Ee} === ${c.default.errors}`);
  }
  function E(D) {
    (0, l.checkUnknownRules)(D), N(D);
  }
  function R(D, q) {
    if (D.opts.jtd)
      return ie(D, [], !1, q);
    const J = (0, t.getSchemaTypes)(D.schema), ne = (0, t.coerceAndCheckDataType)(D, J);
    ie(D, J, !ne, q);
  }
  function N(D) {
    const { schema: q, errSchemaPath: J, opts: ne, self: ce } = D;
    q.$ref && ne.ignoreKeywordsWithRef && (0, l.schemaHasRulesButRef)(q, ce.RULES) && ce.logger.warn(`$ref: keywords ignored in schema at path "${J}"`);
  }
  function B(D) {
    const { schema: q, opts: J } = D;
    q.default !== void 0 && J.useDefaults && J.strictSchema && (0, l.checkStrictMode)(D, "default is ignored in the schema root");
  }
  function F(D) {
    const q = D.schema[D.opts.schemaId];
    q && (D.baseId = (0, u.resolveUrl)(D.opts.uriResolver, D.baseId, q));
  }
  function U(D) {
    if (D.schema.$async && !D.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function G({ gen: D, schemaEnv: q, schema: J, errSchemaPath: ne, opts: ce }) {
    const Ee = J.$comment;
    if (ce.$comment === !0)
      D.code((0, o._)`${c.default.self}.logger.log(${Ee})`);
    else if (typeof ce.$comment == "function") {
      const ge = (0, o.str)`${ne}/$comment`, Ge = D.scopeValue("root", { ref: q.root });
      D.code((0, o._)`${c.default.self}.opts.$comment(${Ee}, ${ge}, ${Ge}.schema)`);
    }
  }
  function M(D) {
    const { gen: q, schemaEnv: J, validateName: ne, ValidationError: ce, opts: Ee } = D;
    J.$async ? q.if((0, o._)`${c.default.errors} === 0`, () => q.return(c.default.data), () => q.throw((0, o._)`new ${ce}(${c.default.vErrors})`)) : (q.assign((0, o._)`${ne}.errors`, c.default.vErrors), Ee.unevaluated && V(D), q.return((0, o._)`${c.default.errors} === 0`));
  }
  function V({ gen: D, evaluated: q, props: J, items: ne }) {
    J instanceof o.Name && D.assign((0, o._)`${q}.props`, J), ne instanceof o.Name && D.assign((0, o._)`${q}.items`, ne);
  }
  function ie(D, q, J, ne) {
    const { gen: ce, schema: Ee, data: ge, allErrors: Ge, opts: ze, self: Xe } = D, { RULES: He } = Xe;
    if (Ee.$ref && (ze.ignoreKeywordsWithRef || !(0, l.schemaHasRulesButRef)(Ee, He))) {
      ce.block(() => b(D, "$ref", He.all.$ref.definition));
      return;
    }
    ze.jtd || ae(D, q), ce.block(() => {
      for (const le of He.rules)
        O(le);
      O(He.post);
    });
    function O(le) {
      (0, r.shouldUseGroup)(Ee, le) && (le.type ? (ce.if((0, n.checkDataType)(le.type, ge, ze.strictNumbers)), W(D, le), q.length === 1 && q[0] === le.type && J && (ce.else(), (0, n.reportTypeError)(D)), ce.endIf()) : W(D, le), Ge || ce.if((0, o._)`${c.default.errors} === ${ne || 0}`));
    }
  }
  function W(D, q) {
    const { gen: J, schema: ne, opts: { useDefaults: ce } } = D;
    ce && (0, i.assignDefaults)(D, q.type), J.block(() => {
      for (const Ee of q.rules)
        (0, r.shouldUseRule)(ne, Ee) && b(D, Ee.keyword, Ee.definition, q.type);
    });
  }
  function ae(D, q) {
    D.schemaEnv.meta || !D.opts.strictTypes || (se(D, q), D.opts.allowUnionTypes || X(D, q), k(D, D.dataTypes));
  }
  function se(D, q) {
    if (q.length) {
      if (!D.dataTypes.length) {
        D.dataTypes = q;
        return;
      }
      q.forEach((J) => {
        C(D.dataTypes, J) || A(D, `type "${J}" not allowed by context "${D.dataTypes.join(",")}"`);
      }), T(D, q);
    }
  }
  function X(D, q) {
    q.length > 1 && !(q.length === 2 && q.includes("null")) && A(D, "use allowUnionTypes to allow union type keyword");
  }
  function k(D, q) {
    const J = D.self.RULES.all;
    for (const ne in J) {
      const ce = J[ne];
      if (typeof ce == "object" && (0, r.shouldUseRule)(D.schema, ce)) {
        const { type: Ee } = ce.definition;
        Ee.length && !Ee.some((ge) => I(q, ge)) && A(D, `missing type "${Ee.join(",")}" for keyword "${ne}"`);
      }
    }
  }
  function I(D, q) {
    return D.includes(q) || q === "number" && D.includes("integer");
  }
  function C(D, q) {
    return D.includes(q) || q === "integer" && D.includes("number");
  }
  function T(D, q) {
    const J = [];
    for (const ne of D.dataTypes)
      C(q, ne) ? J.push(ne) : q.includes("integer") && ne === "number" && J.push("integer");
    D.dataTypes = J;
  }
  function A(D, q) {
    const J = D.schemaEnv.baseId + D.errSchemaPath;
    q += ` at "${J}" (strictTypes)`, (0, l.checkStrictMode)(D, q, D.opts.strictTypes);
  }
  class L {
    constructor(q, J, ne) {
      if ((0, a.validateKeywordUsage)(q, J, ne), this.gen = q.gen, this.allErrors = q.allErrors, this.keyword = ne, this.data = q.data, this.schema = q.schema[ne], this.$data = J.$data && q.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, l.schemaRefOrVal)(q, this.schema, ne, this.$data), this.schemaType = J.schemaType, this.parentSchema = q.schema, this.params = {}, this.it = q, this.def = J, this.$data)
        this.schemaCode = q.gen.const("vSchema", H(this.$data, q));
      else if (this.schemaCode = this.schemaValue, !(0, a.validSchemaType)(this.schema, J.schemaType, J.allowUndefined))
        throw new Error(`${ne} value must be ${JSON.stringify(J.schemaType)}`);
      ("code" in J ? J.trackErrors : J.errors !== !1) && (this.errsCount = q.gen.const("_errs", c.default.errors));
    }
    result(q, J, ne) {
      this.failResult((0, o.not)(q), J, ne);
    }
    failResult(q, J, ne) {
      this.gen.if(q), ne ? ne() : this.error(), J ? (this.gen.else(), J(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(q, J) {
      this.failResult((0, o.not)(q), void 0, J);
    }
    fail(q) {
      if (q === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(q), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(q) {
      if (!this.$data)
        return this.fail(q);
      const { schemaCode: J } = this;
      this.fail((0, o._)`${J} !== undefined && (${(0, o.or)(this.invalid$data(), q)})`);
    }
    error(q, J, ne) {
      if (J) {
        this.setParams(J), this._error(q, ne), this.setParams({});
        return;
      }
      this._error(q, ne);
    }
    _error(q, J) {
      (q ? d.reportExtraError : d.reportError)(this, this.def.error, J);
    }
    $dataError() {
      (0, d.reportError)(this, this.def.$dataError || d.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, d.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(q) {
      this.allErrors || this.gen.if(q);
    }
    setParams(q, J) {
      J ? Object.assign(this.params, q) : this.params = q;
    }
    block$data(q, J, ne = o.nil) {
      this.gen.block(() => {
        this.check$data(q, ne), J();
      });
    }
    check$data(q = o.nil, J = o.nil) {
      if (!this.$data)
        return;
      const { gen: ne, schemaCode: ce, schemaType: Ee, def: ge } = this;
      ne.if((0, o.or)((0, o._)`${ce} === undefined`, J)), q !== o.nil && ne.assign(q, !0), (Ee.length || ge.validateSchema) && (ne.elseIf(this.invalid$data()), this.$dataError(), q !== o.nil && ne.assign(q, !1)), ne.else();
    }
    invalid$data() {
      const { gen: q, schemaCode: J, schemaType: ne, def: ce, it: Ee } = this;
      return (0, o.or)(ge(), Ge());
      function ge() {
        if (ne.length) {
          if (!(J instanceof o.Name))
            throw new Error("ajv implementation error");
          const ze = Array.isArray(ne) ? ne : [ne];
          return (0, o._)`${(0, n.checkDataTypes)(ze, J, Ee.opts.strictNumbers, n.DataType.Wrong)}`;
        }
        return o.nil;
      }
      function Ge() {
        if (ce.validateSchema) {
          const ze = q.scopeValue("validate$data", { ref: ce.validateSchema });
          return (0, o._)`!${ze}(${J})`;
        }
        return o.nil;
      }
    }
    subschema(q, J) {
      const ne = (0, s.getSubschema)(this.it, q);
      (0, s.extendSubschemaData)(ne, this.it, q), (0, s.extendSubschemaMode)(ne, q);
      const ce = { ...this.it, ...ne, items: void 0, props: void 0 };
      return y(ce, J), ce;
    }
    mergeEvaluated(q, J) {
      const { it: ne, gen: ce } = this;
      ne.opts.unevaluated && (ne.props !== !0 && q.props !== void 0 && (ne.props = l.mergeEvaluated.props(ce, q.props, ne.props, J)), ne.items !== !0 && q.items !== void 0 && (ne.items = l.mergeEvaluated.items(ce, q.items, ne.items, J)));
    }
    mergeValidEvaluated(q, J) {
      const { it: ne, gen: ce } = this;
      if (ne.opts.unevaluated && (ne.props !== !0 || ne.items !== !0))
        return ce.if(J, () => this.mergeEvaluated(q, o.Name)), !0;
    }
  }
  vn.KeywordCxt = L;
  function b(D, q, J, ne) {
    const ce = new L(D, J, q);
    "code" in J ? J.code(ce, ne) : ce.$data && J.validate ? (0, a.funcKeywordCode)(ce, J) : "macro" in J ? (0, a.macroKeywordCode)(ce, J) : (J.compile || J.validate) && (0, a.funcKeywordCode)(ce, J);
  }
  const P = /^\/(?:[^~]|~0|~1)*$/, te = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function H(D, { dataLevel: q, dataNames: J, dataPathArr: ne }) {
    let ce, Ee;
    if (D === "")
      return c.default.rootData;
    if (D[0] === "/") {
      if (!P.test(D))
        throw new Error(`Invalid JSON-pointer: ${D}`);
      ce = D, Ee = c.default.rootData;
    } else {
      const Xe = te.exec(D);
      if (!Xe)
        throw new Error(`Invalid JSON-pointer: ${D}`);
      const He = +Xe[1];
      if (ce = Xe[2], ce === "#") {
        if (He >= q)
          throw new Error(ze("property/index", He));
        return ne[q - He];
      }
      if (He > q)
        throw new Error(ze("data", He));
      if (Ee = J[q - He], !ce)
        return Ee;
    }
    let ge = Ee;
    const Ge = ce.split("/");
    for (const Xe of Ge)
      Xe && (Ee = (0, o._)`${Ee}${(0, o.getProperty)((0, l.unescapeJsonPointer)(Xe))}`, ge = (0, o._)`${ge} && ${Ee}`);
    return ge;
    function ze(Xe, He) {
      return `Cannot access ${Xe} ${He} levels up, current level is ${q}`;
    }
  }
  return vn.getData = H, vn;
}
var Io = {}, Ev;
function F0() {
  if (Ev) return Io;
  Ev = 1, Object.defineProperty(Io, "__esModule", { value: !0 });
  class e extends Error {
    constructor(r) {
      super("validation failed"), this.errors = r, this.ajv = this.validation = !0;
    }
  }
  return Io.default = e, Io;
}
var bo = {}, wv;
function pl() {
  if (wv) return bo;
  wv = 1, Object.defineProperty(bo, "__esModule", { value: !0 });
  const e = dl();
  class t extends Error {
    constructor(n, i, a, s) {
      super(s || `can't resolve reference ${a} from id ${i}`), this.missingRef = (0, e.resolveUrl)(n, i, a), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(n, this.missingRef));
    }
  }
  return bo.default = t, bo;
}
var Ar = {}, xv;
function D0() {
  if (xv) return Ar;
  xv = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.resolveSchema = Ar.getCompilingSchema = Ar.resolveRef = Ar.compileSchema = Ar.SchemaEnv = void 0;
  const e = nt(), t = F0(), r = Wn(), n = dl(), i = lt(), a = hl();
  class s {
    constructor(_) {
      var g;
      this.refs = {}, this.dynamicAnchors = {};
      let y;
      typeof _.schema == "object" && (y = _.schema), this.schema = _.schema, this.schemaId = _.schemaId, this.root = _.root || this, this.baseId = (g = _.baseId) !== null && g !== void 0 ? g : (0, n.normalizeId)(y?.[_.schemaId || "$id"]), this.schemaPath = _.schemaPath, this.localRefs = _.localRefs, this.meta = _.meta, this.$async = y?.$async, this.refs = {};
    }
  }
  Ar.SchemaEnv = s;
  function o(h) {
    const _ = l.call(this, h);
    if (_)
      return _;
    const g = (0, n.getFullPath)(this.opts.uriResolver, h.root.baseId), { es5: y, lines: x } = this.opts.code, { ownProperties: S } = this.opts, w = new e.CodeGen(this.scope, { es5: y, lines: x, ownProperties: S });
    let E;
    h.$async && (E = w.scopeValue("Error", {
      ref: t.default,
      code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const R = w.scopeName("validate");
    h.validateName = R;
    const N = {
      gen: w,
      allErrors: this.opts.allErrors,
      data: r.default.data,
      parentData: r.default.parentData,
      parentDataProperty: r.default.parentDataProperty,
      dataNames: [r.default.data],
      dataPathArr: [e.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: w.scopeValue("schema", this.opts.code.source === !0 ? { ref: h.schema, code: (0, e.stringify)(h.schema) } : { ref: h.schema }),
      validateName: R,
      ValidationError: E,
      schema: h.schema,
      schemaEnv: h,
      rootId: g,
      baseId: h.baseId || g,
      schemaPath: e.nil,
      errSchemaPath: h.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, e._)`""`,
      opts: this.opts,
      self: this
    };
    let B;
    try {
      this._compilations.add(h), (0, a.validateFunctionCode)(N), w.optimize(this.opts.code.optimize);
      const F = w.toString();
      B = `${w.scopeRefs(r.default.scope)}return ${F}`, this.opts.code.process && (B = this.opts.code.process(B, h));
      const G = new Function(`${r.default.self}`, `${r.default.scope}`, B)(this, this.scope.get());
      if (this.scope.value(R, { ref: G }), G.errors = null, G.schema = h.schema, G.schemaEnv = h, h.$async && (G.$async = !0), this.opts.code.source === !0 && (G.source = { validateName: R, validateCode: F, scopeValues: w._values }), this.opts.unevaluated) {
        const { props: M, items: V } = N;
        G.evaluated = {
          props: M instanceof e.Name ? void 0 : M,
          items: V instanceof e.Name ? void 0 : V,
          dynamicProps: M instanceof e.Name,
          dynamicItems: V instanceof e.Name
        }, G.source && (G.source.evaluated = (0, e.stringify)(G.evaluated));
      }
      return h.validate = G, h;
    } catch (F) {
      throw delete h.validate, delete h.validateName, B && this.logger.error("Error compiling schema, function code:", B), F;
    } finally {
      this._compilations.delete(h);
    }
  }
  Ar.compileSchema = o;
  function c(h, _, g) {
    var y;
    g = (0, n.resolveUrl)(this.opts.uriResolver, _, g);
    const x = h.refs[g];
    if (x)
      return x;
    let S = f.call(this, h, g);
    if (S === void 0) {
      const w = (y = h.localRefs) === null || y === void 0 ? void 0 : y[g], { schemaId: E } = this.opts;
      w && (S = new s({ schema: w, schemaId: E, root: h, baseId: _ }));
    }
    if (S !== void 0)
      return h.refs[g] = u.call(this, S);
  }
  Ar.resolveRef = c;
  function u(h) {
    return (0, n.inlineRef)(h.schema, this.opts.inlineRefs) ? h.schema : h.validate ? h : o.call(this, h);
  }
  function l(h) {
    for (const _ of this._compilations)
      if (d(_, h))
        return _;
  }
  Ar.getCompilingSchema = l;
  function d(h, _) {
    return h.schema === _.schema && h.root === _.root && h.baseId === _.baseId;
  }
  function f(h, _) {
    let g;
    for (; typeof (g = this.refs[_]) == "string"; )
      _ = g;
    return g || this.schemas[_] || p.call(this, h, _);
  }
  function p(h, _) {
    const g = this.opts.uriResolver.parse(_), y = (0, n._getFullPath)(this.opts.uriResolver, g);
    let x = (0, n.getFullPath)(this.opts.uriResolver, h.baseId, void 0);
    if (Object.keys(h.schema).length > 0 && y === x)
      return m.call(this, g, h);
    const S = (0, n.normalizeId)(y), w = this.refs[S] || this.schemas[S];
    if (typeof w == "string") {
      const E = p.call(this, h, w);
      return typeof E?.schema != "object" ? void 0 : m.call(this, g, E);
    }
    if (typeof w?.schema == "object") {
      if (w.validate || o.call(this, w), S === (0, n.normalizeId)(_)) {
        const { schema: E } = w, { schemaId: R } = this.opts, N = E[R];
        return N && (x = (0, n.resolveUrl)(this.opts.uriResolver, x, N)), new s({ schema: E, schemaId: R, root: h, baseId: x });
      }
      return m.call(this, g, w);
    }
  }
  Ar.resolveSchema = p;
  const v = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function m(h, { baseId: _, schema: g, root: y }) {
    var x;
    if (((x = h.fragment) === null || x === void 0 ? void 0 : x[0]) !== "/")
      return;
    for (const E of h.fragment.slice(1).split("/")) {
      if (typeof g == "boolean")
        return;
      const R = g[(0, i.unescapeFragment)(E)];
      if (R === void 0)
        return;
      g = R;
      const N = typeof g == "object" && g[this.opts.schemaId];
      !v.has(E) && N && (_ = (0, n.resolveUrl)(this.opts.uriResolver, _, N));
    }
    let S;
    if (typeof g != "boolean" && g.$ref && !(0, i.schemaHasRulesButRef)(g, this.RULES)) {
      const E = (0, n.resolveUrl)(this.opts.uriResolver, _, g.$ref);
      S = p.call(this, y, E);
    }
    const { schemaId: w } = this.opts;
    if (S = S || new s({ schema: g, schemaId: w, root: y, baseId: _ }), S.schema !== S.root.schema)
      return S;
  }
  return Ar;
}
const UR = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", qR = "Meta-schema for $data reference (JSON AnySchema extension proposal)", BR = "object", jR = ["$data"], VR = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, HR = !1, GR = {
  $id: UR,
  description: qR,
  type: BR,
  required: jR,
  properties: VR,
  additionalProperties: HR
};
var Fo = {}, Tv;
function zR() {
  if (Tv) return Fo;
  Tv = 1, Object.defineProperty(Fo, "__esModule", { value: !0 });
  const e = jE();
  return e.code = 'require("ajv/dist/runtime/uri").default', Fo.default = e, Fo;
}
var Sv;
function WR() {
  return Sv || (Sv = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
    var t = hl();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return t.KeywordCxt;
    } });
    var r = nt();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return r.CodeGen;
    } });
    const n = F0(), i = pl(), a = XE(), s = D0(), o = nt(), c = dl(), u = Ic(), l = lt(), d = GR, f = zR(), p = (X, k) => new RegExp(X, k);
    p.code = "new RegExp";
    const v = ["removeAdditional", "useDefaults", "coerceTypes"], m = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), h = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, _ = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, g = 200;
    function y(X) {
      var k, I, C, T, A, L, b, P, te, H, D, q, J, ne, ce, Ee, ge, Ge, ze, Xe, He, O, le, me, Ne;
      const _e = X.strict, $e = (k = X.code) === null || k === void 0 ? void 0 : k.optimize, Ae = $e === !0 || $e === void 0 ? 1 : $e || 0, De = (C = (I = X.code) === null || I === void 0 ? void 0 : I.regExp) !== null && C !== void 0 ? C : p, Me = (T = X.uriResolver) !== null && T !== void 0 ? T : f.default;
      return {
        strictSchema: (L = (A = X.strictSchema) !== null && A !== void 0 ? A : _e) !== null && L !== void 0 ? L : !0,
        strictNumbers: (P = (b = X.strictNumbers) !== null && b !== void 0 ? b : _e) !== null && P !== void 0 ? P : !0,
        strictTypes: (H = (te = X.strictTypes) !== null && te !== void 0 ? te : _e) !== null && H !== void 0 ? H : "log",
        strictTuples: (q = (D = X.strictTuples) !== null && D !== void 0 ? D : _e) !== null && q !== void 0 ? q : "log",
        strictRequired: (ne = (J = X.strictRequired) !== null && J !== void 0 ? J : _e) !== null && ne !== void 0 ? ne : !1,
        code: X.code ? { ...X.code, optimize: Ae, regExp: De } : { optimize: Ae, regExp: De },
        loopRequired: (ce = X.loopRequired) !== null && ce !== void 0 ? ce : g,
        loopEnum: (Ee = X.loopEnum) !== null && Ee !== void 0 ? Ee : g,
        meta: (ge = X.meta) !== null && ge !== void 0 ? ge : !0,
        messages: (Ge = X.messages) !== null && Ge !== void 0 ? Ge : !0,
        inlineRefs: (ze = X.inlineRefs) !== null && ze !== void 0 ? ze : !0,
        schemaId: (Xe = X.schemaId) !== null && Xe !== void 0 ? Xe : "$id",
        addUsedSchema: (He = X.addUsedSchema) !== null && He !== void 0 ? He : !0,
        validateSchema: (O = X.validateSchema) !== null && O !== void 0 ? O : !0,
        validateFormats: (le = X.validateFormats) !== null && le !== void 0 ? le : !0,
        unicodeRegExp: (me = X.unicodeRegExp) !== null && me !== void 0 ? me : !0,
        int32range: (Ne = X.int32range) !== null && Ne !== void 0 ? Ne : !0,
        uriResolver: Me
      };
    }
    class x {
      constructor(k = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), k = this.opts = { ...k, ...y(k) };
        const { es5: I, lines: C } = this.opts.code;
        this.scope = new o.ValueScope({ scope: {}, prefixes: m, es5: I, lines: C }), this.logger = U(k.logger);
        const T = k.validateFormats;
        k.validateFormats = !1, this.RULES = (0, a.getRules)(), S.call(this, h, k, "NOT SUPPORTED"), S.call(this, _, k, "DEPRECATED", "warn"), this._metaOpts = B.call(this), k.formats && R.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), k.keywords && N.call(this, k.keywords), typeof k.meta == "object" && this.addMetaSchema(k.meta), E.call(this), k.validateFormats = T;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: k, meta: I, schemaId: C } = this.opts;
        let T = d;
        C === "id" && (T = { ...d }, T.id = T.$id, delete T.$id), I && k && this.addMetaSchema(T, T[C], !1);
      }
      defaultMeta() {
        const { meta: k, schemaId: I } = this.opts;
        return this.opts.defaultMeta = typeof k == "object" ? k[I] || k : void 0;
      }
      validate(k, I) {
        let C;
        if (typeof k == "string") {
          if (C = this.getSchema(k), !C)
            throw new Error(`no schema with key or ref "${k}"`);
        } else
          C = this.compile(k);
        const T = C(I);
        return "$async" in C || (this.errors = C.errors), T;
      }
      compile(k, I) {
        const C = this._addSchema(k, I);
        return C.validate || this._compileSchemaEnv(C);
      }
      compileAsync(k, I) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: C } = this.opts;
        return T.call(this, k, I);
        async function T(H, D) {
          await A.call(this, H.$schema);
          const q = this._addSchema(H, D);
          return q.validate || L.call(this, q);
        }
        async function A(H) {
          H && !this.getSchema(H) && await T.call(this, { $ref: H }, !0);
        }
        async function L(H) {
          try {
            return this._compileSchemaEnv(H);
          } catch (D) {
            if (!(D instanceof i.default))
              throw D;
            return b.call(this, D), await P.call(this, D.missingSchema), L.call(this, H);
          }
        }
        function b({ missingSchema: H, missingRef: D }) {
          if (this.refs[H])
            throw new Error(`AnySchema ${H} is loaded but ${D} cannot be resolved`);
        }
        async function P(H) {
          const D = await te.call(this, H);
          this.refs[H] || await A.call(this, D.$schema), this.refs[H] || this.addSchema(D, H, I);
        }
        async function te(H) {
          const D = this._loading[H];
          if (D)
            return D;
          try {
            return await (this._loading[H] = C(H));
          } finally {
            delete this._loading[H];
          }
        }
      }
      // Adds schema to the instance
      addSchema(k, I, C, T = this.opts.validateSchema) {
        if (Array.isArray(k)) {
          for (const L of k)
            this.addSchema(L, void 0, C, T);
          return this;
        }
        let A;
        if (typeof k == "object") {
          const { schemaId: L } = this.opts;
          if (A = k[L], A !== void 0 && typeof A != "string")
            throw new Error(`schema ${L} must be string`);
        }
        return I = (0, c.normalizeId)(I || A), this._checkUnique(I), this.schemas[I] = this._addSchema(k, C, I, T, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(k, I, C = this.opts.validateSchema) {
        return this.addSchema(k, I, !0, C), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(k, I) {
        if (typeof k == "boolean")
          return !0;
        let C;
        if (C = k.$schema, C !== void 0 && typeof C != "string")
          throw new Error("$schema must be a string");
        if (C = C || this.opts.defaultMeta || this.defaultMeta(), !C)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const T = this.validate(C, k);
        if (!T && I) {
          const A = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(A);
          else
            throw new Error(A);
        }
        return T;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(k) {
        let I;
        for (; typeof (I = w.call(this, k)) == "string"; )
          k = I;
        if (I === void 0) {
          const { schemaId: C } = this.opts, T = new s.SchemaEnv({ schema: {}, schemaId: C });
          if (I = s.resolveSchema.call(this, T, k), !I)
            return;
          this.refs[k] = I;
        }
        return I.validate || this._compileSchemaEnv(I);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(k) {
        if (k instanceof RegExp)
          return this._removeAllSchemas(this.schemas, k), this._removeAllSchemas(this.refs, k), this;
        switch (typeof k) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const I = w.call(this, k);
            return typeof I == "object" && this._cache.delete(I.schema), delete this.schemas[k], delete this.refs[k], this;
          }
          case "object": {
            const I = k;
            this._cache.delete(I);
            let C = k[this.opts.schemaId];
            return C && (C = (0, c.normalizeId)(C), delete this.schemas[C], delete this.refs[C]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(k) {
        for (const I of k)
          this.addKeyword(I);
        return this;
      }
      addKeyword(k, I) {
        let C;
        if (typeof k == "string")
          C = k, typeof I == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), I.keyword = C);
        else if (typeof k == "object" && I === void 0) {
          if (I = k, C = I.keyword, Array.isArray(C) && !C.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (M.call(this, C, I), !I)
          return (0, l.eachItem)(C, (A) => V.call(this, A)), this;
        W.call(this, I);
        const T = {
          ...I,
          type: (0, u.getJSONTypes)(I.type),
          schemaType: (0, u.getJSONTypes)(I.schemaType)
        };
        return (0, l.eachItem)(C, T.type.length === 0 ? (A) => V.call(this, A, T) : (A) => T.type.forEach((L) => V.call(this, A, T, L))), this;
      }
      getKeyword(k) {
        const I = this.RULES.all[k];
        return typeof I == "object" ? I.definition : !!I;
      }
      // Remove keyword
      removeKeyword(k) {
        const { RULES: I } = this;
        delete I.keywords[k], delete I.all[k];
        for (const C of I.rules) {
          const T = C.rules.findIndex((A) => A.keyword === k);
          T >= 0 && C.rules.splice(T, 1);
        }
        return this;
      }
      // Add format
      addFormat(k, I) {
        return typeof I == "string" && (I = new RegExp(I)), this.formats[k] = I, this;
      }
      errorsText(k = this.errors, { separator: I = ", ", dataVar: C = "data" } = {}) {
        return !k || k.length === 0 ? "No errors" : k.map((T) => `${C}${T.instancePath} ${T.message}`).reduce((T, A) => T + I + A);
      }
      $dataMetaSchema(k, I) {
        const C = this.RULES.all;
        k = JSON.parse(JSON.stringify(k));
        for (const T of I) {
          const A = T.split("/").slice(1);
          let L = k;
          for (const b of A)
            L = L[b];
          for (const b in C) {
            const P = C[b];
            if (typeof P != "object")
              continue;
            const { $data: te } = P.definition, H = L[b];
            te && H && (L[b] = se(H));
          }
        }
        return k;
      }
      _removeAllSchemas(k, I) {
        for (const C in k) {
          const T = k[C];
          (!I || I.test(C)) && (typeof T == "string" ? delete k[C] : T && !T.meta && (this._cache.delete(T.schema), delete k[C]));
        }
      }
      _addSchema(k, I, C, T = this.opts.validateSchema, A = this.opts.addUsedSchema) {
        let L;
        const { schemaId: b } = this.opts;
        if (typeof k == "object")
          L = k[b];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof k != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let P = this._cache.get(k);
        if (P !== void 0)
          return P;
        C = (0, c.normalizeId)(L || C);
        const te = c.getSchemaRefs.call(this, k, C);
        return P = new s.SchemaEnv({ schema: k, schemaId: b, meta: I, baseId: C, localRefs: te }), this._cache.set(P.schema, P), A && !C.startsWith("#") && (C && this._checkUnique(C), this.refs[C] = P), T && this.validateSchema(k, !0), P;
      }
      _checkUnique(k) {
        if (this.schemas[k] || this.refs[k])
          throw new Error(`schema with key or id "${k}" already exists`);
      }
      _compileSchemaEnv(k) {
        if (k.meta ? this._compileMetaSchema(k) : s.compileSchema.call(this, k), !k.validate)
          throw new Error("ajv implementation error");
        return k.validate;
      }
      _compileMetaSchema(k) {
        const I = this.opts;
        this.opts = this._metaOpts;
        try {
          s.compileSchema.call(this, k);
        } finally {
          this.opts = I;
        }
      }
    }
    x.ValidationError = n.default, x.MissingRefError = i.default, e.default = x;
    function S(X, k, I, C = "error") {
      for (const T in X) {
        const A = T;
        A in k && this.logger[C](`${I}: option ${T}. ${X[A]}`);
      }
    }
    function w(X) {
      return X = (0, c.normalizeId)(X), this.schemas[X] || this.refs[X];
    }
    function E() {
      const X = this.opts.schemas;
      if (X)
        if (Array.isArray(X))
          this.addSchema(X);
        else
          for (const k in X)
            this.addSchema(X[k], k);
    }
    function R() {
      for (const X in this.opts.formats) {
        const k = this.opts.formats[X];
        k && this.addFormat(X, k);
      }
    }
    function N(X) {
      if (Array.isArray(X)) {
        this.addVocabulary(X);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const k in X) {
        const I = X[k];
        I.keyword || (I.keyword = k), this.addKeyword(I);
      }
    }
    function B() {
      const X = { ...this.opts };
      for (const k of v)
        delete X[k];
      return X;
    }
    const F = { log() {
    }, warn() {
    }, error() {
    } };
    function U(X) {
      if (X === !1)
        return F;
      if (X === void 0)
        return console;
      if (X.log && X.warn && X.error)
        return X;
      throw new Error("logger must implement log, warn and error methods");
    }
    const G = /^[a-z_$][a-z0-9_$:-]*$/i;
    function M(X, k) {
      const { RULES: I } = this;
      if ((0, l.eachItem)(X, (C) => {
        if (I.keywords[C])
          throw new Error(`Keyword ${C} is already defined`);
        if (!G.test(C))
          throw new Error(`Keyword ${C} has invalid name`);
      }), !!k && k.$data && !("code" in k || "validate" in k))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function V(X, k, I) {
      var C;
      const T = k?.post;
      if (I && T)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: A } = this;
      let L = T ? A.post : A.rules.find(({ type: P }) => P === I);
      if (L || (L = { type: I, rules: [] }, A.rules.push(L)), A.keywords[X] = !0, !k)
        return;
      const b = {
        keyword: X,
        definition: {
          ...k,
          type: (0, u.getJSONTypes)(k.type),
          schemaType: (0, u.getJSONTypes)(k.schemaType)
        }
      };
      k.before ? ie.call(this, L, b, k.before) : L.rules.push(b), A.all[X] = b, (C = k.implements) === null || C === void 0 || C.forEach((P) => this.addKeyword(P));
    }
    function ie(X, k, I) {
      const C = X.rules.findIndex((T) => T.keyword === I);
      C >= 0 ? X.rules.splice(C, 0, k) : (X.rules.push(k), this.logger.warn(`rule ${I} is not defined`));
    }
    function W(X) {
      let { metaSchema: k } = X;
      k !== void 0 && (X.$data && this.opts.$data && (k = se(k)), X.validateSchema = this.compile(k, !0));
    }
    const ae = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function se(X) {
      return { anyOf: [X, ae] };
    }
  })(Wf)), Wf;
}
var Do = {}, ko = {}, Lo = {}, Av;
function XR() {
  if (Av) return Lo;
  Av = 1, Object.defineProperty(Lo, "__esModule", { value: !0 });
  const e = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return Lo.default = e, Lo;
}
var kn = {}, Rv;
function KR() {
  if (Rv) return kn;
  Rv = 1, Object.defineProperty(kn, "__esModule", { value: !0 }), kn.callRef = kn.getValidate = void 0;
  const e = pl(), t = en(), r = nt(), n = Wn(), i = D0(), a = lt(), s = {
    keyword: "$ref",
    schemaType: "string",
    code(u) {
      const { gen: l, schema: d, it: f } = u, { baseId: p, schemaEnv: v, validateName: m, opts: h, self: _ } = f, { root: g } = v;
      if ((d === "#" || d === "#/") && p === g.baseId)
        return x();
      const y = i.resolveRef.call(_, g, p, d);
      if (y === void 0)
        throw new e.default(f.opts.uriResolver, p, d);
      if (y instanceof i.SchemaEnv)
        return S(y);
      return w(y);
      function x() {
        if (v === g)
          return c(u, m, v, v.$async);
        const E = l.scopeValue("root", { ref: g });
        return c(u, (0, r._)`${E}.validate`, g, g.$async);
      }
      function S(E) {
        const R = o(u, E);
        c(u, R, E, E.$async);
      }
      function w(E) {
        const R = l.scopeValue("schema", h.code.source === !0 ? { ref: E, code: (0, r.stringify)(E) } : { ref: E }), N = l.name("valid"), B = u.subschema({
          schema: E,
          dataTypes: [],
          schemaPath: r.nil,
          topSchemaRef: R,
          errSchemaPath: d
        }, N);
        u.mergeEvaluated(B), u.ok(N);
      }
    }
  };
  function o(u, l) {
    const { gen: d } = u;
    return l.validate ? d.scopeValue("validate", { ref: l.validate }) : (0, r._)`${d.scopeValue("wrapper", { ref: l })}.validate`;
  }
  kn.getValidate = o;
  function c(u, l, d, f) {
    const { gen: p, it: v } = u, { allErrors: m, schemaEnv: h, opts: _ } = v, g = _.passContext ? n.default.this : r.nil;
    f ? y() : x();
    function y() {
      if (!h.$async)
        throw new Error("async schema referenced by sync schema");
      const E = p.let("valid");
      p.try(() => {
        p.code((0, r._)`await ${(0, t.callValidateCode)(u, l, g)}`), w(l), m || p.assign(E, !0);
      }, (R) => {
        p.if((0, r._)`!(${R} instanceof ${v.ValidationError})`, () => p.throw(R)), S(R), m || p.assign(E, !1);
      }), u.ok(E);
    }
    function x() {
      u.result((0, t.callValidateCode)(u, l, g), () => w(l), () => S(l));
    }
    function S(E) {
      const R = (0, r._)`${E}.errors`;
      p.assign(n.default.vErrors, (0, r._)`${n.default.vErrors} === null ? ${R} : ${n.default.vErrors}.concat(${R})`), p.assign(n.default.errors, (0, r._)`${n.default.vErrors}.length`);
    }
    function w(E) {
      var R;
      if (!v.opts.unevaluated)
        return;
      const N = (R = d?.validate) === null || R === void 0 ? void 0 : R.evaluated;
      if (v.props !== !0)
        if (N && !N.dynamicProps)
          N.props !== void 0 && (v.props = a.mergeEvaluated.props(p, N.props, v.props));
        else {
          const B = p.var("props", (0, r._)`${E}.evaluated.props`);
          v.props = a.mergeEvaluated.props(p, B, v.props, r.Name);
        }
      if (v.items !== !0)
        if (N && !N.dynamicItems)
          N.items !== void 0 && (v.items = a.mergeEvaluated.items(p, N.items, v.items));
        else {
          const B = p.var("items", (0, r._)`${E}.evaluated.items`);
          v.items = a.mergeEvaluated.items(p, B, v.items, r.Name);
        }
    }
  }
  return kn.callRef = c, kn.default = s, kn;
}
var $v;
function YR() {
  if ($v) return ko;
  $v = 1, Object.defineProperty(ko, "__esModule", { value: !0 });
  const e = XR(), t = KR(), r = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    e.default,
    t.default
  ];
  return ko.default = r, ko;
}
var Mo = {}, Uo = {}, Ov;
function JR() {
  if (Ov) return Uo;
  Ov = 1, Object.defineProperty(Uo, "__esModule", { value: !0 });
  const e = nt(), t = e.operators, r = {
    maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
    minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
    exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
    exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
  }, n = {
    message: ({ keyword: a, schemaCode: s }) => (0, e.str)`must be ${r[a].okStr} ${s}`,
    params: ({ keyword: a, schemaCode: s }) => (0, e._)`{comparison: ${r[a].okStr}, limit: ${s}}`
  }, i = {
    keyword: Object.keys(r),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: n,
    code(a) {
      const { keyword: s, data: o, schemaCode: c } = a;
      a.fail$data((0, e._)`${o} ${r[s].fail} ${c} || isNaN(${o})`);
    }
  };
  return Uo.default = i, Uo;
}
var qo = {}, Nv;
function QR() {
  if (Nv) return qo;
  Nv = 1, Object.defineProperty(qo, "__esModule", { value: !0 });
  const e = nt(), r = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, e._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: i, data: a, schemaCode: s, it: o } = n, c = o.opts.multipleOfPrecision, u = i.let("res"), l = c ? (0, e._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${c}` : (0, e._)`${u} !== parseInt(${u})`;
      n.fail$data((0, e._)`(${s} === 0 || (${u} = ${a}/${s}, ${l}))`);
    }
  };
  return qo.default = r, qo;
}
var Bo = {}, jo = {}, Pv;
function ZR() {
  if (Pv) return jo;
  Pv = 1, Object.defineProperty(jo, "__esModule", { value: !0 });
  function e(t) {
    const r = t.length;
    let n = 0, i = 0, a;
    for (; i < r; )
      n++, a = t.charCodeAt(i++), a >= 55296 && a <= 56319 && i < r && (a = t.charCodeAt(i), (a & 64512) === 56320 && i++);
    return n;
  }
  return jo.default = e, e.code = 'require("ajv/dist/runtime/ucs2length").default', jo;
}
var Cv;
function e$() {
  if (Cv) return Bo;
  Cv = 1, Object.defineProperty(Bo, "__esModule", { value: !0 });
  const e = nt(), t = lt(), r = ZR(), i = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: a, schemaCode: s }) {
        const o = a === "maxLength" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${o} than ${s} characters`;
      },
      params: ({ schemaCode: a }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { keyword: s, data: o, schemaCode: c, it: u } = a, l = s === "maxLength" ? e.operators.GT : e.operators.LT, d = u.opts.unicode === !1 ? (0, e._)`${o}.length` : (0, e._)`${(0, t.useFunc)(a.gen, r.default)}(${o})`;
      a.fail$data((0, e._)`${d} ${l} ${c}`);
    }
  };
  return Bo.default = i, Bo;
}
var Vo = {}, Iv;
function t$() {
  if (Iv) return Vo;
  Iv = 1, Object.defineProperty(Vo, "__esModule", { value: !0 });
  const e = en(), t = nt(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: i }) => (0, t.str)`must match pattern "${i}"`,
      params: ({ schemaCode: i }) => (0, t._)`{pattern: ${i}}`
    },
    code(i) {
      const { data: a, $data: s, schema: o, schemaCode: c, it: u } = i, l = u.opts.unicodeRegExp ? "u" : "", d = s ? (0, t._)`(new RegExp(${c}, ${l}))` : (0, e.usePattern)(i, o);
      i.fail$data((0, t._)`!${d}.test(${a})`);
    }
  };
  return Vo.default = n, Vo;
}
var Ho = {}, bv;
function r$() {
  if (bv) return Ho;
  bv = 1, Object.defineProperty(Ho, "__esModule", { value: !0 });
  const e = nt(), r = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: i }) {
        const a = n === "maxProperties" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${i} properties`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: i, data: a, schemaCode: s } = n, o = i === "maxProperties" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`Object.keys(${a}).length ${o} ${s}`);
    }
  };
  return Ho.default = r, Ho;
}
var Go = {}, Fv;
function n$() {
  if (Fv) return Go;
  Fv = 1, Object.defineProperty(Go, "__esModule", { value: !0 });
  const e = en(), t = nt(), r = lt(), i = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: a } }) => (0, t.str)`must have required property '${a}'`,
      params: ({ params: { missingProperty: a } }) => (0, t._)`{missingProperty: ${a}}`
    },
    code(a) {
      const { gen: s, schema: o, schemaCode: c, data: u, $data: l, it: d } = a, { opts: f } = d;
      if (!l && o.length === 0)
        return;
      const p = o.length >= f.loopRequired;
      if (d.allErrors ? v() : m(), f.strictRequired) {
        const g = a.parentSchema.properties, { definedProperties: y } = a.it;
        for (const x of o)
          if (g?.[x] === void 0 && !y.has(x)) {
            const S = d.schemaEnv.baseId + d.errSchemaPath, w = `required property "${x}" is not defined at "${S}" (strictRequired)`;
            (0, r.checkStrictMode)(d, w, d.opts.strictRequired);
          }
      }
      function v() {
        if (p || l)
          a.block$data(t.nil, h);
        else
          for (const g of o)
            (0, e.checkReportMissingProp)(a, g);
      }
      function m() {
        const g = s.let("missing");
        if (p || l) {
          const y = s.let("valid", !0);
          a.block$data(y, () => _(g, y)), a.ok(y);
        } else
          s.if((0, e.checkMissingProp)(a, o, g)), (0, e.reportMissingProp)(a, g), s.else();
      }
      function h() {
        s.forOf("prop", c, (g) => {
          a.setParams({ missingProperty: g }), s.if((0, e.noPropertyInData)(s, u, g, f.ownProperties), () => a.error());
        });
      }
      function _(g, y) {
        a.setParams({ missingProperty: g }), s.forOf(g, c, () => {
          s.assign(y, (0, e.propertyInData)(s, u, g, f.ownProperties)), s.if((0, t.not)(y), () => {
            a.error(), s.break();
          });
        }, t.nil);
      }
    }
  };
  return Go.default = i, Go;
}
var zo = {}, Dv;
function i$() {
  if (Dv) return zo;
  Dv = 1, Object.defineProperty(zo, "__esModule", { value: !0 });
  const e = nt(), r = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: i }) {
        const a = n === "maxItems" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${i} items`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: i, data: a, schemaCode: s } = n, o = i === "maxItems" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`${a}.length ${o} ${s}`);
    }
  };
  return zo.default = r, zo;
}
var Wo = {}, Xo = {}, kv;
function k0() {
  if (kv) return Xo;
  kv = 1, Object.defineProperty(Xo, "__esModule", { value: !0 });
  const e = sl();
  return e.code = 'require("ajv/dist/runtime/equal").default', Xo.default = e, Xo;
}
var Lv;
function a$() {
  if (Lv) return Wo;
  Lv = 1, Object.defineProperty(Wo, "__esModule", { value: !0 });
  const e = Ic(), t = nt(), r = lt(), n = k0(), a = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: s, j: o } }) => (0, t.str)`must NOT have duplicate items (items ## ${o} and ${s} are identical)`,
      params: ({ params: { i: s, j: o } }) => (0, t._)`{i: ${s}, j: ${o}}`
    },
    code(s) {
      const { gen: o, data: c, $data: u, schema: l, parentSchema: d, schemaCode: f, it: p } = s;
      if (!u && !l)
        return;
      const v = o.let("valid"), m = d.items ? (0, e.getSchemaTypes)(d.items) : [];
      s.block$data(v, h, (0, t._)`${f} === false`), s.ok(v);
      function h() {
        const x = o.let("i", (0, t._)`${c}.length`), S = o.let("j");
        s.setParams({ i: x, j: S }), o.assign(v, !0), o.if((0, t._)`${x} > 1`, () => (_() ? g : y)(x, S));
      }
      function _() {
        return m.length > 0 && !m.some((x) => x === "object" || x === "array");
      }
      function g(x, S) {
        const w = o.name("item"), E = (0, e.checkDataTypes)(m, w, p.opts.strictNumbers, e.DataType.Wrong), R = o.const("indices", (0, t._)`{}`);
        o.for((0, t._)`;${x}--;`, () => {
          o.let(w, (0, t._)`${c}[${x}]`), o.if(E, (0, t._)`continue`), m.length > 1 && o.if((0, t._)`typeof ${w} == "string"`, (0, t._)`${w} += "_"`), o.if((0, t._)`typeof ${R}[${w}] == "number"`, () => {
            o.assign(S, (0, t._)`${R}[${w}]`), s.error(), o.assign(v, !1).break();
          }).code((0, t._)`${R}[${w}] = ${x}`);
        });
      }
      function y(x, S) {
        const w = (0, r.useFunc)(o, n.default), E = o.name("outer");
        o.label(E).for((0, t._)`;${x}--;`, () => o.for((0, t._)`${S} = ${x}; ${S}--;`, () => o.if((0, t._)`${w}(${c}[${x}], ${c}[${S}])`, () => {
          s.error(), o.assign(v, !1).break(E);
        })));
      }
    }
  };
  return Wo.default = a, Wo;
}
var Ko = {}, Mv;
function s$() {
  if (Mv) return Ko;
  Mv = 1, Object.defineProperty(Ko, "__esModule", { value: !0 });
  const e = nt(), t = lt(), r = k0(), i = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValue: ${a}}`
    },
    code(a) {
      const { gen: s, data: o, $data: c, schemaCode: u, schema: l } = a;
      c || l && typeof l == "object" ? a.fail$data((0, e._)`!${(0, t.useFunc)(s, r.default)}(${o}, ${u})`) : a.fail((0, e._)`${l} !== ${o}`);
    }
  };
  return Ko.default = i, Ko;
}
var Yo = {}, Uv;
function o$() {
  if (Uv) return Yo;
  Uv = 1, Object.defineProperty(Yo, "__esModule", { value: !0 });
  const e = nt(), t = lt(), r = k0(), i = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValues: ${a}}`
    },
    code(a) {
      const { gen: s, data: o, $data: c, schema: u, schemaCode: l, it: d } = a;
      if (!c && u.length === 0)
        throw new Error("enum must have non-empty array");
      const f = u.length >= d.opts.loopEnum;
      let p;
      const v = () => p ?? (p = (0, t.useFunc)(s, r.default));
      let m;
      if (f || c)
        m = s.let("valid"), a.block$data(m, h);
      else {
        if (!Array.isArray(u))
          throw new Error("ajv implementation error");
        const g = s.const("vSchema", l);
        m = (0, e.or)(...u.map((y, x) => _(g, x)));
      }
      a.pass(m);
      function h() {
        s.assign(m, !1), s.forOf("v", l, (g) => s.if((0, e._)`${v()}(${o}, ${g})`, () => s.assign(m, !0).break()));
      }
      function _(g, y) {
        const x = u[y];
        return typeof x == "object" && x !== null ? (0, e._)`${v()}(${o}, ${g}[${y}])` : (0, e._)`${o} === ${x}`;
      }
    }
  };
  return Yo.default = i, Yo;
}
var qv;
function c$() {
  if (qv) return Mo;
  qv = 1, Object.defineProperty(Mo, "__esModule", { value: !0 });
  const e = JR(), t = QR(), r = e$(), n = t$(), i = r$(), a = n$(), s = i$(), o = a$(), c = s$(), u = o$(), l = [
    // number
    e.default,
    t.default,
    // string
    r.default,
    n.default,
    // object
    i.default,
    a.default,
    // array
    s.default,
    o.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    c.default,
    u.default
  ];
  return Mo.default = l, Mo;
}
var Jo = {}, Di = {}, Bv;
function YE() {
  if (Bv) return Di;
  Bv = 1, Object.defineProperty(Di, "__esModule", { value: !0 }), Di.validateAdditionalItems = void 0;
  const e = nt(), t = lt(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: a } }) => (0, e.str)`must NOT have more than ${a} items`,
      params: ({ params: { len: a } }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { parentSchema: s, it: o } = a, { items: c } = s;
      if (!Array.isArray(c)) {
        (0, t.checkStrictMode)(o, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      i(a, c);
    }
  };
  function i(a, s) {
    const { gen: o, schema: c, data: u, keyword: l, it: d } = a;
    d.items = !0;
    const f = o.const("len", (0, e._)`${u}.length`);
    if (c === !1)
      a.setParams({ len: s.length }), a.pass((0, e._)`${f} <= ${s.length}`);
    else if (typeof c == "object" && !(0, t.alwaysValidSchema)(d, c)) {
      const v = o.var("valid", (0, e._)`${f} <= ${s.length}`);
      o.if((0, e.not)(v), () => p(v)), a.ok(v);
    }
    function p(v) {
      o.forRange("i", s.length, f, (m) => {
        a.subschema({ keyword: l, dataProp: m, dataPropType: t.Type.Num }, v), d.allErrors || o.if((0, e.not)(v), () => o.break());
      });
    }
  }
  return Di.validateAdditionalItems = i, Di.default = n, Di;
}
var Qo = {}, ki = {}, jv;
function JE() {
  if (jv) return ki;
  jv = 1, Object.defineProperty(ki, "__esModule", { value: !0 }), ki.validateTuple = void 0;
  const e = nt(), t = lt(), r = en(), n = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(a) {
      const { schema: s, it: o } = a;
      if (Array.isArray(s))
        return i(a, "additionalItems", s);
      o.items = !0, !(0, t.alwaysValidSchema)(o, s) && a.ok((0, r.validateArray)(a));
    }
  };
  function i(a, s, o = a.schema) {
    const { gen: c, parentSchema: u, data: l, keyword: d, it: f } = a;
    m(u), f.opts.unevaluated && o.length && f.items !== !0 && (f.items = t.mergeEvaluated.items(c, o.length, f.items));
    const p = c.name("valid"), v = c.const("len", (0, e._)`${l}.length`);
    o.forEach((h, _) => {
      (0, t.alwaysValidSchema)(f, h) || (c.if((0, e._)`${v} > ${_}`, () => a.subschema({
        keyword: d,
        schemaProp: _,
        dataProp: _
      }, p)), a.ok(p));
    });
    function m(h) {
      const { opts: _, errSchemaPath: g } = f, y = o.length, x = y === h.minItems && (y === h.maxItems || h[s] === !1);
      if (_.strictTuples && !x) {
        const S = `"${d}" is ${y}-tuple, but minItems or maxItems/${s} are not specified or different at path "${g}"`;
        (0, t.checkStrictMode)(f, S, _.strictTuples);
      }
    }
  }
  return ki.validateTuple = i, ki.default = n, ki;
}
var Vv;
function l$() {
  if (Vv) return Qo;
  Vv = 1, Object.defineProperty(Qo, "__esModule", { value: !0 });
  const e = JE(), t = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (r) => (0, e.validateTuple)(r, "items")
  };
  return Qo.default = t, Qo;
}
var Zo = {}, Hv;
function u$() {
  if (Hv) return Zo;
  Hv = 1, Object.defineProperty(Zo, "__esModule", { value: !0 });
  const e = nt(), t = lt(), r = en(), n = YE(), a = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: s } }) => (0, e.str)`must NOT have more than ${s} items`,
      params: ({ params: { len: s } }) => (0, e._)`{limit: ${s}}`
    },
    code(s) {
      const { schema: o, parentSchema: c, it: u } = s, { prefixItems: l } = c;
      u.items = !0, !(0, t.alwaysValidSchema)(u, o) && (l ? (0, n.validateAdditionalItems)(s, l) : s.ok((0, r.validateArray)(s)));
    }
  };
  return Zo.default = a, Zo;
}
var ec = {}, Gv;
function f$() {
  if (Gv) return ec;
  Gv = 1, Object.defineProperty(ec, "__esModule", { value: !0 });
  const e = nt(), t = lt(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: i, max: a } }) => a === void 0 ? (0, e.str)`must contain at least ${i} valid item(s)` : (0, e.str)`must contain at least ${i} and no more than ${a} valid item(s)`,
      params: ({ params: { min: i, max: a } }) => a === void 0 ? (0, e._)`{minContains: ${i}}` : (0, e._)`{minContains: ${i}, maxContains: ${a}}`
    },
    code(i) {
      const { gen: a, schema: s, parentSchema: o, data: c, it: u } = i;
      let l, d;
      const { minContains: f, maxContains: p } = o;
      u.opts.next ? (l = f === void 0 ? 1 : f, d = p) : l = 1;
      const v = a.const("len", (0, e._)`${c}.length`);
      if (i.setParams({ min: l, max: d }), d === void 0 && l === 0) {
        (0, t.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (d !== void 0 && l > d) {
        (0, t.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), i.fail();
        return;
      }
      if ((0, t.alwaysValidSchema)(u, s)) {
        let y = (0, e._)`${v} >= ${l}`;
        d !== void 0 && (y = (0, e._)`${y} && ${v} <= ${d}`), i.pass(y);
        return;
      }
      u.items = !0;
      const m = a.name("valid");
      d === void 0 && l === 1 ? _(m, () => a.if(m, () => a.break())) : l === 0 ? (a.let(m, !0), d !== void 0 && a.if((0, e._)`${c}.length > 0`, h)) : (a.let(m, !1), h()), i.result(m, () => i.reset());
      function h() {
        const y = a.name("_valid"), x = a.let("count", 0);
        _(y, () => a.if(y, () => g(x)));
      }
      function _(y, x) {
        a.forRange("i", 0, v, (S) => {
          i.subschema({
            keyword: "contains",
            dataProp: S,
            dataPropType: t.Type.Num,
            compositeRule: !0
          }, y), x();
        });
      }
      function g(y) {
        a.code((0, e._)`${y}++`), d === void 0 ? a.if((0, e._)`${y} >= ${l}`, () => a.assign(m, !0).break()) : (a.if((0, e._)`${y} > ${d}`, () => a.assign(m, !1).break()), l === 1 ? a.assign(m, !0) : a.if((0, e._)`${y} >= ${l}`, () => a.assign(m, !0)));
      }
    }
  };
  return ec.default = n, ec;
}
var Zf = {}, zv;
function d$() {
  return zv || (zv = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
    const t = nt(), r = lt(), n = en();
    e.error = {
      message: ({ params: { property: c, depsCount: u, deps: l } }) => {
        const d = u === 1 ? "property" : "properties";
        return (0, t.str)`must have ${d} ${l} when property ${c} is present`;
      },
      params: ({ params: { property: c, depsCount: u, deps: l, missingProperty: d } }) => (0, t._)`{property: ${c},
    missingProperty: ${d},
    depsCount: ${u},
    deps: ${l}}`
      // TODO change to reference
    };
    const i = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: e.error,
      code(c) {
        const [u, l] = a(c);
        s(c, u), o(c, l);
      }
    };
    function a({ schema: c }) {
      const u = {}, l = {};
      for (const d in c) {
        if (d === "__proto__")
          continue;
        const f = Array.isArray(c[d]) ? u : l;
        f[d] = c[d];
      }
      return [u, l];
    }
    function s(c, u = c.schema) {
      const { gen: l, data: d, it: f } = c;
      if (Object.keys(u).length === 0)
        return;
      const p = l.let("missing");
      for (const v in u) {
        const m = u[v];
        if (m.length === 0)
          continue;
        const h = (0, n.propertyInData)(l, d, v, f.opts.ownProperties);
        c.setParams({
          property: v,
          depsCount: m.length,
          deps: m.join(", ")
        }), f.allErrors ? l.if(h, () => {
          for (const _ of m)
            (0, n.checkReportMissingProp)(c, _);
        }) : (l.if((0, t._)`${h} && (${(0, n.checkMissingProp)(c, m, p)})`), (0, n.reportMissingProp)(c, p), l.else());
      }
    }
    e.validatePropertyDeps = s;
    function o(c, u = c.schema) {
      const { gen: l, data: d, keyword: f, it: p } = c, v = l.name("valid");
      for (const m in u)
        (0, r.alwaysValidSchema)(p, u[m]) || (l.if(
          (0, n.propertyInData)(l, d, m, p.opts.ownProperties),
          () => {
            const h = c.subschema({ keyword: f, schemaProp: m }, v);
            c.mergeValidEvaluated(h, v);
          },
          () => l.var(v, !0)
          // TODO var
        ), c.ok(v));
    }
    e.validateSchemaDeps = o, e.default = i;
  })(Zf)), Zf;
}
var tc = {}, Wv;
function h$() {
  if (Wv) return tc;
  Wv = 1, Object.defineProperty(tc, "__esModule", { value: !0 });
  const e = nt(), t = lt(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: i }) => (0, e._)`{propertyName: ${i.propertyName}}`
    },
    code(i) {
      const { gen: a, schema: s, data: o, it: c } = i;
      if ((0, t.alwaysValidSchema)(c, s))
        return;
      const u = a.name("valid");
      a.forIn("key", o, (l) => {
        i.setParams({ propertyName: l }), i.subschema({
          keyword: "propertyNames",
          data: l,
          dataTypes: ["string"],
          propertyName: l,
          compositeRule: !0
        }, u), a.if((0, e.not)(u), () => {
          i.error(!0), c.allErrors || a.break();
        });
      }), i.ok(u);
    }
  };
  return tc.default = n, tc;
}
var rc = {}, Xv;
function QE() {
  if (Xv) return rc;
  Xv = 1, Object.defineProperty(rc, "__esModule", { value: !0 });
  const e = en(), t = nt(), r = Wn(), n = lt(), a = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: s }) => (0, t._)`{additionalProperty: ${s.additionalProperty}}`
    },
    code(s) {
      const { gen: o, schema: c, parentSchema: u, data: l, errsCount: d, it: f } = s;
      if (!d)
        throw new Error("ajv implementation error");
      const { allErrors: p, opts: v } = f;
      if (f.props = !0, v.removeAdditional !== "all" && (0, n.alwaysValidSchema)(f, c))
        return;
      const m = (0, e.allSchemaProperties)(u.properties), h = (0, e.allSchemaProperties)(u.patternProperties);
      _(), s.ok((0, t._)`${d} === ${r.default.errors}`);
      function _() {
        o.forIn("key", l, (w) => {
          !m.length && !h.length ? x(w) : o.if(g(w), () => x(w));
        });
      }
      function g(w) {
        let E;
        if (m.length > 8) {
          const R = (0, n.schemaRefOrVal)(f, u.properties, "properties");
          E = (0, e.isOwnProperty)(o, R, w);
        } else m.length ? E = (0, t.or)(...m.map((R) => (0, t._)`${w} === ${R}`)) : E = t.nil;
        return h.length && (E = (0, t.or)(E, ...h.map((R) => (0, t._)`${(0, e.usePattern)(s, R)}.test(${w})`))), (0, t.not)(E);
      }
      function y(w) {
        o.code((0, t._)`delete ${l}[${w}]`);
      }
      function x(w) {
        if (v.removeAdditional === "all" || v.removeAdditional && c === !1) {
          y(w);
          return;
        }
        if (c === !1) {
          s.setParams({ additionalProperty: w }), s.error(), p || o.break();
          return;
        }
        if (typeof c == "object" && !(0, n.alwaysValidSchema)(f, c)) {
          const E = o.name("valid");
          v.removeAdditional === "failing" ? (S(w, E, !1), o.if((0, t.not)(E), () => {
            s.reset(), y(w);
          })) : (S(w, E), p || o.if((0, t.not)(E), () => o.break()));
        }
      }
      function S(w, E, R) {
        const N = {
          keyword: "additionalProperties",
          dataProp: w,
          dataPropType: n.Type.Str
        };
        R === !1 && Object.assign(N, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), s.subschema(N, E);
      }
    }
  };
  return rc.default = a, rc;
}
var nc = {}, Kv;
function p$() {
  if (Kv) return nc;
  Kv = 1, Object.defineProperty(nc, "__esModule", { value: !0 });
  const e = hl(), t = en(), r = lt(), n = QE(), i = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(a) {
      const { gen: s, schema: o, parentSchema: c, data: u, it: l } = a;
      l.opts.removeAdditional === "all" && c.additionalProperties === void 0 && n.default.code(new e.KeywordCxt(l, n.default, "additionalProperties"));
      const d = (0, t.allSchemaProperties)(o);
      for (const h of d)
        l.definedProperties.add(h);
      l.opts.unevaluated && d.length && l.props !== !0 && (l.props = r.mergeEvaluated.props(s, (0, r.toHash)(d), l.props));
      const f = d.filter((h) => !(0, r.alwaysValidSchema)(l, o[h]));
      if (f.length === 0)
        return;
      const p = s.name("valid");
      for (const h of f)
        v(h) ? m(h) : (s.if((0, t.propertyInData)(s, u, h, l.opts.ownProperties)), m(h), l.allErrors || s.else().var(p, !0), s.endIf()), a.it.definedProperties.add(h), a.ok(p);
      function v(h) {
        return l.opts.useDefaults && !l.compositeRule && o[h].default !== void 0;
      }
      function m(h) {
        a.subschema({
          keyword: "properties",
          schemaProp: h,
          dataProp: h
        }, p);
      }
    }
  };
  return nc.default = i, nc;
}
var ic = {}, Yv;
function m$() {
  if (Yv) return ic;
  Yv = 1, Object.defineProperty(ic, "__esModule", { value: !0 });
  const e = en(), t = nt(), r = lt(), n = lt(), i = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(a) {
      const { gen: s, schema: o, data: c, parentSchema: u, it: l } = a, { opts: d } = l, f = (0, e.allSchemaProperties)(o), p = f.filter((x) => (0, r.alwaysValidSchema)(l, o[x]));
      if (f.length === 0 || p.length === f.length && (!l.opts.unevaluated || l.props === !0))
        return;
      const v = d.strictSchema && !d.allowMatchingProperties && u.properties, m = s.name("valid");
      l.props !== !0 && !(l.props instanceof t.Name) && (l.props = (0, n.evaluatedPropsToName)(s, l.props));
      const { props: h } = l;
      _();
      function _() {
        for (const x of f)
          v && g(x), l.allErrors ? y(x) : (s.var(m, !0), y(x), s.if(m));
      }
      function g(x) {
        for (const S in v)
          new RegExp(x).test(S) && (0, r.checkStrictMode)(l, `property ${S} matches pattern ${x} (use allowMatchingProperties)`);
      }
      function y(x) {
        s.forIn("key", c, (S) => {
          s.if((0, t._)`${(0, e.usePattern)(a, x)}.test(${S})`, () => {
            const w = p.includes(x);
            w || a.subschema({
              keyword: "patternProperties",
              schemaProp: x,
              dataProp: S,
              dataPropType: n.Type.Str
            }, m), l.opts.unevaluated && h !== !0 ? s.assign((0, t._)`${h}[${S}]`, !0) : !w && !l.allErrors && s.if((0, t.not)(m), () => s.break());
          });
        });
      }
    }
  };
  return ic.default = i, ic;
}
var ac = {}, Jv;
function g$() {
  if (Jv) return ac;
  Jv = 1, Object.defineProperty(ac, "__esModule", { value: !0 });
  const e = lt(), t = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(r) {
      const { gen: n, schema: i, it: a } = r;
      if ((0, e.alwaysValidSchema)(a, i)) {
        r.fail();
        return;
      }
      const s = n.name("valid");
      r.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, s), r.failResult(s, () => r.reset(), () => r.error());
    },
    error: { message: "must NOT be valid" }
  };
  return ac.default = t, ac;
}
var sc = {}, Qv;
function v$() {
  if (Qv) return sc;
  Qv = 1, Object.defineProperty(sc, "__esModule", { value: !0 });
  const t = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: en().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return sc.default = t, sc;
}
var oc = {}, Zv;
function _$() {
  if (Zv) return oc;
  Zv = 1, Object.defineProperty(oc, "__esModule", { value: !0 });
  const e = nt(), t = lt(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: i }) => (0, e._)`{passingSchemas: ${i.passing}}`
    },
    code(i) {
      const { gen: a, schema: s, parentSchema: o, it: c } = i;
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      if (c.opts.discriminator && o.discriminator)
        return;
      const u = s, l = a.let("valid", !1), d = a.let("passing", null), f = a.name("_valid");
      i.setParams({ passing: d }), a.block(p), i.result(l, () => i.reset(), () => i.error(!0));
      function p() {
        u.forEach((v, m) => {
          let h;
          (0, t.alwaysValidSchema)(c, v) ? a.var(f, !0) : h = i.subschema({
            keyword: "oneOf",
            schemaProp: m,
            compositeRule: !0
          }, f), m > 0 && a.if((0, e._)`${f} && ${l}`).assign(l, !1).assign(d, (0, e._)`[${d}, ${m}]`).else(), a.if(f, () => {
            a.assign(l, !0), a.assign(d, m), h && i.mergeEvaluated(h, e.Name);
          });
        });
      }
    }
  };
  return oc.default = n, oc;
}
var cc = {}, e_;
function y$() {
  if (e_) return cc;
  e_ = 1, Object.defineProperty(cc, "__esModule", { value: !0 });
  const e = lt(), t = {
    keyword: "allOf",
    schemaType: "array",
    code(r) {
      const { gen: n, schema: i, it: a } = r;
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const s = n.name("valid");
      i.forEach((o, c) => {
        if ((0, e.alwaysValidSchema)(a, o))
          return;
        const u = r.subschema({ keyword: "allOf", schemaProp: c }, s);
        r.ok(s), r.mergeEvaluated(u);
      });
    }
  };
  return cc.default = t, cc;
}
var lc = {}, t_;
function E$() {
  if (t_) return lc;
  t_ = 1, Object.defineProperty(lc, "__esModule", { value: !0 });
  const e = nt(), t = lt(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: a }) => (0, e.str)`must match "${a.ifClause}" schema`,
      params: ({ params: a }) => (0, e._)`{failingKeyword: ${a.ifClause}}`
    },
    code(a) {
      const { gen: s, parentSchema: o, it: c } = a;
      o.then === void 0 && o.else === void 0 && (0, t.checkStrictMode)(c, '"if" without "then" and "else" is ignored');
      const u = i(c, "then"), l = i(c, "else");
      if (!u && !l)
        return;
      const d = s.let("valid", !0), f = s.name("_valid");
      if (p(), a.reset(), u && l) {
        const m = s.let("ifClause");
        a.setParams({ ifClause: m }), s.if(f, v("then", m), v("else", m));
      } else u ? s.if(f, v("then")) : s.if((0, e.not)(f), v("else"));
      a.pass(d, () => a.error(!0));
      function p() {
        const m = a.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, f);
        a.mergeEvaluated(m);
      }
      function v(m, h) {
        return () => {
          const _ = a.subschema({ keyword: m }, f);
          s.assign(d, f), a.mergeValidEvaluated(_, d), h ? s.assign(h, (0, e._)`${m}`) : a.setParams({ ifClause: m });
        };
      }
    }
  };
  function i(a, s) {
    const o = a.schema[s];
    return o !== void 0 && !(0, t.alwaysValidSchema)(a, o);
  }
  return lc.default = n, lc;
}
var uc = {}, r_;
function w$() {
  if (r_) return uc;
  r_ = 1, Object.defineProperty(uc, "__esModule", { value: !0 });
  const e = lt(), t = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: r, parentSchema: n, it: i }) {
      n.if === void 0 && (0, e.checkStrictMode)(i, `"${r}" without "if" is ignored`);
    }
  };
  return uc.default = t, uc;
}
var n_;
function x$() {
  if (n_) return Jo;
  n_ = 1, Object.defineProperty(Jo, "__esModule", { value: !0 });
  const e = YE(), t = l$(), r = JE(), n = u$(), i = f$(), a = d$(), s = h$(), o = QE(), c = p$(), u = m$(), l = g$(), d = v$(), f = _$(), p = y$(), v = E$(), m = w$();
  function h(_ = !1) {
    const g = [
      // any
      l.default,
      d.default,
      f.default,
      p.default,
      v.default,
      m.default,
      // object
      s.default,
      o.default,
      a.default,
      c.default,
      u.default
    ];
    return _ ? g.push(t.default, n.default) : g.push(e.default, r.default), g.push(i.default), g;
  }
  return Jo.default = h, Jo;
}
var fc = {}, dc = {}, i_;
function T$() {
  if (i_) return dc;
  i_ = 1, Object.defineProperty(dc, "__esModule", { value: !0 });
  const e = nt(), r = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, e._)`{format: ${n}}`
    },
    code(n, i) {
      const { gen: a, data: s, $data: o, schema: c, schemaCode: u, it: l } = n, { opts: d, errSchemaPath: f, schemaEnv: p, self: v } = l;
      if (!d.validateFormats)
        return;
      o ? m() : h();
      function m() {
        const _ = a.scopeValue("formats", {
          ref: v.formats,
          code: d.code.formats
        }), g = a.const("fDef", (0, e._)`${_}[${u}]`), y = a.let("fType"), x = a.let("format");
        a.if((0, e._)`typeof ${g} == "object" && !(${g} instanceof RegExp)`, () => a.assign(y, (0, e._)`${g}.type || "string"`).assign(x, (0, e._)`${g}.validate`), () => a.assign(y, (0, e._)`"string"`).assign(x, g)), n.fail$data((0, e.or)(S(), w()));
        function S() {
          return d.strictSchema === !1 ? e.nil : (0, e._)`${u} && !${x}`;
        }
        function w() {
          const E = p.$async ? (0, e._)`(${g}.async ? await ${x}(${s}) : ${x}(${s}))` : (0, e._)`${x}(${s})`, R = (0, e._)`(typeof ${x} == "function" ? ${E} : ${x}.test(${s}))`;
          return (0, e._)`${x} && ${x} !== true && ${y} === ${i} && !${R}`;
        }
      }
      function h() {
        const _ = v.formats[c];
        if (!_) {
          S();
          return;
        }
        if (_ === !0)
          return;
        const [g, y, x] = w(_);
        g === i && n.pass(E());
        function S() {
          if (d.strictSchema === !1) {
            v.logger.warn(R());
            return;
          }
          throw new Error(R());
          function R() {
            return `unknown format "${c}" ignored in schema at path "${f}"`;
          }
        }
        function w(R) {
          const N = R instanceof RegExp ? (0, e.regexpCode)(R) : d.code.formats ? (0, e._)`${d.code.formats}${(0, e.getProperty)(c)}` : void 0, B = a.scopeValue("formats", { key: c, ref: R, code: N });
          return typeof R == "object" && !(R instanceof RegExp) ? [R.type || "string", R.validate, (0, e._)`${B}.validate`] : ["string", R, B];
        }
        function E() {
          if (typeof _ == "object" && !(_ instanceof RegExp) && _.async) {
            if (!p.$async)
              throw new Error("async format in sync schema");
            return (0, e._)`await ${x}(${s})`;
          }
          return typeof y == "function" ? (0, e._)`${x}(${s})` : (0, e._)`${x}.test(${s})`;
        }
      }
    }
  };
  return dc.default = r, dc;
}
var a_;
function S$() {
  if (a_) return fc;
  a_ = 1, Object.defineProperty(fc, "__esModule", { value: !0 });
  const t = [T$().default];
  return fc.default = t, fc;
}
var ui = {}, s_;
function A$() {
  return s_ || (s_ = 1, Object.defineProperty(ui, "__esModule", { value: !0 }), ui.contentVocabulary = ui.metadataVocabulary = void 0, ui.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], ui.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), ui;
}
var o_;
function R$() {
  if (o_) return Do;
  o_ = 1, Object.defineProperty(Do, "__esModule", { value: !0 });
  const e = YR(), t = c$(), r = x$(), n = S$(), i = A$(), a = [
    e.default,
    t.default,
    (0, r.default)(),
    n.default,
    i.metadataVocabulary,
    i.contentVocabulary
  ];
  return Do.default = a, Do;
}
var hc = {}, La = {}, c_;
function $$() {
  if (c_) return La;
  c_ = 1, Object.defineProperty(La, "__esModule", { value: !0 }), La.DiscrError = void 0;
  var e;
  return (function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  })(e || (La.DiscrError = e = {})), La;
}
var l_;
function O$() {
  if (l_) return hc;
  l_ = 1, Object.defineProperty(hc, "__esModule", { value: !0 });
  const e = nt(), t = $$(), r = D0(), n = pl(), i = lt(), s = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: o, tagName: c } }) => o === t.DiscrError.Tag ? `tag "${c}" must be string` : `value of tag "${c}" must be in oneOf`,
      params: ({ params: { discrError: o, tag: c, tagName: u } }) => (0, e._)`{error: ${o}, tag: ${u}, tagValue: ${c}}`
    },
    code(o) {
      const { gen: c, data: u, schema: l, parentSchema: d, it: f } = o, { oneOf: p } = d;
      if (!f.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const v = l.propertyName;
      if (typeof v != "string")
        throw new Error("discriminator: requires propertyName");
      if (l.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!p)
        throw new Error("discriminator: requires oneOf keyword");
      const m = c.let("valid", !1), h = c.const("tag", (0, e._)`${u}${(0, e.getProperty)(v)}`);
      c.if((0, e._)`typeof ${h} == "string"`, () => _(), () => o.error(!1, { discrError: t.DiscrError.Tag, tag: h, tagName: v })), o.ok(m);
      function _() {
        const x = y();
        c.if(!1);
        for (const S in x)
          c.elseIf((0, e._)`${h} === ${S}`), c.assign(m, g(x[S]));
        c.else(), o.error(!1, { discrError: t.DiscrError.Mapping, tag: h, tagName: v }), c.endIf();
      }
      function g(x) {
        const S = c.name("valid"), w = o.subschema({ keyword: "oneOf", schemaProp: x }, S);
        return o.mergeEvaluated(w, e.Name), S;
      }
      function y() {
        var x;
        const S = {}, w = R(d);
        let E = !0;
        for (let F = 0; F < p.length; F++) {
          let U = p[F];
          if (U?.$ref && !(0, i.schemaHasRulesButRef)(U, f.self.RULES)) {
            const M = U.$ref;
            if (U = r.resolveRef.call(f.self, f.schemaEnv.root, f.baseId, M), U instanceof r.SchemaEnv && (U = U.schema), U === void 0)
              throw new n.default(f.opts.uriResolver, f.baseId, M);
          }
          const G = (x = U?.properties) === null || x === void 0 ? void 0 : x[v];
          if (typeof G != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${v}"`);
          E = E && (w || R(U)), N(G, F);
        }
        if (!E)
          throw new Error(`discriminator: "${v}" must be required`);
        return S;
        function R({ required: F }) {
          return Array.isArray(F) && F.includes(v);
        }
        function N(F, U) {
          if (F.const)
            B(F.const, U);
          else if (F.enum)
            for (const G of F.enum)
              B(G, U);
          else
            throw new Error(`discriminator: "properties/${v}" must have "const" or "enum"`);
        }
        function B(F, U) {
          if (typeof F != "string" || F in S)
            throw new Error(`discriminator: "${v}" values must be unique strings`);
          S[F] = U;
        }
      }
    }
  };
  return hc.default = s, hc;
}
const N$ = "http://json-schema.org/draft-07/schema#", P$ = "http://json-schema.org/draft-07/schema#", C$ = "Core schema meta-schema", I$ = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, b$ = ["object", "boolean"], F$ = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, D$ = {
  $schema: N$,
  $id: P$,
  title: C$,
  definitions: I$,
  type: b$,
  properties: F$,
  default: !0
};
var u_;
function k$() {
  return u_ || (u_ = 1, (function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
    const r = WR(), n = R$(), i = O$(), a = D$, s = ["/properties"], o = "http://json-schema.org/draft-07/schema";
    class c extends r.default {
      _addVocabularies() {
        super._addVocabularies(), n.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator && this.addKeyword(i.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const v = this.opts.$data ? this.$dataMetaSchema(a, s) : a;
        this.addMetaSchema(v, o, !1), this.refs["http://json-schema.org/schema"] = o;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
      }
    }
    t.Ajv = c, e.exports = t = c, e.exports.Ajv = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
    var u = hl();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return u.KeywordCxt;
    } });
    var l = nt();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return l._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return l.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return l.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return l.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return l.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return l.CodeGen;
    } });
    var d = F0();
    Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
      return d.default;
    } });
    var f = pl();
    Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
      return f.default;
    } });
  })(Po, Po.exports)), Po.exports;
}
var f_;
function L$() {
  return f_ || (f_ = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
    const t = k$(), r = nt(), n = r.operators, i = {
      formatMaximum: { okStr: "<=", ok: n.LTE, fail: n.GT },
      formatMinimum: { okStr: ">=", ok: n.GTE, fail: n.LT },
      formatExclusiveMaximum: { okStr: "<", ok: n.LT, fail: n.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: n.GT, fail: n.LTE }
    }, a = {
      message: ({ keyword: o, schemaCode: c }) => (0, r.str)`should be ${i[o].okStr} ${c}`,
      params: ({ keyword: o, schemaCode: c }) => (0, r._)`{comparison: ${i[o].okStr}, limit: ${c}}`
    };
    e.formatLimitDefinition = {
      keyword: Object.keys(i),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: a,
      code(o) {
        const { gen: c, data: u, schemaCode: l, keyword: d, it: f } = o, { opts: p, self: v } = f;
        if (!p.validateFormats)
          return;
        const m = new t.KeywordCxt(f, v.RULES.all.format.definition, "format");
        m.$data ? h() : _();
        function h() {
          const y = c.scopeValue("formats", {
            ref: v.formats,
            code: p.code.formats
          }), x = c.const("fmt", (0, r._)`${y}[${m.schemaCode}]`);
          o.fail$data((0, r.or)((0, r._)`typeof ${x} != "object"`, (0, r._)`${x} instanceof RegExp`, (0, r._)`typeof ${x}.compare != "function"`, g(x)));
        }
        function _() {
          const y = m.schema, x = v.formats[y];
          if (!x || x === !0)
            return;
          if (typeof x != "object" || x instanceof RegExp || typeof x.compare != "function")
            throw new Error(`"${d}": format "${y}" does not define "compare" function`);
          const S = c.scopeValue("formats", {
            key: y,
            ref: x,
            code: p.code.formats ? (0, r._)`${p.code.formats}${(0, r.getProperty)(y)}` : void 0
          });
          o.fail$data(g(S));
        }
        function g(y) {
          return (0, r._)`${y}.compare(${u}, ${l}) ${i[d].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const s = (o) => (o.addKeyword(e.formatLimitDefinition), o);
    e.default = s;
  })(zf)), zf;
}
var d_;
function M$() {
  return d_ || (d_ = 1, (function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const r = bR(), n = L$(), i = nt(), a = new i.Name("fullFormats"), s = new i.Name("fastFormats"), o = (u, l = { keywords: !0 }) => {
      if (Array.isArray(l))
        return c(u, l, r.fullFormats, a), u;
      const [d, f] = l.mode === "fast" ? [r.fastFormats, s] : [r.fullFormats, a], p = l.formats || r.formatNames;
      return c(u, p, d, f), l.keywords && (0, n.default)(u), u;
    };
    o.get = (u, l = "full") => {
      const f = (l === "fast" ? r.fastFormats : r.fullFormats)[u];
      if (!f)
        throw new Error(`Unknown format "${u}"`);
      return f;
    };
    function c(u, l, d, f) {
      var p, v;
      (p = (v = u.opts.code).formats) !== null && p !== void 0 || (v.formats = (0, i._)`require("ajv-formats/dist/formats").${f}`);
      for (const m of l)
        u.addFormat(m, d[m]);
    }
    e.exports = t = o, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = o;
  })(No, No.exports)), No.exports;
}
var U$ = M$();
const q$ = /* @__PURE__ */ rE(U$), B$ = (e, t, r, n) => {
  if (r === "length" || r === "prototype" || r === "arguments" || r === "caller")
    return;
  const i = Object.getOwnPropertyDescriptor(e, r), a = Object.getOwnPropertyDescriptor(t, r);
  !j$(i, a) && n || Object.defineProperty(e, r, a);
}, j$ = function(e, t) {
  return e === void 0 || e.configurable || e.writable === t.writable && e.enumerable === t.enumerable && e.configurable === t.configurable && (e.writable || e.value === t.value);
}, V$ = (e, t) => {
  const r = Object.getPrototypeOf(t);
  r !== Object.getPrototypeOf(e) && Object.setPrototypeOf(e, r);
}, H$ = (e, t) => `/* Wrapped ${e}*/
${t}`, G$ = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), z$ = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), W$ = (e, t, r) => {
  const n = r === "" ? "" : `with ${r.trim()}() `, i = H$.bind(null, n, t.toString());
  Object.defineProperty(i, "name", z$);
  const { writable: a, enumerable: s, configurable: o } = G$;
  Object.defineProperty(e, "toString", { value: i, writable: a, enumerable: s, configurable: o });
};
function X$(e, t, { ignoreNonConfigurable: r = !1 } = {}) {
  const { name: n } = e;
  for (const i of Reflect.ownKeys(t))
    B$(e, t, i, r);
  return V$(e, t), W$(e, t, n), e;
}
const h_ = (e, t = {}) => {
  if (typeof e != "function")
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof e}\``);
  const {
    wait: r = 0,
    maxWait: n = Number.POSITIVE_INFINITY,
    before: i = !1,
    after: a = !0
  } = t;
  if (r < 0 || n < 0)
    throw new RangeError("`wait` and `maxWait` must not be negative.");
  if (!i && !a)
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  let s, o, c;
  const u = function(...l) {
    const d = this, f = () => {
      s = void 0, o && (clearTimeout(o), o = void 0), a && (c = e.apply(d, l));
    }, p = () => {
      o = void 0, s && (clearTimeout(s), s = void 0), a && (c = e.apply(d, l));
    }, v = i && !s;
    return clearTimeout(s), s = setTimeout(f, r), n > 0 && n !== Number.POSITIVE_INFINITY && !o && (o = setTimeout(p, n)), v && (c = e.apply(d, l)), c;
  };
  return X$(u, e), u.cancel = () => {
    s && (clearTimeout(s), s = void 0), o && (clearTimeout(o), o = void 0);
  }, u;
};
var pc = { exports: {} }, ed, p_;
function ml() {
  if (p_) return ed;
  p_ = 1;
  const e = "2.0.0", t = 256, r = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, n = 16, i = t - 6;
  return ed = {
    MAX_LENGTH: t,
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: i,
    MAX_SAFE_INTEGER: r,
    RELEASE_TYPES: [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ],
    SEMVER_SPEC_VERSION: e,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }, ed;
}
var td, m_;
function gl() {
  return m_ || (m_ = 1, td = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
  }), td;
}
var g_;
function as() {
  return g_ || (g_ = 1, (function(e, t) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: r,
      MAX_SAFE_BUILD_LENGTH: n,
      MAX_LENGTH: i
    } = ml(), a = gl();
    t = e.exports = {};
    const s = t.re = [], o = t.safeRe = [], c = t.src = [], u = t.safeSrc = [], l = t.t = {};
    let d = 0;
    const f = "[a-zA-Z0-9-]", p = [
      ["\\s", 1],
      ["\\d", i],
      [f, n]
    ], v = (h) => {
      for (const [_, g] of p)
        h = h.split(`${_}*`).join(`${_}{0,${g}}`).split(`${_}+`).join(`${_}{1,${g}}`);
      return h;
    }, m = (h, _, g) => {
      const y = v(_), x = d++;
      a(h, x, _), l[h] = x, c[x] = _, u[x] = y, s[x] = new RegExp(_, g ? "g" : void 0), o[x] = new RegExp(y, g ? "g" : void 0);
    };
    m("NUMERICIDENTIFIER", "0|[1-9]\\d*"), m("NUMERICIDENTIFIERLOOSE", "\\d+"), m("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`), m("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), m("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), m("PRERELEASEIDENTIFIER", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIER]})`), m("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIERLOOSE]})`), m("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), m("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), m("BUILDIDENTIFIER", `${f}+`), m("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), m("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), m("FULL", `^${c[l.FULLPLAIN]}$`), m("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), m("LOOSE", `^${c[l.LOOSEPLAIN]}$`), m("GTLT", "((?:<|>)?=?)"), m("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), m("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`), m("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), m("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), m("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), m("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), m("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), m("COERCE", `${c[l.COERCEPLAIN]}(?:$|[^\\d])`), m("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), m("COERCERTL", c[l.COERCE], !0), m("COERCERTLFULL", c[l.COERCEFULL], !0), m("LONETILDE", "(?:~>?)"), m("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", m("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), m("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), m("LONECARET", "(?:\\^)"), m("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", m("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), m("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), m("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), m("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), m("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", m("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), m("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), m("STAR", "(<|>)?=?\\s*\\*"), m("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), m("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(pc, pc.exports)), pc.exports;
}
var rd, v_;
function L0() {
  if (v_) return rd;
  v_ = 1;
  const e = Object.freeze({ loose: !0 }), t = Object.freeze({});
  return rd = (n) => n ? typeof n != "object" ? e : n : t, rd;
}
var nd, __;
function ZE() {
  if (__) return nd;
  __ = 1;
  const e = /^[0-9]+$/, t = (n, i) => {
    if (typeof n == "number" && typeof i == "number")
      return n === i ? 0 : n < i ? -1 : 1;
    const a = e.test(n), s = e.test(i);
    return a && s && (n = +n, i = +i), n === i ? 0 : a && !s ? -1 : s && !a ? 1 : n < i ? -1 : 1;
  };
  return nd = {
    compareIdentifiers: t,
    rcompareIdentifiers: (n, i) => t(i, n)
  }, nd;
}
var id, y_;
function mr() {
  if (y_) return id;
  y_ = 1;
  const e = gl(), { MAX_LENGTH: t, MAX_SAFE_INTEGER: r } = ml(), { safeRe: n, t: i } = as(), a = L0(), { compareIdentifiers: s } = ZE();
  class o {
    constructor(u, l) {
      if (l = a(l), u instanceof o) {
        if (u.loose === !!l.loose && u.includePrerelease === !!l.includePrerelease)
          return u;
        u = u.version;
      } else if (typeof u != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof u}".`);
      if (u.length > t)
        throw new TypeError(
          `version is longer than ${t} characters`
        );
      e("SemVer", u, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
      const d = u.trim().match(l.loose ? n[i.LOOSE] : n[i.FULL]);
      if (!d)
        throw new TypeError(`Invalid Version: ${u}`);
      if (this.raw = u, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > r || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > r || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > r || this.patch < 0)
        throw new TypeError("Invalid patch version");
      d[4] ? this.prerelease = d[4].split(".").map((f) => {
        if (/^[0-9]+$/.test(f)) {
          const p = +f;
          if (p >= 0 && p < r)
            return p;
        }
        return f;
      }) : this.prerelease = [], this.build = d[5] ? d[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(u) {
      if (e("SemVer.compare", this.version, this.options, u), !(u instanceof o)) {
        if (typeof u == "string" && u === this.version)
          return 0;
        u = new o(u, this.options);
      }
      return u.version === this.version ? 0 : this.compareMain(u) || this.comparePre(u);
    }
    compareMain(u) {
      return u instanceof o || (u = new o(u, this.options)), this.major < u.major ? -1 : this.major > u.major ? 1 : this.minor < u.minor ? -1 : this.minor > u.minor ? 1 : this.patch < u.patch ? -1 : this.patch > u.patch ? 1 : 0;
    }
    comparePre(u) {
      if (u instanceof o || (u = new o(u, this.options)), this.prerelease.length && !u.prerelease.length)
        return -1;
      if (!this.prerelease.length && u.prerelease.length)
        return 1;
      if (!this.prerelease.length && !u.prerelease.length)
        return 0;
      let l = 0;
      do {
        const d = this.prerelease[l], f = u.prerelease[l];
        if (e("prerelease compare", l, d, f), d === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === f)
          continue;
        return s(d, f);
      } while (++l);
    }
    compareBuild(u) {
      u instanceof o || (u = new o(u, this.options));
      let l = 0;
      do {
        const d = this.build[l], f = u.build[l];
        if (e("build compare", l, d, f), d === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === f)
          continue;
        return s(d, f);
      } while (++l);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(u, l, d) {
      if (u.startsWith("pre")) {
        if (!l && d === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (l) {
          const f = `-${l}`.match(this.options.loose ? n[i.PRERELEASELOOSE] : n[i.PRERELEASE]);
          if (!f || f[1] !== l)
            throw new Error(`invalid identifier: ${l}`);
        }
      }
      switch (u) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l, d);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l, d);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        case "release":
          if (this.prerelease.length === 0)
            throw new Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const f = Number(d) ? 1 : 0;
          if (this.prerelease.length === 0)
            this.prerelease = [f];
          else {
            let p = this.prerelease.length;
            for (; --p >= 0; )
              typeof this.prerelease[p] == "number" && (this.prerelease[p]++, p = -2);
            if (p === -1) {
              if (l === this.prerelease.join(".") && d === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(f);
            }
          }
          if (l) {
            let p = [l, f];
            d === !1 && (p = [l]), s(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = p) : this.prerelease = p;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${u}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  return id = o, id;
}
var ad, E_;
function ta() {
  if (E_) return ad;
  E_ = 1;
  const e = mr();
  return ad = (r, n, i = !1) => {
    if (r instanceof e)
      return r;
    try {
      return new e(r, n);
    } catch (a) {
      if (!i)
        return null;
      throw a;
    }
  }, ad;
}
var sd, w_;
function K$() {
  if (w_) return sd;
  w_ = 1;
  const e = ta();
  return sd = (r, n) => {
    const i = e(r, n);
    return i ? i.version : null;
  }, sd;
}
var od, x_;
function Y$() {
  if (x_) return od;
  x_ = 1;
  const e = ta();
  return od = (r, n) => {
    const i = e(r.trim().replace(/^[=v]+/, ""), n);
    return i ? i.version : null;
  }, od;
}
var cd, T_;
function J$() {
  if (T_) return cd;
  T_ = 1;
  const e = mr();
  return cd = (r, n, i, a, s) => {
    typeof i == "string" && (s = a, a = i, i = void 0);
    try {
      return new e(
        r instanceof e ? r.version : r,
        i
      ).inc(n, a, s).version;
    } catch {
      return null;
    }
  }, cd;
}
var ld, S_;
function Q$() {
  if (S_) return ld;
  S_ = 1;
  const e = ta();
  return ld = (r, n) => {
    const i = e(r, null, !0), a = e(n, null, !0), s = i.compare(a);
    if (s === 0)
      return null;
    const o = s > 0, c = o ? i : a, u = o ? a : i, l = !!c.prerelease.length;
    if (!!u.prerelease.length && !l) {
      if (!u.patch && !u.minor)
        return "major";
      if (u.compareMain(c) === 0)
        return u.minor && !u.patch ? "minor" : "patch";
    }
    const f = l ? "pre" : "";
    return i.major !== a.major ? f + "major" : i.minor !== a.minor ? f + "minor" : i.patch !== a.patch ? f + "patch" : "prerelease";
  }, ld;
}
var ud, A_;
function Z$() {
  if (A_) return ud;
  A_ = 1;
  const e = mr();
  return ud = (r, n) => new e(r, n).major, ud;
}
var fd, R_;
function eO() {
  if (R_) return fd;
  R_ = 1;
  const e = mr();
  return fd = (r, n) => new e(r, n).minor, fd;
}
var dd, $_;
function tO() {
  if ($_) return dd;
  $_ = 1;
  const e = mr();
  return dd = (r, n) => new e(r, n).patch, dd;
}
var hd, O_;
function rO() {
  if (O_) return hd;
  O_ = 1;
  const e = ta();
  return hd = (r, n) => {
    const i = e(r, n);
    return i && i.prerelease.length ? i.prerelease : null;
  }, hd;
}
var pd, N_;
function tn() {
  if (N_) return pd;
  N_ = 1;
  const e = mr();
  return pd = (r, n, i) => new e(r, i).compare(new e(n, i)), pd;
}
var md, P_;
function nO() {
  if (P_) return md;
  P_ = 1;
  const e = tn();
  return md = (r, n, i) => e(n, r, i), md;
}
var gd, C_;
function iO() {
  if (C_) return gd;
  C_ = 1;
  const e = tn();
  return gd = (r, n) => e(r, n, !0), gd;
}
var vd, I_;
function M0() {
  if (I_) return vd;
  I_ = 1;
  const e = mr();
  return vd = (r, n, i) => {
    const a = new e(r, i), s = new e(n, i);
    return a.compare(s) || a.compareBuild(s);
  }, vd;
}
var _d, b_;
function aO() {
  if (b_) return _d;
  b_ = 1;
  const e = M0();
  return _d = (r, n) => r.sort((i, a) => e(i, a, n)), _d;
}
var yd, F_;
function sO() {
  if (F_) return yd;
  F_ = 1;
  const e = M0();
  return yd = (r, n) => r.sort((i, a) => e(a, i, n)), yd;
}
var Ed, D_;
function vl() {
  if (D_) return Ed;
  D_ = 1;
  const e = tn();
  return Ed = (r, n, i) => e(r, n, i) > 0, Ed;
}
var wd, k_;
function U0() {
  if (k_) return wd;
  k_ = 1;
  const e = tn();
  return wd = (r, n, i) => e(r, n, i) < 0, wd;
}
var xd, L_;
function ew() {
  if (L_) return xd;
  L_ = 1;
  const e = tn();
  return xd = (r, n, i) => e(r, n, i) === 0, xd;
}
var Td, M_;
function tw() {
  if (M_) return Td;
  M_ = 1;
  const e = tn();
  return Td = (r, n, i) => e(r, n, i) !== 0, Td;
}
var Sd, U_;
function q0() {
  if (U_) return Sd;
  U_ = 1;
  const e = tn();
  return Sd = (r, n, i) => e(r, n, i) >= 0, Sd;
}
var Ad, q_;
function B0() {
  if (q_) return Ad;
  q_ = 1;
  const e = tn();
  return Ad = (r, n, i) => e(r, n, i) <= 0, Ad;
}
var Rd, B_;
function rw() {
  if (B_) return Rd;
  B_ = 1;
  const e = ew(), t = tw(), r = vl(), n = q0(), i = U0(), a = B0();
  return Rd = (o, c, u, l) => {
    switch (c) {
      case "===":
        return typeof o == "object" && (o = o.version), typeof u == "object" && (u = u.version), o === u;
      case "!==":
        return typeof o == "object" && (o = o.version), typeof u == "object" && (u = u.version), o !== u;
      case "":
      case "=":
      case "==":
        return e(o, u, l);
      case "!=":
        return t(o, u, l);
      case ">":
        return r(o, u, l);
      case ">=":
        return n(o, u, l);
      case "<":
        return i(o, u, l);
      case "<=":
        return a(o, u, l);
      default:
        throw new TypeError(`Invalid operator: ${c}`);
    }
  }, Rd;
}
var $d, j_;
function oO() {
  if (j_) return $d;
  j_ = 1;
  const e = mr(), t = ta(), { safeRe: r, t: n } = as();
  return $d = (a, s) => {
    if (a instanceof e)
      return a;
    if (typeof a == "number" && (a = String(a)), typeof a != "string")
      return null;
    s = s || {};
    let o = null;
    if (!s.rtl)
      o = a.match(s.includePrerelease ? r[n.COERCEFULL] : r[n.COERCE]);
    else {
      const p = s.includePrerelease ? r[n.COERCERTLFULL] : r[n.COERCERTL];
      let v;
      for (; (v = p.exec(a)) && (!o || o.index + o[0].length !== a.length); )
        (!o || v.index + v[0].length !== o.index + o[0].length) && (o = v), p.lastIndex = v.index + v[1].length + v[2].length;
      p.lastIndex = -1;
    }
    if (o === null)
      return null;
    const c = o[2], u = o[3] || "0", l = o[4] || "0", d = s.includePrerelease && o[5] ? `-${o[5]}` : "", f = s.includePrerelease && o[6] ? `+${o[6]}` : "";
    return t(`${c}.${u}.${l}${d}${f}`, s);
  }, $d;
}
var Od, V_;
function cO() {
  if (V_) return Od;
  V_ = 1;
  class e {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(r) {
      const n = this.map.get(r);
      if (n !== void 0)
        return this.map.delete(r), this.map.set(r, n), n;
    }
    delete(r) {
      return this.map.delete(r);
    }
    set(r, n) {
      if (!this.delete(r) && n !== void 0) {
        if (this.map.size >= this.max) {
          const a = this.map.keys().next().value;
          this.delete(a);
        }
        this.map.set(r, n);
      }
      return this;
    }
  }
  return Od = e, Od;
}
var Nd, H_;
function rn() {
  if (H_) return Nd;
  H_ = 1;
  const e = /\s+/g;
  class t {
    constructor(V, ie) {
      if (ie = i(ie), V instanceof t)
        return V.loose === !!ie.loose && V.includePrerelease === !!ie.includePrerelease ? V : new t(V.raw, ie);
      if (V instanceof a)
        return this.raw = V.value, this.set = [[V]], this.formatted = void 0, this;
      if (this.options = ie, this.loose = !!ie.loose, this.includePrerelease = !!ie.includePrerelease, this.raw = V.trim().replace(e, " "), this.set = this.raw.split("||").map((W) => this.parseRange(W.trim())).filter((W) => W.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const W = this.set[0];
        if (this.set = this.set.filter((ae) => !m(ae[0])), this.set.length === 0)
          this.set = [W];
        else if (this.set.length > 1) {
          for (const ae of this.set)
            if (ae.length === 1 && h(ae[0])) {
              this.set = [ae];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let V = 0; V < this.set.length; V++) {
          V > 0 && (this.formatted += "||");
          const ie = this.set[V];
          for (let W = 0; W < ie.length; W++)
            W > 0 && (this.formatted += " "), this.formatted += ie[W].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(V) {
      const W = ((this.options.includePrerelease && p) | (this.options.loose && v)) + ":" + V, ae = n.get(W);
      if (ae)
        return ae;
      const se = this.options.loose, X = se ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      V = V.replace(X, U(this.options.includePrerelease)), s("hyphen replace", V), V = V.replace(c[u.COMPARATORTRIM], l), s("comparator trim", V), V = V.replace(c[u.TILDETRIM], d), s("tilde trim", V), V = V.replace(c[u.CARETTRIM], f), s("caret trim", V);
      let k = V.split(" ").map((A) => g(A, this.options)).join(" ").split(/\s+/).map((A) => F(A, this.options));
      se && (k = k.filter((A) => (s("loose invalid filter", A, this.options), !!A.match(c[u.COMPARATORLOOSE])))), s("range list", k);
      const I = /* @__PURE__ */ new Map(), C = k.map((A) => new a(A, this.options));
      for (const A of C) {
        if (m(A))
          return [A];
        I.set(A.value, A);
      }
      I.size > 1 && I.has("") && I.delete("");
      const T = [...I.values()];
      return n.set(W, T), T;
    }
    intersects(V, ie) {
      if (!(V instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((W) => _(W, ie) && V.set.some((ae) => _(ae, ie) && W.every((se) => ae.every((X) => se.intersects(X, ie)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(V) {
      if (!V)
        return !1;
      if (typeof V == "string")
        try {
          V = new o(V, this.options);
        } catch {
          return !1;
        }
      for (let ie = 0; ie < this.set.length; ie++)
        if (G(this.set[ie], V, this.options))
          return !0;
      return !1;
    }
  }
  Nd = t;
  const r = cO(), n = new r(), i = L0(), a = _l(), s = gl(), o = mr(), {
    safeRe: c,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: d,
    caretTrimReplace: f
  } = as(), { FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: v } = ml(), m = (M) => M.value === "<0.0.0-0", h = (M) => M.value === "", _ = (M, V) => {
    let ie = !0;
    const W = M.slice();
    let ae = W.pop();
    for (; ie && W.length; )
      ie = W.every((se) => ae.intersects(se, V)), ae = W.pop();
    return ie;
  }, g = (M, V) => (M = M.replace(c[u.BUILD], ""), s("comp", M, V), M = w(M, V), s("caret", M), M = x(M, V), s("tildes", M), M = R(M, V), s("xrange", M), M = B(M, V), s("stars", M), M), y = (M) => !M || M.toLowerCase() === "x" || M === "*", x = (M, V) => M.trim().split(/\s+/).map((ie) => S(ie, V)).join(" "), S = (M, V) => {
    const ie = V.loose ? c[u.TILDELOOSE] : c[u.TILDE];
    return M.replace(ie, (W, ae, se, X, k) => {
      s("tilde", M, W, ae, se, X, k);
      let I;
      return y(ae) ? I = "" : y(se) ? I = `>=${ae}.0.0 <${+ae + 1}.0.0-0` : y(X) ? I = `>=${ae}.${se}.0 <${ae}.${+se + 1}.0-0` : k ? (s("replaceTilde pr", k), I = `>=${ae}.${se}.${X}-${k} <${ae}.${+se + 1}.0-0`) : I = `>=${ae}.${se}.${X} <${ae}.${+se + 1}.0-0`, s("tilde return", I), I;
    });
  }, w = (M, V) => M.trim().split(/\s+/).map((ie) => E(ie, V)).join(" "), E = (M, V) => {
    s("caret", M, V);
    const ie = V.loose ? c[u.CARETLOOSE] : c[u.CARET], W = V.includePrerelease ? "-0" : "";
    return M.replace(ie, (ae, se, X, k, I) => {
      s("caret", M, ae, se, X, k, I);
      let C;
      return y(se) ? C = "" : y(X) ? C = `>=${se}.0.0${W} <${+se + 1}.0.0-0` : y(k) ? se === "0" ? C = `>=${se}.${X}.0${W} <${se}.${+X + 1}.0-0` : C = `>=${se}.${X}.0${W} <${+se + 1}.0.0-0` : I ? (s("replaceCaret pr", I), se === "0" ? X === "0" ? C = `>=${se}.${X}.${k}-${I} <${se}.${X}.${+k + 1}-0` : C = `>=${se}.${X}.${k}-${I} <${se}.${+X + 1}.0-0` : C = `>=${se}.${X}.${k}-${I} <${+se + 1}.0.0-0`) : (s("no pr"), se === "0" ? X === "0" ? C = `>=${se}.${X}.${k}${W} <${se}.${X}.${+k + 1}-0` : C = `>=${se}.${X}.${k}${W} <${se}.${+X + 1}.0-0` : C = `>=${se}.${X}.${k} <${+se + 1}.0.0-0`), s("caret return", C), C;
    });
  }, R = (M, V) => (s("replaceXRanges", M, V), M.split(/\s+/).map((ie) => N(ie, V)).join(" ")), N = (M, V) => {
    M = M.trim();
    const ie = V.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
    return M.replace(ie, (W, ae, se, X, k, I) => {
      s("xRange", M, W, ae, se, X, k, I);
      const C = y(se), T = C || y(X), A = T || y(k), L = A;
      return ae === "=" && L && (ae = ""), I = V.includePrerelease ? "-0" : "", C ? ae === ">" || ae === "<" ? W = "<0.0.0-0" : W = "*" : ae && L ? (T && (X = 0), k = 0, ae === ">" ? (ae = ">=", T ? (se = +se + 1, X = 0, k = 0) : (X = +X + 1, k = 0)) : ae === "<=" && (ae = "<", T ? se = +se + 1 : X = +X + 1), ae === "<" && (I = "-0"), W = `${ae + se}.${X}.${k}${I}`) : T ? W = `>=${se}.0.0${I} <${+se + 1}.0.0-0` : A && (W = `>=${se}.${X}.0${I} <${se}.${+X + 1}.0-0`), s("xRange return", W), W;
    });
  }, B = (M, V) => (s("replaceStars", M, V), M.trim().replace(c[u.STAR], "")), F = (M, V) => (s("replaceGTE0", M, V), M.trim().replace(c[V.includePrerelease ? u.GTE0PRE : u.GTE0], "")), U = (M) => (V, ie, W, ae, se, X, k, I, C, T, A, L) => (y(W) ? ie = "" : y(ae) ? ie = `>=${W}.0.0${M ? "-0" : ""}` : y(se) ? ie = `>=${W}.${ae}.0${M ? "-0" : ""}` : X ? ie = `>=${ie}` : ie = `>=${ie}${M ? "-0" : ""}`, y(C) ? I = "" : y(T) ? I = `<${+C + 1}.0.0-0` : y(A) ? I = `<${C}.${+T + 1}.0-0` : L ? I = `<=${C}.${T}.${A}-${L}` : M ? I = `<${C}.${T}.${+A + 1}-0` : I = `<=${I}`, `${ie} ${I}`.trim()), G = (M, V, ie) => {
    for (let W = 0; W < M.length; W++)
      if (!M[W].test(V))
        return !1;
    if (V.prerelease.length && !ie.includePrerelease) {
      for (let W = 0; W < M.length; W++)
        if (s(M[W].semver), M[W].semver !== a.ANY && M[W].semver.prerelease.length > 0) {
          const ae = M[W].semver;
          if (ae.major === V.major && ae.minor === V.minor && ae.patch === V.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Nd;
}
var Pd, G_;
function _l() {
  if (G_) return Pd;
  G_ = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(l, d) {
      if (d = r(d), l instanceof t) {
        if (l.loose === !!d.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), s("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, s("comp", this);
    }
    parse(l) {
      const d = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], f = l.match(d);
      if (!f)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = f[1] !== void 0 ? f[1] : "", this.operator === "=" && (this.operator = ""), f[2] ? this.semver = new o(f[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (s("Comparator.test", l, this.options.loose), this.semver === e || l === e)
        return !0;
      if (typeof l == "string")
        try {
          l = new o(l, this.options);
        } catch {
          return !1;
        }
      return a(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new c(this.value, d).test(l.semver) : (d = r(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || a(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || a(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  Pd = t;
  const r = L0(), { safeRe: n, t: i } = as(), a = rw(), s = gl(), o = mr(), c = rn();
  return Pd;
}
var Cd, z_;
function yl() {
  if (z_) return Cd;
  z_ = 1;
  const e = rn();
  return Cd = (r, n, i) => {
    try {
      n = new e(n, i);
    } catch {
      return !1;
    }
    return n.test(r);
  }, Cd;
}
var Id, W_;
function lO() {
  if (W_) return Id;
  W_ = 1;
  const e = rn();
  return Id = (r, n) => new e(r, n).set.map((i) => i.map((a) => a.value).join(" ").trim().split(" ")), Id;
}
var bd, X_;
function uO() {
  if (X_) return bd;
  X_ = 1;
  const e = mr(), t = rn();
  return bd = (n, i, a) => {
    let s = null, o = null, c = null;
    try {
      c = new t(i, a);
    } catch {
      return null;
    }
    return n.forEach((u) => {
      c.test(u) && (!s || o.compare(u) === -1) && (s = u, o = new e(s, a));
    }), s;
  }, bd;
}
var Fd, K_;
function fO() {
  if (K_) return Fd;
  K_ = 1;
  const e = mr(), t = rn();
  return Fd = (n, i, a) => {
    let s = null, o = null, c = null;
    try {
      c = new t(i, a);
    } catch {
      return null;
    }
    return n.forEach((u) => {
      c.test(u) && (!s || o.compare(u) === 1) && (s = u, o = new e(s, a));
    }), s;
  }, Fd;
}
var Dd, Y_;
function dO() {
  if (Y_) return Dd;
  Y_ = 1;
  const e = mr(), t = rn(), r = vl();
  return Dd = (i, a) => {
    i = new t(i, a);
    let s = new e("0.0.0");
    if (i.test(s) || (s = new e("0.0.0-0"), i.test(s)))
      return s;
    s = null;
    for (let o = 0; o < i.set.length; ++o) {
      const c = i.set[o];
      let u = null;
      c.forEach((l) => {
        const d = new e(l.semver.version);
        switch (l.operator) {
          case ">":
            d.prerelease.length === 0 ? d.patch++ : d.prerelease.push(0), d.raw = d.format();
          /* fallthrough */
          case "":
          case ">=":
            (!u || r(d, u)) && (u = d);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${l.operator}`);
        }
      }), u && (!s || r(s, u)) && (s = u);
    }
    return s && i.test(s) ? s : null;
  }, Dd;
}
var kd, J_;
function hO() {
  if (J_) return kd;
  J_ = 1;
  const e = rn();
  return kd = (r, n) => {
    try {
      return new e(r, n).range || "*";
    } catch {
      return null;
    }
  }, kd;
}
var Ld, Q_;
function j0() {
  if (Q_) return Ld;
  Q_ = 1;
  const e = mr(), t = _l(), { ANY: r } = t, n = rn(), i = yl(), a = vl(), s = U0(), o = B0(), c = q0();
  return Ld = (l, d, f, p) => {
    l = new e(l, p), d = new n(d, p);
    let v, m, h, _, g;
    switch (f) {
      case ">":
        v = a, m = o, h = s, _ = ">", g = ">=";
        break;
      case "<":
        v = s, m = c, h = a, _ = "<", g = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (i(l, d, p))
      return !1;
    for (let y = 0; y < d.set.length; ++y) {
      const x = d.set[y];
      let S = null, w = null;
      if (x.forEach((E) => {
        E.semver === r && (E = new t(">=0.0.0")), S = S || E, w = w || E, v(E.semver, S.semver, p) ? S = E : h(E.semver, w.semver, p) && (w = E);
      }), S.operator === _ || S.operator === g || (!w.operator || w.operator === _) && m(l, w.semver))
        return !1;
      if (w.operator === g && h(l, w.semver))
        return !1;
    }
    return !0;
  }, Ld;
}
var Md, Z_;
function pO() {
  if (Z_) return Md;
  Z_ = 1;
  const e = j0();
  return Md = (r, n, i) => e(r, n, ">", i), Md;
}
var Ud, ey;
function mO() {
  if (ey) return Ud;
  ey = 1;
  const e = j0();
  return Ud = (r, n, i) => e(r, n, "<", i), Ud;
}
var qd, ty;
function gO() {
  if (ty) return qd;
  ty = 1;
  const e = rn();
  return qd = (r, n, i) => (r = new e(r, i), n = new e(n, i), r.intersects(n, i)), qd;
}
var Bd, ry;
function vO() {
  if (ry) return Bd;
  ry = 1;
  const e = yl(), t = tn();
  return Bd = (r, n, i) => {
    const a = [];
    let s = null, o = null;
    const c = r.sort((f, p) => t(f, p, i));
    for (const f of c)
      e(f, n, i) ? (o = f, s || (s = f)) : (o && a.push([s, o]), o = null, s = null);
    s && a.push([s, null]);
    const u = [];
    for (const [f, p] of a)
      f === p ? u.push(f) : !p && f === c[0] ? u.push("*") : p ? f === c[0] ? u.push(`<=${p}`) : u.push(`${f} - ${p}`) : u.push(`>=${f}`);
    const l = u.join(" || "), d = typeof n.raw == "string" ? n.raw : String(n);
    return l.length < d.length ? l : n;
  }, Bd;
}
var jd, ny;
function _O() {
  if (ny) return jd;
  ny = 1;
  const e = rn(), t = _l(), { ANY: r } = t, n = yl(), i = tn(), a = (d, f, p = {}) => {
    if (d === f)
      return !0;
    d = new e(d, p), f = new e(f, p);
    let v = !1;
    e: for (const m of d.set) {
      for (const h of f.set) {
        const _ = c(m, h, p);
        if (v = v || _ !== null, _)
          continue e;
      }
      if (v)
        return !1;
    }
    return !0;
  }, s = [new t(">=0.0.0-0")], o = [new t(">=0.0.0")], c = (d, f, p) => {
    if (d === f)
      return !0;
    if (d.length === 1 && d[0].semver === r) {
      if (f.length === 1 && f[0].semver === r)
        return !0;
      p.includePrerelease ? d = s : d = o;
    }
    if (f.length === 1 && f[0].semver === r) {
      if (p.includePrerelease)
        return !0;
      f = o;
    }
    const v = /* @__PURE__ */ new Set();
    let m, h;
    for (const R of d)
      R.operator === ">" || R.operator === ">=" ? m = u(m, R, p) : R.operator === "<" || R.operator === "<=" ? h = l(h, R, p) : v.add(R.semver);
    if (v.size > 1)
      return null;
    let _;
    if (m && h) {
      if (_ = i(m.semver, h.semver, p), _ > 0)
        return null;
      if (_ === 0 && (m.operator !== ">=" || h.operator !== "<="))
        return null;
    }
    for (const R of v) {
      if (m && !n(R, String(m), p) || h && !n(R, String(h), p))
        return null;
      for (const N of f)
        if (!n(R, String(N), p))
          return !1;
      return !0;
    }
    let g, y, x, S, w = h && !p.includePrerelease && h.semver.prerelease.length ? h.semver : !1, E = m && !p.includePrerelease && m.semver.prerelease.length ? m.semver : !1;
    w && w.prerelease.length === 1 && h.operator === "<" && w.prerelease[0] === 0 && (w = !1);
    for (const R of f) {
      if (S = S || R.operator === ">" || R.operator === ">=", x = x || R.operator === "<" || R.operator === "<=", m) {
        if (E && R.semver.prerelease && R.semver.prerelease.length && R.semver.major === E.major && R.semver.minor === E.minor && R.semver.patch === E.patch && (E = !1), R.operator === ">" || R.operator === ">=") {
          if (g = u(m, R, p), g === R && g !== m)
            return !1;
        } else if (m.operator === ">=" && !n(m.semver, String(R), p))
          return !1;
      }
      if (h) {
        if (w && R.semver.prerelease && R.semver.prerelease.length && R.semver.major === w.major && R.semver.minor === w.minor && R.semver.patch === w.patch && (w = !1), R.operator === "<" || R.operator === "<=") {
          if (y = l(h, R, p), y === R && y !== h)
            return !1;
        } else if (h.operator === "<=" && !n(h.semver, String(R), p))
          return !1;
      }
      if (!R.operator && (h || m) && _ !== 0)
        return !1;
    }
    return !(m && x && !h && _ !== 0 || h && S && !m && _ !== 0 || E || w);
  }, u = (d, f, p) => {
    if (!d)
      return f;
    const v = i(d.semver, f.semver, p);
    return v > 0 ? d : v < 0 || f.operator === ">" && d.operator === ">=" ? f : d;
  }, l = (d, f, p) => {
    if (!d)
      return f;
    const v = i(d.semver, f.semver, p);
    return v < 0 ? d : v > 0 || f.operator === "<" && d.operator === "<=" ? f : d;
  };
  return jd = a, jd;
}
var Vd, iy;
function yO() {
  if (iy) return Vd;
  iy = 1;
  const e = as(), t = ml(), r = mr(), n = ZE(), i = ta(), a = K$(), s = Y$(), o = J$(), c = Q$(), u = Z$(), l = eO(), d = tO(), f = rO(), p = tn(), v = nO(), m = iO(), h = M0(), _ = aO(), g = sO(), y = vl(), x = U0(), S = ew(), w = tw(), E = q0(), R = B0(), N = rw(), B = oO(), F = _l(), U = rn(), G = yl(), M = lO(), V = uO(), ie = fO(), W = dO(), ae = hO(), se = j0(), X = pO(), k = mO(), I = gO(), C = vO(), T = _O();
  return Vd = {
    parse: i,
    valid: a,
    clean: s,
    inc: o,
    diff: c,
    major: u,
    minor: l,
    patch: d,
    prerelease: f,
    compare: p,
    rcompare: v,
    compareLoose: m,
    compareBuild: h,
    sort: _,
    rsort: g,
    gt: y,
    lt: x,
    eq: S,
    neq: w,
    gte: E,
    lte: R,
    cmp: N,
    coerce: B,
    Comparator: F,
    Range: U,
    satisfies: G,
    toComparators: M,
    maxSatisfying: V,
    minSatisfying: ie,
    minVersion: W,
    validRange: ae,
    outside: se,
    gtr: X,
    ltr: k,
    intersects: I,
    simplifyRange: C,
    subset: T,
    SemVer: r,
    re: e.re,
    src: e.src,
    tokens: e.t,
    SEMVER_SPEC_VERSION: t.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: t.RELEASE_TYPES,
    compareIdentifiers: n.compareIdentifiers,
    rcompareIdentifiers: n.rcompareIdentifiers
  }, Vd;
}
var EO = yO();
const Li = /* @__PURE__ */ rE(EO), wO = Object.prototype.toString, xO = "[object Uint8Array]", TO = "[object ArrayBuffer]";
function nw(e, t, r) {
  return e ? e.constructor === t ? !0 : wO.call(e) === r : !1;
}
function iw(e) {
  return nw(e, Uint8Array, xO);
}
function SO(e) {
  return nw(e, ArrayBuffer, TO);
}
function AO(e) {
  return iw(e) || SO(e);
}
function RO(e) {
  if (!iw(e))
    throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof e}\``);
}
function $O(e) {
  if (!AO(e))
    throw new TypeError(`Expected \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof e}\``);
}
function Hd(e, t) {
  if (e.length === 0)
    return new Uint8Array(0);
  t ??= e.reduce((i, a) => i + a.length, 0);
  const r = new Uint8Array(t);
  let n = 0;
  for (const i of e)
    RO(i), r.set(i, n), n += i.length;
  return r;
}
const ay = {
  utf8: new globalThis.TextDecoder("utf8")
};
function mc(e, t = "utf8") {
  return $O(e), ay[t] ??= new globalThis.TextDecoder(t), ay[t].decode(e);
}
function OO(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected \`string\`, got \`${typeof e}\``);
}
const NO = new globalThis.TextEncoder();
function gc(e) {
  return OO(e), NO.encode(e);
}
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
const Gd = "aes-256-cbc", Ln = () => /* @__PURE__ */ Object.create(null), sy = (e) => e !== void 0, zd = (e, t) => {
  const r = /* @__PURE__ */ new Set([
    "undefined",
    "symbol",
    "function"
  ]), n = typeof t;
  if (r.has(n))
    throw new TypeError(`Setting a value of type \`${n}\` for key \`${e}\` is not allowed as it's not supported by JSON`);
}, Un = "__internal__", Wd = `${Un}.migrations.version`;
class PO {
  path;
  events;
  #i;
  #r;
  #e;
  #t = {};
  #a = !1;
  #s;
  #o;
  #n;
  constructor(t = {}) {
    const r = this.#c(t);
    this.#e = r, this.#l(r), this.#f(r), this.#d(r), this.events = new EventTarget(), this.#r = r.encryptionKey, this.path = this.#h(r), this.#p(r), r.watch && this._watch();
  }
  get(t, r) {
    if (this.#e.accessPropertiesByDotNotation)
      return this._get(t, r);
    const { store: n } = this;
    return t in n ? n[t] : r;
  }
  set(t, r) {
    if (typeof t != "string" && typeof t != "object")
      throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof t}`);
    if (typeof t != "object" && r === void 0)
      throw new TypeError("Use `delete()` to clear values");
    if (this._containsReservedKey(t))
      throw new TypeError(`Please don't use the ${Un} key, as it's used to manage this module internal operations.`);
    const { store: n } = this, i = (a, s) => {
      if (zd(a, s), this.#e.accessPropertiesByDotNotation)
        Cs(n, a, s);
      else {
        if (a === "__proto__" || a === "constructor" || a === "prototype")
          return;
        n[a] = s;
      }
    };
    if (typeof t == "object") {
      const a = t;
      for (const [s, o] of Object.entries(a))
        i(s, o);
    } else
      i(t, r);
    this.store = n;
  }
  has(t) {
    return this.#e.accessPropertiesByDotNotation ? bf(this.store, t) : t in this.store;
  }
  appendToArray(t, r) {
    zd(t, r);
    const n = this.#e.accessPropertiesByDotNotation ? this._get(t, []) : t in this.store ? this.store[t] : [];
    if (!Array.isArray(n))
      throw new TypeError(`The key \`${t}\` is already set to a non-array value`);
    this.set(t, [...n, r]);
  }
  /**
      Reset items to their default values, as defined by the `defaults` or `schema` option.
  
      @see `clear()` to reset all items.
  
      @param keys - The keys of the items to reset.
      */
  reset(...t) {
    for (const r of t)
      sy(this.#t[r]) && this.set(r, this.#t[r]);
  }
  delete(t) {
    const { store: r } = this;
    this.#e.accessPropertiesByDotNotation ? zS(r, t) : delete r[t], this.store = r;
  }
  /**
      Delete all items.
  
      This resets known items to their default values, if defined by the `defaults` or `schema` option.
      */
  clear() {
    const t = Ln();
    for (const r of Object.keys(this.#t))
      sy(this.#t[r]) && (zd(r, this.#t[r]), this.#e.accessPropertiesByDotNotation ? Cs(t, r, this.#t[r]) : t[r] = this.#t[r]);
    this.store = t;
  }
  onDidChange(t, r) {
    if (typeof t != "string")
      throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof t}`);
    if (typeof r != "function")
      throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof r}`);
    return this._handleValueChange(() => this.get(t), r);
  }
  /**
      Watches the whole config object, calling `callback` on any changes.
  
      @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
      @returns A function, that when called, will unsubscribe.
      */
  onDidAnyChange(t) {
    if (typeof t != "function")
      throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof t}`);
    return this._handleStoreChange(t);
  }
  get size() {
    return Object.keys(this.store).filter((r) => !this._isReservedKeyPath(r)).length;
  }
  /**
      Get all the config as an object or replace the current config with an object.
  
      @example
      ```
      console.log(config.store);
      //=> {name: 'John', age: 30}
      ```
  
      @example
      ```
      config.store = {
          hello: 'world'
      };
      ```
      */
  get store() {
    try {
      const t = Je.readFileSync(this.path, this.#r ? null : "utf8"), r = this._decryptData(t), n = this._deserialize(r);
      return this.#a || this._validate(n), Object.assign(Ln(), n);
    } catch (t) {
      if (t?.code === "ENOENT")
        return this._ensureDirectory(), Ln();
      if (this.#e.clearInvalidConfig) {
        const r = t;
        if (r.name === "SyntaxError" || r.message?.startsWith("Config schema violation:"))
          return Ln();
      }
      throw t;
    }
  }
  set store(t) {
    if (this._ensureDirectory(), !bf(t, Un))
      try {
        const r = Je.readFileSync(this.path, this.#r ? null : "utf8"), n = this._decryptData(r), i = this._deserialize(n);
        bf(i, Un) && Cs(t, Un, A1(i, Un));
      } catch {
      }
    this.#a || this._validate(t), this._write(t), this.events.dispatchEvent(new Event("change"));
  }
  *[Symbol.iterator]() {
    for (const [t, r] of Object.entries(this.store))
      this._isReservedKeyPath(t) || (yield [t, r]);
  }
  /**
  Close the file watcher if one exists. This is useful in tests to prevent the process from hanging.
  */
  _closeWatcher() {
    this.#s && (this.#s.close(), this.#s = void 0), this.#o && (Je.unwatchFile(this.path), this.#o = !1), this.#n = void 0;
  }
  _decryptData(t) {
    if (!this.#r)
      return typeof t == "string" ? t : mc(t);
    try {
      const r = t.slice(0, 16), n = Zn.pbkdf2Sync(this.#r, r, 1e4, 32, "sha512"), i = Zn.createDecipheriv(Gd, n, r), a = t.slice(17), s = typeof a == "string" ? gc(a) : a;
      return mc(Hd([i.update(s), i.final()]));
    } catch {
      try {
        const r = t.slice(0, 16), n = Zn.pbkdf2Sync(this.#r, r.toString(), 1e4, 32, "sha512"), i = Zn.createDecipheriv(Gd, n, r), a = t.slice(17), s = typeof a == "string" ? gc(a) : a;
        return mc(Hd([i.update(s), i.final()]));
      } catch {
      }
    }
    return typeof t == "string" ? t : mc(t);
  }
  _handleStoreChange(t) {
    let r = this.store;
    const n = () => {
      const i = r, a = this.store;
      xh(a, i) || (r = a, t.call(this, a, i));
    };
    return this.events.addEventListener("change", n), () => {
      this.events.removeEventListener("change", n);
    };
  }
  _handleValueChange(t, r) {
    let n = t();
    const i = () => {
      const a = n, s = t();
      xh(s, a) || (n = s, r.call(this, s, a));
    };
    return this.events.addEventListener("change", i), () => {
      this.events.removeEventListener("change", i);
    };
  }
  _deserialize = (t) => JSON.parse(t);
  _serialize = (t) => JSON.stringify(t, void 0, "	");
  _validate(t) {
    if (!this.#i || this.#i(t) || !this.#i.errors)
      return;
    const n = this.#i.errors.map(({ instancePath: i, message: a = "" }) => `\`${i.slice(1)}\` ${a}`);
    throw new Error("Config schema violation: " + n.join("; "));
  }
  _ensureDirectory() {
    Je.mkdirSync(ut.dirname(this.path), { recursive: !0 });
  }
  _write(t) {
    let r = this._serialize(t);
    if (this.#r) {
      const n = Zn.randomBytes(16), i = Zn.pbkdf2Sync(this.#r, n, 1e4, 32, "sha512"), a = Zn.createCipheriv(Gd, i, n);
      r = Hd([n, gc(":"), a.update(gc(r)), a.final()]);
    }
    if ($t.env.SNAP)
      Je.writeFileSync(this.path, r, { mode: this.#e.configFileMode });
    else
      try {
        ME(this.path, r, { mode: this.#e.configFileMode });
      } catch (n) {
        if (n?.code === "EXDEV") {
          Je.writeFileSync(this.path, r, { mode: this.#e.configFileMode });
          return;
        }
        throw n;
      }
  }
  _watch() {
    if (this._ensureDirectory(), Je.existsSync(this.path) || this._write(Ln()), $t.platform === "win32" || $t.platform === "darwin") {
      this.#n ??= h_(() => {
        this.events.dispatchEvent(new Event("change"));
      }, { wait: 100 });
      const t = ut.dirname(this.path), r = ut.basename(this.path);
      this.#s = Je.watch(t, { persistent: !1, encoding: "utf8" }, (n, i) => {
        i && i !== r || typeof this.#n == "function" && this.#n();
      });
    } else
      this.#n ??= h_(() => {
        this.events.dispatchEvent(new Event("change"));
      }, { wait: 1e3 }), Je.watchFile(this.path, { persistent: !1 }, (t, r) => {
        typeof this.#n == "function" && this.#n();
      }), this.#o = !0;
  }
  _migrate(t, r, n) {
    let i = this._get(Wd, "0.0.0");
    const a = Object.keys(t).filter((o) => this._shouldPerformMigration(o, i, r));
    let s = structuredClone(this.store);
    for (const o of a)
      try {
        n && n(this, {
          fromVersion: i,
          toVersion: o,
          finalVersion: r,
          versions: a
        });
        const c = t[o];
        c?.(this), this._set(Wd, o), i = o, s = structuredClone(this.store);
      } catch (c) {
        this.store = s;
        try {
          this._write(s);
        } catch {
        }
        const u = c instanceof Error ? c.message : String(c);
        throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${u}`);
      }
    (this._isVersionInRangeFormat(i) || !Li.eq(i, r)) && this._set(Wd, r);
  }
  _containsReservedKey(t) {
    return typeof t == "string" ? this._isReservedKeyPath(t) : !t || typeof t != "object" ? !1 : this._objectContainsReservedKey(t);
  }
  _objectContainsReservedKey(t) {
    if (!t || typeof t != "object")
      return !1;
    for (const [r, n] of Object.entries(t))
      if (this._isReservedKeyPath(r) || this._objectContainsReservedKey(n))
        return !0;
    return !1;
  }
  _isReservedKeyPath(t) {
    return t === Un || t.startsWith(`${Un}.`);
  }
  _isVersionInRangeFormat(t) {
    return Li.clean(t) === null;
  }
  _shouldPerformMigration(t, r, n) {
    return this._isVersionInRangeFormat(t) ? r !== "0.0.0" && Li.satisfies(r, t) ? !1 : Li.satisfies(n, t) : !(Li.lte(t, r) || Li.gt(t, n));
  }
  _get(t, r) {
    return A1(this.store, t, r);
  }
  _set(t, r) {
    const { store: n } = this;
    Cs(n, t, r), this.store = n;
  }
  #c(t) {
    const r = {
      configName: "config",
      fileExtension: "json",
      projectSuffix: "nodejs",
      clearInvalidConfig: !1,
      accessPropertiesByDotNotation: !0,
      configFileMode: 438,
      ...t
    };
    if (!r.cwd) {
      if (!r.projectName)
        throw new Error("Please specify the `projectName` option.");
      r.cwd = YS(r.projectName, { suffix: r.projectSuffix }).config;
    }
    return typeof r.fileExtension == "string" && (r.fileExtension = r.fileExtension.replace(/^\.+/, "")), r;
  }
  #l(t) {
    if (!(t.schema ?? t.ajvOptions ?? t.rootSchema))
      return;
    if (t.schema && typeof t.schema != "object")
      throw new TypeError("The `schema` option must be an object.");
    const r = q$.default, n = new IR.Ajv2020({
      allErrors: !0,
      useDefaults: !0,
      ...t.ajvOptions
    });
    r(n);
    const i = {
      ...t.rootSchema,
      type: "object",
      properties: t.schema
    };
    this.#i = n.compile(i), this.#u(t.schema);
  }
  #u(t) {
    const r = Object.entries(t ?? {});
    for (const [n, i] of r) {
      if (!i || typeof i != "object" || !Object.hasOwn(i, "default"))
        continue;
      const { default: a } = i;
      a !== void 0 && (this.#t[n] = a);
    }
  }
  #f(t) {
    t.defaults && Object.assign(this.#t, t.defaults);
  }
  #d(t) {
    t.serialize && (this._serialize = t.serialize), t.deserialize && (this._deserialize = t.deserialize);
  }
  #h(t) {
    const r = typeof t.fileExtension == "string" ? t.fileExtension : void 0, n = r ? `.${r}` : "";
    return ut.resolve(t.cwd, `${t.configName ?? "config"}${n}`);
  }
  #p(t) {
    if (t.migrations) {
      this.#m(t), this._validate(this.store);
      return;
    }
    const r = this.store, n = Object.assign(Ln(), t.defaults ?? {}, r);
    this._validate(n);
    try {
      Th.deepEqual(r, n);
    } catch {
      this.store = n;
    }
  }
  #m(t) {
    const { migrations: r, projectVersion: n } = t;
    if (r) {
      if (!n)
        throw new Error("Please specify the `projectVersion` option.");
      this.#a = !0;
      try {
        const i = this.store, a = Object.assign(Ln(), t.defaults ?? {}, i);
        try {
          Th.deepEqual(i, a);
        } catch {
          this._write(a);
        }
        this._migrate(r, n, t.beforeEachMigration);
      } finally {
        this.#a = !1;
      }
    }
  }
}
const { app: $c, ipcMain: a0, shell: CO } = Tn;
let oy = !1;
const cy = () => {
  if (!a0 || !$c)
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  const e = {
    defaultCwd: $c.getPath("userData"),
    appVersion: $c.getVersion()
  };
  return oy || (a0.on("electron-store-get-data", (t) => {
    t.returnValue = e;
  }), oy = !0), e;
};
class IO extends PO {
  constructor(t) {
    let r, n;
    if ($t.type === "renderer") {
      const i = Tn.ipcRenderer.sendSync("electron-store-get-data");
      if (!i)
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      ({ defaultCwd: r, appVersion: n } = i);
    } else a0 && $c && ({ defaultCwd: r, appVersion: n } = cy());
    t = {
      name: "config",
      ...t
    }, t.projectVersion ||= n, t.cwd ? t.cwd = ut.isAbsolute(t.cwd) ? t.cwd : ut.join(r, t.cwd) : t.cwd = r, t.configName = t.name, delete t.name, super(t);
  }
  static initRenderer() {
    cy();
  }
  async openInEditor() {
    const t = await CO.openPath(this.path);
    if (t)
      throw new Error(t);
  }
}
var bc = {};
bc.version = "0.18.5";
var aw = 1252, bO = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4], sw = function(e) {
  bO.indexOf(e) != -1 && (aw = e);
};
function FO() {
  sw(1252);
}
var Wa = function(e) {
  sw(e);
};
function DO() {
  Wa(1200), FO();
}
var vc = function(t) {
  return String.fromCharCode(t);
}, ly = function(t) {
  return String.fromCharCode(t);
}, Fc, Bn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Xa(e) {
  for (var t = "", r = 0, n = 0, i = 0, a = 0, s = 0, o = 0, c = 0, u = 0; u < e.length; )
    r = e.charCodeAt(u++), a = r >> 2, n = e.charCodeAt(u++), s = (r & 3) << 4 | n >> 4, i = e.charCodeAt(u++), o = (n & 15) << 2 | i >> 6, c = i & 63, isNaN(n) ? o = c = 64 : isNaN(i) && (c = 64), t += Bn.charAt(a) + Bn.charAt(s) + Bn.charAt(o) + Bn.charAt(c);
  return t;
}
function Sn(e) {
  var t = "", r = 0, n = 0, i = 0, a = 0, s = 0, o = 0, c = 0;
  e = e.replace(/[^\w\+\/\=]/g, "");
  for (var u = 0; u < e.length; )
    a = Bn.indexOf(e.charAt(u++)), s = Bn.indexOf(e.charAt(u++)), r = a << 2 | s >> 4, t += String.fromCharCode(r), o = Bn.indexOf(e.charAt(u++)), n = (s & 15) << 4 | o >> 2, o !== 64 && (t += String.fromCharCode(n)), c = Bn.indexOf(e.charAt(u++)), i = (o & 3) << 6 | c, c !== 64 && (t += String.fromCharCode(i));
  return t;
}
var ft = /* @__PURE__ */ (function() {
  return typeof Buffer < "u" && typeof process < "u" && typeof process.versions < "u" && !!process.versions.node;
})(), Rn = /* @__PURE__ */ (function() {
  if (typeof Buffer < "u") {
    var e = !Buffer.from;
    if (!e) try {
      Buffer.from("foo", "utf8");
    } catch {
      e = !0;
    }
    return e ? function(t, r) {
      return r ? new Buffer(t, r) : new Buffer(t);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
})();
function mi(e) {
  return ft ? Buffer.alloc ? Buffer.alloc(e) : new Buffer(e) : typeof Uint8Array < "u" ? new Uint8Array(e) : new Array(e);
}
function uy(e) {
  return ft ? Buffer.allocUnsafe ? Buffer.allocUnsafe(e) : new Buffer(e) : typeof Uint8Array < "u" ? new Uint8Array(e) : new Array(e);
}
var Gr = function(t) {
  return ft ? Rn(t, "binary") : t.split("").map(function(r) {
    return r.charCodeAt(0) & 255;
  });
};
function El(e) {
  if (typeof ArrayBuffer > "u") return Gr(e);
  for (var t = new ArrayBuffer(e.length), r = new Uint8Array(t), n = 0; n != e.length; ++n) r[n] = e.charCodeAt(n) & 255;
  return t;
}
function ss(e) {
  if (Array.isArray(e)) return e.map(function(n) {
    return String.fromCharCode(n);
  }).join("");
  for (var t = [], r = 0; r < e.length; ++r) t[r] = String.fromCharCode(e[r]);
  return t.join("");
}
function kO(e) {
  if (typeof Uint8Array > "u") throw new Error("Unsupported");
  return new Uint8Array(e);
}
var Wt = ft ? function(e) {
  return Buffer.concat(e.map(function(t) {
    return Buffer.isBuffer(t) ? t : Rn(t);
  }));
} : function(e) {
  if (typeof Uint8Array < "u") {
    var t = 0, r = 0;
    for (t = 0; t < e.length; ++t) r += e[t].length;
    var n = new Uint8Array(r), i = 0;
    for (t = 0, r = 0; t < e.length; r += i, ++t)
      if (i = e[t].length, e[t] instanceof Uint8Array) n.set(e[t], r);
      else {
        if (typeof e[t] == "string")
          throw "wtf";
        n.set(new Uint8Array(e[t]), r);
      }
    return n;
  }
  return [].concat.apply([], e.map(function(a) {
    return Array.isArray(a) ? a : [].slice.call(a);
  }));
};
function LO(e) {
  for (var t = [], r = 0, n = e.length + 250, i = mi(e.length + 255), a = 0; a < e.length; ++a) {
    var s = e.charCodeAt(a);
    if (s < 128) i[r++] = s;
    else if (s < 2048)
      i[r++] = 192 | s >> 6 & 31, i[r++] = 128 | s & 63;
    else if (s >= 55296 && s < 57344) {
      s = (s & 1023) + 64;
      var o = e.charCodeAt(++a) & 1023;
      i[r++] = 240 | s >> 8 & 7, i[r++] = 128 | s >> 2 & 63, i[r++] = 128 | o >> 6 & 15 | (s & 3) << 4, i[r++] = 128 | o & 63;
    } else
      i[r++] = 224 | s >> 12 & 15, i[r++] = 128 | s >> 6 & 63, i[r++] = 128 | s & 63;
    r > n && (t.push(i.slice(0, r)), r = 0, i = mi(65535), n = 65530);
  }
  return t.push(i.slice(0, r)), Wt(t);
}
var Ba = /\u0000/g, _c = /[\u0001-\u0006]/g;
function Gi(e) {
  for (var t = "", r = e.length - 1; r >= 0; ) t += e.charAt(r--);
  return t;
}
function Wr(e, t) {
  var r = "" + e;
  return r.length >= t ? r : Pt("0", t - r.length) + r;
}
function V0(e, t) {
  var r = "" + e;
  return r.length >= t ? r : Pt(" ", t - r.length) + r;
}
function Dc(e, t) {
  var r = "" + e;
  return r.length >= t ? r : r + Pt(" ", t - r.length);
}
function MO(e, t) {
  var r = "" + Math.round(e);
  return r.length >= t ? r : Pt("0", t - r.length) + r;
}
function UO(e, t) {
  var r = "" + e;
  return r.length >= t ? r : Pt("0", t - r.length) + r;
}
var fy = /* @__PURE__ */ Math.pow(2, 32);
function Mi(e, t) {
  if (e > fy || e < -fy) return MO(e, t);
  var r = Math.round(e);
  return UO(r, t);
}
function kc(e, t) {
  return t = t || 0, e.length >= 7 + t && (e.charCodeAt(t) | 32) === 103 && (e.charCodeAt(t + 1) | 32) === 101 && (e.charCodeAt(t + 2) | 32) === 110 && (e.charCodeAt(t + 3) | 32) === 101 && (e.charCodeAt(t + 4) | 32) === 114 && (e.charCodeAt(t + 5) | 32) === 97 && (e.charCodeAt(t + 6) | 32) === 108;
}
var dy = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
], Xd = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function qO(e) {
  return e || (e = {}), e[0] = "General", e[1] = "0", e[2] = "0.00", e[3] = "#,##0", e[4] = "#,##0.00", e[9] = "0%", e[10] = "0.00%", e[11] = "0.00E+00", e[12] = "# ?/?", e[13] = "# ??/??", e[14] = "m/d/yy", e[15] = "d-mmm-yy", e[16] = "d-mmm", e[17] = "mmm-yy", e[18] = "h:mm AM/PM", e[19] = "h:mm:ss AM/PM", e[20] = "h:mm", e[21] = "h:mm:ss", e[22] = "m/d/yy h:mm", e[37] = "#,##0 ;(#,##0)", e[38] = "#,##0 ;[Red](#,##0)", e[39] = "#,##0.00;(#,##0.00)", e[40] = "#,##0.00;[Red](#,##0.00)", e[45] = "mm:ss", e[46] = "[h]:mm:ss", e[47] = "mmss.0", e[48] = "##0.0E+0", e[49] = "@", e[56] = '"/ "hh""mm""ss" "', e;
}
var It = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"/ "hh""mm""ss" "'
}, hy = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
}, BO = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function Lc(e, t, r) {
  for (var n = e < 0 ? -1 : 1, i = e * n, a = 0, s = 1, o = 0, c = 1, u = 0, l = 0, d = Math.floor(i); u < t && (d = Math.floor(i), o = d * s + a, l = d * u + c, !(i - d < 5e-8)); )
    i = 1 / (i - d), a = s, s = o, c = u, u = l;
  if (l > t && (u > t ? (l = c, o = a) : (l = u, o = s)), !r) return [0, n * o, l];
  var f = Math.floor(n * o / l);
  return [f, n * o - f * l, l];
}
function yc(e, t, r) {
  if (e > 2958465 || e < 0) return null;
  var n = e | 0, i = Math.floor(86400 * (e - n)), a = 0, s = [], o = { D: n, T: i, u: 86400 * (e - n) - i, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(o.u) < 1e-6 && (o.u = 0), t && t.date1904 && (n += 1462), o.u > 0.9999 && (o.u = 0, ++i == 86400 && (o.T = i = 0, ++n, ++o.D)), n === 60)
    s = r ? [1317, 10, 29] : [1900, 2, 29], a = 3;
  else if (n === 0)
    s = r ? [1317, 8, 29] : [1900, 1, 0], a = 6;
  else {
    n > 60 && --n;
    var c = new Date(1900, 0, 1);
    c.setDate(c.getDate() + n - 1), s = [c.getFullYear(), c.getMonth() + 1, c.getDate()], a = c.getDay(), n < 60 && (a = (a + 6) % 7), r && (a = XO(c, s));
  }
  return o.y = s[0], o.m = s[1], o.d = s[2], o.S = i % 60, i = Math.floor(i / 60), o.M = i % 60, i = Math.floor(i / 60), o.H = i, o.q = a, o;
}
var ow = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0), jO = /* @__PURE__ */ ow.getTime(), VO = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
function cw(e, t) {
  var r = /* @__PURE__ */ e.getTime();
  return t ? r -= 1461 * 24 * 60 * 60 * 1e3 : e >= VO && (r += 1440 * 60 * 1e3), (r - (jO + (/* @__PURE__ */ e.getTimezoneOffset() - /* @__PURE__ */ ow.getTimezoneOffset()) * 6e4)) / (1440 * 60 * 1e3);
}
function H0(e) {
  return e.indexOf(".") == -1 ? e : e.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function HO(e) {
  return e.indexOf("E") == -1 ? e : e.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function GO(e) {
  var t = e < 0 ? 12 : 11, r = H0(e.toFixed(12));
  return r.length <= t || (r = e.toPrecision(10), r.length <= t) ? r : e.toExponential(5);
}
function zO(e) {
  var t = H0(e.toFixed(11));
  return t.length > (e < 0 ? 12 : 11) || t === "0" || t === "-0" ? e.toPrecision(6) : t;
}
function WO(e) {
  var t = Math.floor(Math.log(Math.abs(e)) * Math.LOG10E), r;
  return t >= -4 && t <= -1 ? r = e.toPrecision(10 + t) : Math.abs(t) <= 9 ? r = GO(e) : t === 10 ? r = e.toFixed(10).substr(0, 12) : r = zO(e), H0(HO(r.toUpperCase()));
}
function s0(e, t) {
  switch (typeof e) {
    case "string":
      return e;
    case "boolean":
      return e ? "TRUE" : "FALSE";
    case "number":
      return (e | 0) === e ? e.toString(10) : WO(e);
    case "undefined":
      return "";
    case "object":
      if (e == null) return "";
      if (e instanceof Date) return Vn(14, cw(e, t && t.date1904), t);
  }
  throw new Error("unsupported value in General format: " + e);
}
function XO(e, t) {
  t[0] -= 581;
  var r = e.getDay();
  return e < 60 && (r = (r + 6) % 7), r;
}
function KO(e, t, r, n) {
  var i = "", a = 0, s = 0, o = r.y, c, u = 0;
  switch (e) {
    case 98:
      o = r.y + 543;
    /* falls through */
    case 121:
      switch (t.length) {
        case 1:
        case 2:
          c = o % 100, u = 2;
          break;
        default:
          c = o % 1e4, u = 4;
          break;
      }
      break;
    case 109:
      switch (t.length) {
        case 1:
        case 2:
          c = r.m, u = t.length;
          break;
        case 3:
          return Xd[r.m - 1][1];
        case 5:
          return Xd[r.m - 1][0];
        default:
          return Xd[r.m - 1][2];
      }
      break;
    case 100:
      switch (t.length) {
        case 1:
        case 2:
          c = r.d, u = t.length;
          break;
        case 3:
          return dy[r.q][0];
        default:
          return dy[r.q][1];
      }
      break;
    case 104:
      switch (t.length) {
        case 1:
        case 2:
          c = 1 + (r.H + 11) % 12, u = t.length;
          break;
        default:
          throw "bad hour format: " + t;
      }
      break;
    case 72:
      switch (t.length) {
        case 1:
        case 2:
          c = r.H, u = t.length;
          break;
        default:
          throw "bad hour format: " + t;
      }
      break;
    case 77:
      switch (t.length) {
        case 1:
        case 2:
          c = r.M, u = t.length;
          break;
        default:
          throw "bad minute format: " + t;
      }
      break;
    case 115:
      if (t != "s" && t != "ss" && t != ".0" && t != ".00" && t != ".000") throw "bad second format: " + t;
      return r.u === 0 && (t == "s" || t == "ss") ? Wr(r.S, t.length) : (n >= 2 ? s = n === 3 ? 1e3 : 100 : s = n === 1 ? 10 : 1, a = Math.round(s * (r.S + r.u)), a >= 60 * s && (a = 0), t === "s" ? a === 0 ? "0" : "" + a / s : (i = Wr(a, 2 + n), t === "ss" ? i.substr(0, 2) : "." + i.substr(2, t.length - 1)));
    case 90:
      switch (t) {
        case "[h]":
        case "[hh]":
          c = r.D * 24 + r.H;
          break;
        case "[m]":
        case "[mm]":
          c = (r.D * 24 + r.H) * 60 + r.M;
          break;
        case "[s]":
        case "[ss]":
          c = ((r.D * 24 + r.H) * 60 + r.M) * 60 + Math.round(r.S + r.u);
          break;
        default:
          throw "bad abstime format: " + t;
      }
      u = t.length === 3 ? 1 : 2;
      break;
    case 101:
      c = o, u = 1;
      break;
  }
  var l = u > 0 ? Wr(c, u) : "";
  return l;
}
function jn(e) {
  var t = 3;
  if (e.length <= t) return e;
  for (var r = e.length % t, n = e.substr(0, r); r != e.length; r += t) n += (n.length > 0 ? "," : "") + e.substr(r, t);
  return n;
}
var lw = /%/g;
function YO(e, t, r) {
  var n = t.replace(lw, ""), i = t.length - n.length;
  return En(e, n, r * Math.pow(10, 2 * i)) + Pt("%", i);
}
function JO(e, t, r) {
  for (var n = t.length - 1; t.charCodeAt(n - 1) === 44; ) --n;
  return En(e, t.substr(0, n), r / Math.pow(10, 3 * (t.length - n)));
}
function uw(e, t) {
  var r, n = e.indexOf("E") - e.indexOf(".") - 1;
  if (e.match(/^#+0.0E\+0$/)) {
    if (t == 0) return "0.0E+0";
    if (t < 0) return "-" + uw(e, -t);
    var i = e.indexOf(".");
    i === -1 && (i = e.indexOf("E"));
    var a = Math.floor(Math.log(t) * Math.LOG10E) % i;
    if (a < 0 && (a += i), r = (t / Math.pow(10, a)).toPrecision(n + 1 + (i + a) % i), r.indexOf("e") === -1) {
      var s = Math.floor(Math.log(t) * Math.LOG10E);
      for (r.indexOf(".") === -1 ? r = r.charAt(0) + "." + r.substr(1) + "E+" + (s - r.length + a) : r += "E+" + (s - a); r.substr(0, 2) === "0."; )
        r = r.charAt(0) + r.substr(2, i) + "." + r.substr(2 + i), r = r.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      r = r.replace(/\+-/, "-");
    }
    r = r.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(o, c, u, l) {
      return c + u + l.substr(0, (i + a) % i) + "." + l.substr(a) + "E";
    });
  } else r = t.toExponential(n);
  return e.match(/E\+00$/) && r.match(/e[+-]\d$/) && (r = r.substr(0, r.length - 1) + "0" + r.charAt(r.length - 1)), e.match(/E\-/) && r.match(/e\+/) && (r = r.replace(/e\+/, "e")), r.replace("e", "E");
}
var fw = /# (\?+)( ?)\/( ?)(\d+)/;
function QO(e, t, r) {
  var n = parseInt(e[4], 10), i = Math.round(t * n), a = Math.floor(i / n), s = i - a * n, o = n;
  return r + (a === 0 ? "" : "" + a) + " " + (s === 0 ? Pt(" ", e[1].length + 1 + e[4].length) : V0(s, e[1].length) + e[2] + "/" + e[3] + Wr(o, e[4].length));
}
function ZO(e, t, r) {
  return r + (t === 0 ? "" : "" + t) + Pt(" ", e[1].length + 2 + e[4].length);
}
var dw = /^#*0*\.([0#]+)/, hw = /\).*[0#]/, pw = /\(###\) ###\\?-####/;
function lr(e) {
  for (var t = "", r, n = 0; n != e.length; ++n) switch (r = e.charCodeAt(n)) {
    case 35:
      break;
    case 63:
      t += " ";
      break;
    case 48:
      t += "0";
      break;
    default:
      t += String.fromCharCode(r);
  }
  return t;
}
function py(e, t) {
  var r = Math.pow(10, t);
  return "" + Math.round(e * r) / r;
}
function my(e, t) {
  var r = e - Math.floor(e), n = Math.pow(10, t);
  return t < ("" + Math.round(r * n)).length ? 0 : Math.round(r * n);
}
function eN(e, t) {
  return t < ("" + Math.round((e - Math.floor(e)) * Math.pow(10, t))).length ? 1 : 0;
}
function tN(e) {
  return e < 2147483647 && e > -2147483648 ? "" + (e >= 0 ? e | 0 : e - 1 | 0) : "" + Math.floor(e);
}
function Fr(e, t, r) {
  if (e.charCodeAt(0) === 40 && !t.match(hw)) {
    var n = t.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return r >= 0 ? Fr("n", n, r) : "(" + Fr("n", n, -r) + ")";
  }
  if (t.charCodeAt(t.length - 1) === 44) return JO(e, t, r);
  if (t.indexOf("%") !== -1) return YO(e, t, r);
  if (t.indexOf("E") !== -1) return uw(t, r);
  if (t.charCodeAt(0) === 36) return "$" + Fr(e, t.substr(t.charAt(1) == " " ? 2 : 1), r);
  var i, a, s, o, c = Math.abs(r), u = r < 0 ? "-" : "";
  if (t.match(/^00+$/)) return u + Mi(c, t.length);
  if (t.match(/^[#?]+$/))
    return i = Mi(r, 0), i === "0" && (i = ""), i.length > t.length ? i : lr(t.substr(0, t.length - i.length)) + i;
  if (a = t.match(fw)) return QO(a, c, u);
  if (t.match(/^#+0+$/)) return u + Mi(c, t.length - t.indexOf("0"));
  if (a = t.match(dw))
    return i = py(r, a[1].length).replace(/^([^\.]+)$/, "$1." + lr(a[1])).replace(/\.$/, "." + lr(a[1])).replace(/\.(\d*)$/, function(v, m) {
      return "." + m + Pt("0", lr(
        /*::(*/
        a[1]
      ).length - m.length);
    }), t.indexOf("0.") !== -1 ? i : i.replace(/^0\./, ".");
  if (t = t.replace(/^#+([0.])/, "$1"), a = t.match(/^(0*)\.(#*)$/))
    return u + py(c, a[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, a[1].length ? "0." : ".");
  if (a = t.match(/^#{1,3},##0(\.?)$/)) return u + jn(Mi(c, 0));
  if (a = t.match(/^#,##0\.([#0]*0)$/))
    return r < 0 ? "-" + Fr(e, t, -r) : jn("" + (Math.floor(r) + eN(r, a[1].length))) + "." + Wr(my(r, a[1].length), a[1].length);
  if (a = t.match(/^#,#*,#0/)) return Fr(e, t.replace(/^#,#*,/, ""), r);
  if (a = t.match(/^([0#]+)(\\?-([0#]+))+$/))
    return i = Gi(Fr(e, t.replace(/[\\-]/g, ""), r)), s = 0, Gi(Gi(t.replace(/\\/g, "")).replace(/[0#]/g, function(v) {
      return s < i.length ? i.charAt(s++) : v === "0" ? "0" : "";
    }));
  if (t.match(pw))
    return i = Fr(e, "##########", r), "(" + i.substr(0, 3) + ") " + i.substr(3, 3) + "-" + i.substr(6);
  var l = "";
  if (a = t.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return s = Math.min(
      /*::String(*/
      a[4].length,
      7
    ), o = Lc(c, Math.pow(10, s) - 1, !1), i = "" + u, l = En(
      "n",
      /*::String(*/
      a[1],
      o[1]
    ), l.charAt(l.length - 1) == " " && (l = l.substr(0, l.length - 1) + "0"), i += l + /*::String(*/
    a[2] + "/" + /*::String(*/
    a[3], l = Dc(o[2], s), l.length < a[4].length && (l = lr(a[4].substr(a[4].length - l.length)) + l), i += l, i;
  if (a = t.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return s = Math.min(Math.max(a[1].length, a[4].length), 7), o = Lc(c, Math.pow(10, s) - 1, !0), u + (o[0] || (o[1] ? "" : "0")) + " " + (o[1] ? V0(o[1], s) + a[2] + "/" + a[3] + Dc(o[2], s) : Pt(" ", 2 * s + 1 + a[2].length + a[3].length));
  if (a = t.match(/^[#0?]+$/))
    return i = Mi(r, 0), t.length <= i.length ? i : lr(t.substr(0, t.length - i.length)) + i;
  if (a = t.match(/^([#0?]+)\.([#0]+)$/)) {
    i = "" + r.toFixed(Math.min(a[2].length, 10)).replace(/([^0])0+$/, "$1"), s = i.indexOf(".");
    var d = t.indexOf(".") - s, f = t.length - i.length - d;
    return lr(t.substr(0, d) + i + t.substr(t.length - f));
  }
  if (a = t.match(/^00,000\.([#0]*0)$/))
    return s = my(r, a[1].length), r < 0 ? "-" + Fr(e, t, -r) : jn(tN(r)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(v) {
      return "00," + (v.length < 3 ? Wr(0, 3 - v.length) : "") + v;
    }) + "." + Wr(s, a[1].length);
  switch (t) {
    case "###,##0.00":
      return Fr(e, "#,##0.00", r);
    case "###,###":
    case "##,###":
    case "#,###":
      var p = jn(Mi(c, 0));
      return p !== "0" ? u + p : "";
    case "###,###.00":
      return Fr(e, "###,##0.00", r).replace(/^0\./, ".");
    case "#,###.00":
      return Fr(e, "#,##0.00", r).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + t + "|");
}
function rN(e, t, r) {
  for (var n = t.length - 1; t.charCodeAt(n - 1) === 44; ) --n;
  return En(e, t.substr(0, n), r / Math.pow(10, 3 * (t.length - n)));
}
function nN(e, t, r) {
  var n = t.replace(lw, ""), i = t.length - n.length;
  return En(e, n, r * Math.pow(10, 2 * i)) + Pt("%", i);
}
function mw(e, t) {
  var r, n = e.indexOf("E") - e.indexOf(".") - 1;
  if (e.match(/^#+0.0E\+0$/)) {
    if (t == 0) return "0.0E+0";
    if (t < 0) return "-" + mw(e, -t);
    var i = e.indexOf(".");
    i === -1 && (i = e.indexOf("E"));
    var a = Math.floor(Math.log(t) * Math.LOG10E) % i;
    if (a < 0 && (a += i), r = (t / Math.pow(10, a)).toPrecision(n + 1 + (i + a) % i), !r.match(/[Ee]/)) {
      var s = Math.floor(Math.log(t) * Math.LOG10E);
      r.indexOf(".") === -1 ? r = r.charAt(0) + "." + r.substr(1) + "E+" + (s - r.length + a) : r += "E+" + (s - a), r = r.replace(/\+-/, "-");
    }
    r = r.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(o, c, u, l) {
      return c + u + l.substr(0, (i + a) % i) + "." + l.substr(a) + "E";
    });
  } else r = t.toExponential(n);
  return e.match(/E\+00$/) && r.match(/e[+-]\d$/) && (r = r.substr(0, r.length - 1) + "0" + r.charAt(r.length - 1)), e.match(/E\-/) && r.match(/e\+/) && (r = r.replace(/e\+/, "e")), r.replace("e", "E");
}
function nn(e, t, r) {
  if (e.charCodeAt(0) === 40 && !t.match(hw)) {
    var n = t.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return r >= 0 ? nn("n", n, r) : "(" + nn("n", n, -r) + ")";
  }
  if (t.charCodeAt(t.length - 1) === 44) return rN(e, t, r);
  if (t.indexOf("%") !== -1) return nN(e, t, r);
  if (t.indexOf("E") !== -1) return mw(t, r);
  if (t.charCodeAt(0) === 36) return "$" + nn(e, t.substr(t.charAt(1) == " " ? 2 : 1), r);
  var i, a, s, o, c = Math.abs(r), u = r < 0 ? "-" : "";
  if (t.match(/^00+$/)) return u + Wr(c, t.length);
  if (t.match(/^[#?]+$/))
    return i = "" + r, r === 0 && (i = ""), i.length > t.length ? i : lr(t.substr(0, t.length - i.length)) + i;
  if (a = t.match(fw)) return ZO(a, c, u);
  if (t.match(/^#+0+$/)) return u + Wr(c, t.length - t.indexOf("0"));
  if (a = t.match(dw))
    return i = ("" + r).replace(/^([^\.]+)$/, "$1." + lr(a[1])).replace(/\.$/, "." + lr(a[1])), i = i.replace(/\.(\d*)$/, function(v, m) {
      return "." + m + Pt("0", lr(a[1]).length - m.length);
    }), t.indexOf("0.") !== -1 ? i : i.replace(/^0\./, ".");
  if (t = t.replace(/^#+([0.])/, "$1"), a = t.match(/^(0*)\.(#*)$/))
    return u + ("" + c).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, a[1].length ? "0." : ".");
  if (a = t.match(/^#{1,3},##0(\.?)$/)) return u + jn("" + c);
  if (a = t.match(/^#,##0\.([#0]*0)$/))
    return r < 0 ? "-" + nn(e, t, -r) : jn("" + r) + "." + Pt("0", a[1].length);
  if (a = t.match(/^#,#*,#0/)) return nn(e, t.replace(/^#,#*,/, ""), r);
  if (a = t.match(/^([0#]+)(\\?-([0#]+))+$/))
    return i = Gi(nn(e, t.replace(/[\\-]/g, ""), r)), s = 0, Gi(Gi(t.replace(/\\/g, "")).replace(/[0#]/g, function(v) {
      return s < i.length ? i.charAt(s++) : v === "0" ? "0" : "";
    }));
  if (t.match(pw))
    return i = nn(e, "##########", r), "(" + i.substr(0, 3) + ") " + i.substr(3, 3) + "-" + i.substr(6);
  var l = "";
  if (a = t.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return s = Math.min(
      /*::String(*/
      a[4].length,
      7
    ), o = Lc(c, Math.pow(10, s) - 1, !1), i = "" + u, l = En(
      "n",
      /*::String(*/
      a[1],
      o[1]
    ), l.charAt(l.length - 1) == " " && (l = l.substr(0, l.length - 1) + "0"), i += l + /*::String(*/
    a[2] + "/" + /*::String(*/
    a[3], l = Dc(o[2], s), l.length < a[4].length && (l = lr(a[4].substr(a[4].length - l.length)) + l), i += l, i;
  if (a = t.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return s = Math.min(Math.max(a[1].length, a[4].length), 7), o = Lc(c, Math.pow(10, s) - 1, !0), u + (o[0] || (o[1] ? "" : "0")) + " " + (o[1] ? V0(o[1], s) + a[2] + "/" + a[3] + Dc(o[2], s) : Pt(" ", 2 * s + 1 + a[2].length + a[3].length));
  if (a = t.match(/^[#0?]+$/))
    return i = "" + r, t.length <= i.length ? i : lr(t.substr(0, t.length - i.length)) + i;
  if (a = t.match(/^([#0]+)\.([#0]+)$/)) {
    i = "" + r.toFixed(Math.min(a[2].length, 10)).replace(/([^0])0+$/, "$1"), s = i.indexOf(".");
    var d = t.indexOf(".") - s, f = t.length - i.length - d;
    return lr(t.substr(0, d) + i + t.substr(t.length - f));
  }
  if (a = t.match(/^00,000\.([#0]*0)$/))
    return r < 0 ? "-" + nn(e, t, -r) : jn("" + r).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(v) {
      return "00," + (v.length < 3 ? Wr(0, 3 - v.length) : "") + v;
    }) + "." + Wr(0, a[1].length);
  switch (t) {
    case "###,###":
    case "##,###":
    case "#,###":
      var p = jn("" + c);
      return p !== "0" ? u + p : "";
    default:
      if (t.match(/\.[0#?]*$/)) return nn(e, t.slice(0, t.lastIndexOf(".")), r) + lr(t.slice(t.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + t + "|");
}
function En(e, t, r) {
  return (r | 0) === r ? nn(e, t, r) : Fr(e, t, r);
}
function iN(e) {
  for (var t = [], r = !1, n = 0, i = 0; n < e.length; ++n) switch (
    /*cc=*/
    e.charCodeAt(n)
  ) {
    case 34:
      r = !r;
      break;
    case 95:
    case 42:
    case 92:
      ++n;
      break;
    case 59:
      t[t.length] = e.substr(i, n - i), i = n + 1;
  }
  if (t[t.length] = e.substr(i), r === !0) throw new Error("Format |" + e + "| unterminated string ");
  return t;
}
var gw = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function vw(e) {
  for (var t = 0, r = "", n = ""; t < e.length; )
    switch (r = e.charAt(t)) {
      case "G":
        kc(e, t) && (t += 6), t++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          e.charCodeAt(++t) !== 34 && t < e.length;
        )
          ;
        ++t;
        break;
      case "\\":
        t += 2;
        break;
      case "_":
        t += 2;
        break;
      case "@":
        ++t;
        break;
      case "B":
      case "b":
        if (e.charAt(t + 1) === "1" || e.charAt(t + 1) === "2") return !0;
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return !0;
      case "A":
      case "a":
      case "":
        if (e.substr(t, 3).toUpperCase() === "A/P" || e.substr(t, 5).toUpperCase() === "AM/PM" || e.substr(t, 5).toUpperCase() === "/") return !0;
        ++t;
        break;
      case "[":
        for (n = r; e.charAt(t++) !== "]" && t < e.length; ) n += e.charAt(t);
        if (n.match(gw)) return !0;
        break;
      case ".":
      /* falls through */
      case "0":
      case "#":
        for (; t < e.length && ("0#?.,E+-%".indexOf(r = e.charAt(++t)) > -1 || r == "\\" && e.charAt(t + 1) == "-" && "0#".indexOf(e.charAt(t + 2)) > -1); )
          ;
        break;
      case "?":
        for (; e.charAt(++t) === r; )
          ;
        break;
      case "*":
        ++t, (e.charAt(t) == " " || e.charAt(t) == "*") && ++t;
        break;
      case "(":
      case ")":
        ++t;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (; t < e.length && "0123456789".indexOf(e.charAt(++t)) > -1; )
          ;
        break;
      case " ":
        ++t;
        break;
      default:
        ++t;
        break;
    }
  return !1;
}
function aN(e, t, r, n) {
  for (var i = [], a = "", s = 0, o = "", c = "t", u, l, d, f = "H"; s < e.length; )
    switch (o = e.charAt(s)) {
      case "G":
        if (!kc(e, s)) throw new Error("unrecognized character " + o + " in " + e);
        i[i.length] = { t: "G", v: "General" }, s += 7;
        break;
      case '"':
        for (a = ""; (d = e.charCodeAt(++s)) !== 34 && s < e.length; ) a += String.fromCharCode(d);
        i[i.length] = { t: "t", v: a }, ++s;
        break;
      case "\\":
        var p = e.charAt(++s), v = p === "(" || p === ")" ? p : "t";
        i[i.length] = { t: v, v: p }, ++s;
        break;
      case "_":
        i[i.length] = { t: "t", v: " " }, s += 2;
        break;
      case "@":
        i[i.length] = { t: "T", v: t }, ++s;
        break;
      case "B":
      case "b":
        if (e.charAt(s + 1) === "1" || e.charAt(s + 1) === "2") {
          if (u == null && (u = yc(t, r, e.charAt(s + 1) === "2"), u == null))
            return "";
          i[i.length] = { t: "X", v: e.substr(s, 2) }, c = o, s += 2;
          break;
        }
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        o = o.toLowerCase();
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (t < 0 || u == null && (u = yc(t, r), u == null))
          return "";
        for (a = o; ++s < e.length && e.charAt(s).toLowerCase() === o; ) a += o;
        o === "m" && c.toLowerCase() === "h" && (o = "M"), o === "h" && (o = f), i[i.length] = { t: o, v: a }, c = o;
        break;
      case "A":
      case "a":
      case "":
        var m = { t: o, v: o };
        if (u == null && (u = yc(t, r)), e.substr(s, 3).toUpperCase() === "A/P" ? (u != null && (m.v = u.H >= 12 ? "P" : "A"), m.t = "T", f = "h", s += 3) : e.substr(s, 5).toUpperCase() === "AM/PM" ? (u != null && (m.v = u.H >= 12 ? "PM" : "AM"), m.t = "T", s += 5, f = "h") : e.substr(s, 5).toUpperCase() === "/" ? (u != null && (m.v = u.H >= 12 ? "" : ""), m.t = "T", s += 5, f = "h") : (m.t = "t", ++s), u == null && m.t === "T") return "";
        i[i.length] = m, c = o;
        break;
      case "[":
        for (a = o; e.charAt(s++) !== "]" && s < e.length; ) a += e.charAt(s);
        if (a.slice(-1) !== "]") throw 'unterminated "[" block: |' + a + "|";
        if (a.match(gw)) {
          if (u == null && (u = yc(t, r), u == null))
            return "";
          i[i.length] = { t: "Z", v: a.toLowerCase() }, c = a.charAt(1);
        } else a.indexOf("$") > -1 && (a = (a.match(/\$([^-\[\]]*)/) || [])[1] || "$", vw(e) || (i[i.length] = { t: "t", v: a }));
        break;
      /* Numbers */
      case ".":
        if (u != null) {
          for (a = o; ++s < e.length && (o = e.charAt(s)) === "0"; ) a += o;
          i[i.length] = { t: "s", v: a };
          break;
        }
      /* falls through */
      case "0":
      case "#":
        for (a = o; ++s < e.length && "0#?.,E+-%".indexOf(o = e.charAt(s)) > -1; ) a += o;
        i[i.length] = { t: "n", v: a };
        break;
      case "?":
        for (a = o; e.charAt(++s) === o; ) a += o;
        i[i.length] = { t: o, v: a }, c = o;
        break;
      case "*":
        ++s, (e.charAt(s) == " " || e.charAt(s) == "*") && ++s;
        break;
      // **
      case "(":
      case ")":
        i[i.length] = { t: n === 1 ? "t" : o, v: o }, ++s;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (a = o; s < e.length && "0123456789".indexOf(e.charAt(++s)) > -1; ) a += e.charAt(s);
        i[i.length] = { t: "D", v: a };
        break;
      case " ":
        i[i.length] = { t: o, v: o }, ++s;
        break;
      case "$":
        i[i.length] = { t: "t", v: "$" }, ++s;
        break;
      default:
        if (",$-+/():!^&'~{}<>=acfijklopqrtuvwxzP".indexOf(o) === -1) throw new Error("unrecognized character " + o + " in " + e);
        i[i.length] = { t: "t", v: o }, ++s;
        break;
    }
  var h = 0, _ = 0, g;
  for (s = i.length - 1, c = "t"; s >= 0; --s)
    switch (i[s].t) {
      case "h":
      case "H":
        i[s].t = f, c = "h", h < 1 && (h = 1);
        break;
      case "s":
        (g = i[s].v.match(/\.0+$/)) && (_ = Math.max(_, g[0].length - 1)), h < 3 && (h = 3);
      /* falls through */
      case "d":
      case "y":
      case "M":
      case "e":
        c = i[s].t;
        break;
      case "m":
        c === "s" && (i[s].t = "M", h < 2 && (h = 2));
        break;
      case "X":
        break;
      case "Z":
        h < 1 && i[s].v.match(/[Hh]/) && (h = 1), h < 2 && i[s].v.match(/[Mm]/) && (h = 2), h < 3 && i[s].v.match(/[Ss]/) && (h = 3);
    }
  switch (h) {
    case 0:
      break;
    case 1:
      u.u >= 0.5 && (u.u = 0, ++u.S), u.S >= 60 && (u.S = 0, ++u.M), u.M >= 60 && (u.M = 0, ++u.H);
      break;
    case 2:
      u.u >= 0.5 && (u.u = 0, ++u.S), u.S >= 60 && (u.S = 0, ++u.M);
      break;
  }
  var y = "", x;
  for (s = 0; s < i.length; ++s)
    switch (i[s].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        i[s].v = "", i[s].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        i[s].v = KO(i[s].t.charCodeAt(0), i[s].v, u, _), i[s].t = "t";
        break;
      case "n":
      case "?":
        for (x = s + 1; i[x] != null && ((o = i[x].t) === "?" || o === "D" || (o === " " || o === "t") && i[x + 1] != null && (i[x + 1].t === "?" || i[x + 1].t === "t" && i[x + 1].v === "/") || i[s].t === "(" && (o === " " || o === "n" || o === ")") || o === "t" && (i[x].v === "/" || i[x].v === " " && i[x + 1] != null && i[x + 1].t == "?")); )
          i[s].v += i[x].v, i[x] = { v: "", t: ";" }, ++x;
        y += i[s].v, s = x - 1;
        break;
      case "G":
        i[s].t = "t", i[s].v = s0(t, r);
        break;
    }
  var S = "", w, E;
  if (y.length > 0) {
    y.charCodeAt(0) == 40 ? (w = t < 0 && y.charCodeAt(0) === 45 ? -t : t, E = En("n", y, w)) : (w = t < 0 && n > 1 ? -t : t, E = En("n", y, w), w < 0 && i[0] && i[0].t == "t" && (E = E.substr(1), i[0].v = "-" + i[0].v)), x = E.length - 1;
    var R = i.length;
    for (s = 0; s < i.length; ++s) if (i[s] != null && i[s].t != "t" && i[s].v.indexOf(".") > -1) {
      R = s;
      break;
    }
    var N = i.length;
    if (R === i.length && E.indexOf("E") === -1) {
      for (s = i.length - 1; s >= 0; --s)
        i[s] == null || "n?".indexOf(i[s].t) === -1 || (x >= i[s].v.length - 1 ? (x -= i[s].v.length, i[s].v = E.substr(x + 1, i[s].v.length)) : x < 0 ? i[s].v = "" : (i[s].v = E.substr(0, x + 1), x = -1), i[s].t = "t", N = s);
      x >= 0 && N < i.length && (i[N].v = E.substr(0, x + 1) + i[N].v);
    } else if (R !== i.length && E.indexOf("E") === -1) {
      for (x = E.indexOf(".") - 1, s = R; s >= 0; --s)
        if (!(i[s] == null || "n?".indexOf(i[s].t) === -1)) {
          for (l = i[s].v.indexOf(".") > -1 && s === R ? i[s].v.indexOf(".") - 1 : i[s].v.length - 1, S = i[s].v.substr(l + 1); l >= 0; --l)
            x >= 0 && (i[s].v.charAt(l) === "0" || i[s].v.charAt(l) === "#") && (S = E.charAt(x--) + S);
          i[s].v = S, i[s].t = "t", N = s;
        }
      for (x >= 0 && N < i.length && (i[N].v = E.substr(0, x + 1) + i[N].v), x = E.indexOf(".") + 1, s = R; s < i.length; ++s)
        if (!(i[s] == null || "n?(".indexOf(i[s].t) === -1 && s !== R)) {
          for (l = i[s].v.indexOf(".") > -1 && s === R ? i[s].v.indexOf(".") + 1 : 0, S = i[s].v.substr(0, l); l < i[s].v.length; ++l)
            x < E.length && (S += E.charAt(x++));
          i[s].v = S, i[s].t = "t", N = s;
        }
    }
  }
  for (s = 0; s < i.length; ++s) i[s] != null && "n?".indexOf(i[s].t) > -1 && (w = n > 1 && t < 0 && s > 0 && i[s - 1].v === "-" ? -t : t, i[s].v = En(i[s].t, i[s].v, w), i[s].t = "t");
  var B = "";
  for (s = 0; s !== i.length; ++s) i[s] != null && (B += i[s].v);
  return B;
}
var gy = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function vy(e, t) {
  if (t == null) return !1;
  var r = parseFloat(t[2]);
  switch (t[1]) {
    case "=":
      if (e == r) return !0;
      break;
    case ">":
      if (e > r) return !0;
      break;
    case "<":
      if (e < r) return !0;
      break;
    case "<>":
      if (e != r) return !0;
      break;
    case ">=":
      if (e >= r) return !0;
      break;
    case "<=":
      if (e <= r) return !0;
      break;
  }
  return !1;
}
function sN(e, t) {
  var r = iN(e), n = r.length, i = r[n - 1].indexOf("@");
  if (n < 4 && i > -1 && --n, r.length > 4) throw new Error("cannot find right format for |" + r.join("|") + "|");
  if (typeof t != "number") return [4, r.length === 4 || i > -1 ? r[r.length - 1] : "@"];
  switch (r.length) {
    case 1:
      r = i > -1 ? ["General", "General", "General", r[0]] : [r[0], r[0], r[0], "@"];
      break;
    case 2:
      r = i > -1 ? [r[0], r[0], r[0], r[1]] : [r[0], r[1], r[0], "@"];
      break;
    case 3:
      r = i > -1 ? [r[0], r[1], r[0], r[2]] : [r[0], r[1], r[2], "@"];
      break;
  }
  var a = t > 0 ? r[0] : t < 0 ? r[1] : r[2];
  if (r[0].indexOf("[") === -1 && r[1].indexOf("[") === -1) return [n, a];
  if (r[0].match(/\[[=<>]/) != null || r[1].match(/\[[=<>]/) != null) {
    var s = r[0].match(gy), o = r[1].match(gy);
    return vy(t, s) ? [n, r[0]] : vy(t, o) ? [n, r[1]] : [n, r[s != null && o != null ? 2 : 1]];
  }
  return [n, a];
}
function Vn(e, t, r) {
  r == null && (r = {});
  var n = "";
  switch (typeof e) {
    case "string":
      e == "m/d/yy" && r.dateNF ? n = r.dateNF : n = e;
      break;
    case "number":
      e == 14 && r.dateNF ? n = r.dateNF : n = (r.table != null ? r.table : It)[e], n == null && (n = r.table && r.table[hy[e]] || It[hy[e]]), n == null && (n = BO[e] || "General");
      break;
  }
  if (kc(n, 0)) return s0(t, r);
  t instanceof Date && (t = cw(t, r.date1904));
  var i = sN(n, t);
  if (kc(i[1])) return s0(t, r);
  if (t === !0) t = "TRUE";
  else if (t === !1) t = "FALSE";
  else if (t === "" || t == null) return "";
  return aN(i[1], t, r, i[0]);
}
function _w(e, t) {
  if (typeof t != "number") {
    t = +t || -1;
    for (var r = 0; r < 392; ++r) {
      if (It[r] == null) {
        t < 0 && (t = r);
        continue;
      }
      if (It[r] == e) {
        t = r;
        break;
      }
    }
    t < 0 && (t = 391);
  }
  return It[t] = e, t;
}
function wl(e) {
  for (var t = 0; t != 392; ++t)
    e[t] !== void 0 && _w(e[t], t);
}
function xl() {
  It = qO();
}
var yw = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function oN(e) {
  var t = typeof e == "number" ? It[e] : e;
  return t = t.replace(yw, "(\\d+)"), new RegExp("^" + t + "$");
}
function cN(e, t, r) {
  var n = -1, i = -1, a = -1, s = -1, o = -1, c = -1;
  (t.match(yw) || []).forEach(function(d, f) {
    var p = parseInt(r[f + 1], 10);
    switch (d.toLowerCase().charAt(0)) {
      case "y":
        n = p;
        break;
      case "d":
        a = p;
        break;
      case "h":
        s = p;
        break;
      case "s":
        c = p;
        break;
      case "m":
        s >= 0 ? o = p : i = p;
        break;
    }
  }), c >= 0 && o == -1 && i >= 0 && (o = i, i = -1);
  var u = ("" + (n >= 0 ? n : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (i >= 1 ? i : 1)).slice(-2) + "-" + ("00" + (a >= 1 ? a : 1)).slice(-2);
  u.length == 7 && (u = "0" + u), u.length == 8 && (u = "20" + u);
  var l = ("00" + (s >= 0 ? s : 0)).slice(-2) + ":" + ("00" + (o >= 0 ? o : 0)).slice(-2) + ":" + ("00" + (c >= 0 ? c : 0)).slice(-2);
  return s == -1 && o == -1 && c == -1 ? u : n == -1 && i == -1 && a == -1 ? l : u + "T" + l;
}
var lN = /* @__PURE__ */ (function() {
  var e = {};
  e.version = "1.2.0";
  function t() {
    for (var E = 0, R = new Array(256), N = 0; N != 256; ++N)
      E = N, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, R[N] = E;
    return typeof Int32Array < "u" ? new Int32Array(R) : R;
  }
  var r = t();
  function n(E) {
    var R = 0, N = 0, B = 0, F = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
    for (B = 0; B != 256; ++B) F[B] = E[B];
    for (B = 0; B != 256; ++B)
      for (N = E[B], R = 256 + B; R < 4096; R += 256) N = F[R] = N >>> 8 ^ E[N & 255];
    var U = [];
    for (B = 1; B != 16; ++B) U[B - 1] = typeof Int32Array < "u" ? F.subarray(B * 256, B * 256 + 256) : F.slice(B * 256, B * 256 + 256);
    return U;
  }
  var i = n(r), a = i[0], s = i[1], o = i[2], c = i[3], u = i[4], l = i[5], d = i[6], f = i[7], p = i[8], v = i[9], m = i[10], h = i[11], _ = i[12], g = i[13], y = i[14];
  function x(E, R) {
    for (var N = R ^ -1, B = 0, F = E.length; B < F; ) N = N >>> 8 ^ r[(N ^ E.charCodeAt(B++)) & 255];
    return ~N;
  }
  function S(E, R) {
    for (var N = R ^ -1, B = E.length - 15, F = 0; F < B; ) N = y[E[F++] ^ N & 255] ^ g[E[F++] ^ N >> 8 & 255] ^ _[E[F++] ^ N >> 16 & 255] ^ h[E[F++] ^ N >>> 24] ^ m[E[F++]] ^ v[E[F++]] ^ p[E[F++]] ^ f[E[F++]] ^ d[E[F++]] ^ l[E[F++]] ^ u[E[F++]] ^ c[E[F++]] ^ o[E[F++]] ^ s[E[F++]] ^ a[E[F++]] ^ r[E[F++]];
    for (B += 15; F < B; ) N = N >>> 8 ^ r[(N ^ E[F++]) & 255];
    return ~N;
  }
  function w(E, R) {
    for (var N = R ^ -1, B = 0, F = E.length, U = 0, G = 0; B < F; )
      U = E.charCodeAt(B++), U < 128 ? N = N >>> 8 ^ r[(N ^ U) & 255] : U < 2048 ? (N = N >>> 8 ^ r[(N ^ (192 | U >> 6 & 31)) & 255], N = N >>> 8 ^ r[(N ^ (128 | U & 63)) & 255]) : U >= 55296 && U < 57344 ? (U = (U & 1023) + 64, G = E.charCodeAt(B++) & 1023, N = N >>> 8 ^ r[(N ^ (240 | U >> 8 & 7)) & 255], N = N >>> 8 ^ r[(N ^ (128 | U >> 2 & 63)) & 255], N = N >>> 8 ^ r[(N ^ (128 | G >> 6 & 15 | (U & 3) << 4)) & 255], N = N >>> 8 ^ r[(N ^ (128 | G & 63)) & 255]) : (N = N >>> 8 ^ r[(N ^ (224 | U >> 12 & 15)) & 255], N = N >>> 8 ^ r[(N ^ (128 | U >> 6 & 63)) & 255], N = N >>> 8 ^ r[(N ^ (128 | U & 63)) & 255]);
    return ~N;
  }
  return e.table = r, e.bstr = x, e.buf = S, e.str = w, e;
})(), xt = /* @__PURE__ */ (function() {
  var t = {};
  t.version = "1.2.1";
  function r(j, Z) {
    for (var K = j.split("/"), Y = Z.split("/"), ee = 0, re = 0, ue = Math.min(K.length, Y.length); ee < ue; ++ee) {
      if (re = K[ee].length - Y[ee].length) return re;
      if (K[ee] != Y[ee]) return K[ee] < Y[ee] ? -1 : 1;
    }
    return K.length - Y.length;
  }
  function n(j) {
    if (j.charAt(j.length - 1) == "/") return j.slice(0, -1).indexOf("/") === -1 ? j : n(j.slice(0, -1));
    var Z = j.lastIndexOf("/");
    return Z === -1 ? j : j.slice(0, Z + 1);
  }
  function i(j) {
    if (j.charAt(j.length - 1) == "/") return i(j.slice(0, -1));
    var Z = j.lastIndexOf("/");
    return Z === -1 ? j : j.slice(Z + 1);
  }
  function a(j, Z) {
    typeof Z == "string" && (Z = new Date(Z));
    var K = Z.getHours();
    K = K << 6 | Z.getMinutes(), K = K << 5 | Z.getSeconds() >>> 1, j.write_shift(2, K);
    var Y = Z.getFullYear() - 1980;
    Y = Y << 4 | Z.getMonth() + 1, Y = Y << 5 | Z.getDate(), j.write_shift(2, Y);
  }
  function s(j) {
    var Z = j.read_shift(2) & 65535, K = j.read_shift(2) & 65535, Y = /* @__PURE__ */ new Date(), ee = K & 31;
    K >>>= 5;
    var re = K & 15;
    K >>>= 4, Y.setMilliseconds(0), Y.setFullYear(K + 1980), Y.setMonth(re - 1), Y.setDate(ee);
    var ue = Z & 31;
    Z >>>= 5;
    var ye = Z & 63;
    return Z >>>= 6, Y.setHours(Z), Y.setMinutes(ye), Y.setSeconds(ue << 1), Y;
  }
  function o(j) {
    $r(j, 0);
    for (var Z = (
      /*::(*/
      {}
    ), K = 0; j.l <= j.length - 4; ) {
      var Y = j.read_shift(2), ee = j.read_shift(2), re = j.l + ee, ue = {};
      switch (Y) {
        /* UNIX-style Timestamps */
        case 21589:
          K = j.read_shift(1), K & 1 && (ue.mtime = j.read_shift(4)), ee > 5 && (K & 2 && (ue.atime = j.read_shift(4)), K & 4 && (ue.ctime = j.read_shift(4))), ue.mtime && (ue.mt = new Date(ue.mtime * 1e3));
          break;
      }
      j.l = re, Z[Y] = ue;
    }
    return Z;
  }
  var c;
  function u() {
    return c || (c = {});
  }
  function l(j, Z) {
    if (j[0] == 80 && j[1] == 75) return Pe(j, Z);
    if ((j[0] | 32) == 109 && (j[1] | 32) == 105) return ln(j, Z);
    if (j.length < 512) throw new Error("CFB file size " + j.length + " < 512");
    var K = 3, Y = 512, ee = 0, re = 0, ue = 0, ye = 0, fe = 0, de = [], pe = (
      /*::(*/
      j.slice(0, 512)
    );
    $r(pe, 0);
    var Oe = d(pe);
    switch (K = Oe[0], K) {
      case 3:
        Y = 512;
        break;
      case 4:
        Y = 4096;
        break;
      case 0:
        if (Oe[1] == 0) return Pe(j, Z);
      /* falls through */
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + K);
    }
    Y !== 512 && (pe = /*::(*/
    j.slice(0, Y), $r(
      pe,
      28
      /* blob.l */
    ));
    var Ie = j.slice(0, Y);
    f(pe, K);
    var qe = pe.read_shift(4, "i");
    if (K === 3 && qe !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + qe);
    pe.l += 4, ue = pe.read_shift(4, "i"), pe.l += 4, pe.chk("00100000", "Mini Stream Cutoff Size: "), ye = pe.read_shift(4, "i"), ee = pe.read_shift(4, "i"), fe = pe.read_shift(4, "i"), re = pe.read_shift(4, "i");
    for (var Ce = -1, Le = 0; Le < 109 && (Ce = pe.read_shift(4, "i"), !(Ce < 0)); ++Le)
      de[Le] = Ce;
    var Ke = p(j, Y);
    h(fe, re, Ke, Y, de);
    var Tt = g(Ke, ue, de, Y);
    Tt[ue].name = "!Directory", ee > 0 && ye !== G && (Tt[ye].name = "!MiniFAT"), Tt[de[0]].name = "!FAT", Tt.fat_addrs = de, Tt.ssz = Y;
    var Et = {}, Lt = [], Kn = [], gr = [];
    y(ue, Tt, Ke, Lt, ee, Et, Kn, ye), v(Kn, gr, Lt), Lt.shift();
    var Yn = {
      FileIndex: Kn,
      FullPaths: gr
    };
    return Z && Z.raw && (Yn.raw = { header: Ie, sectors: Ke }), Yn;
  }
  function d(j) {
    if (j[j.l] == 80 && j[j.l + 1] == 75) return [0, 0];
    j.chk(M, "Header Signature: "), j.l += 16;
    var Z = j.read_shift(2, "u");
    return [j.read_shift(2, "u"), Z];
  }
  function f(j, Z) {
    var K = 9;
    switch (j.l += 2, K = j.read_shift(2)) {
      case 9:
        if (Z != 3) throw new Error("Sector Shift: Expected 9 saw " + K);
        break;
      case 12:
        if (Z != 4) throw new Error("Sector Shift: Expected 12 saw " + K);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + K);
    }
    j.chk("0600", "Mini Sector Shift: "), j.chk("000000000000", "Reserved: ");
  }
  function p(j, Z) {
    for (var K = Math.ceil(j.length / Z) - 1, Y = [], ee = 1; ee < K; ++ee) Y[ee - 1] = j.slice(ee * Z, (ee + 1) * Z);
    return Y[K - 1] = j.slice(K * Z), Y;
  }
  function v(j, Z, K) {
    for (var Y = 0, ee = 0, re = 0, ue = 0, ye = 0, fe = K.length, de = [], pe = []; Y < fe; ++Y)
      de[Y] = pe[Y] = Y, Z[Y] = K[Y];
    for (; ye < pe.length; ++ye)
      Y = pe[ye], ee = j[Y].L, re = j[Y].R, ue = j[Y].C, de[Y] === Y && (ee !== -1 && de[ee] !== ee && (de[Y] = de[ee]), re !== -1 && de[re] !== re && (de[Y] = de[re])), ue !== -1 && (de[ue] = Y), ee !== -1 && Y != de[Y] && (de[ee] = de[Y], pe.lastIndexOf(ee) < ye && pe.push(ee)), re !== -1 && Y != de[Y] && (de[re] = de[Y], pe.lastIndexOf(re) < ye && pe.push(re));
    for (Y = 1; Y < fe; ++Y) de[Y] === Y && (re !== -1 && de[re] !== re ? de[Y] = de[re] : ee !== -1 && de[ee] !== ee && (de[Y] = de[ee]));
    for (Y = 1; Y < fe; ++Y)
      if (j[Y].type !== 0) {
        if (ye = Y, ye != de[ye]) do
          ye = de[ye], Z[Y] = Z[ye] + "/" + Z[Y];
        while (ye !== 0 && de[ye] !== -1 && ye != de[ye]);
        de[Y] = -1;
      }
    for (Z[0] += "/", Y = 1; Y < fe; ++Y)
      j[Y].type !== 2 && (Z[Y] += "/");
  }
  function m(j, Z, K) {
    for (var Y = j.start, ee = j.size, re = [], ue = Y; K && ee > 0 && ue >= 0; )
      re.push(Z.slice(ue * U, ue * U + U)), ee -= U, ue = fi(K, ue * 4);
    return re.length === 0 ? ve(0) : Wt(re).slice(0, j.size);
  }
  function h(j, Z, K, Y, ee) {
    var re = G;
    if (j === G) {
      if (Z !== 0) throw new Error("DIFAT chain shorter than expected");
    } else if (j !== -1) {
      var ue = K[j], ye = (Y >>> 2) - 1;
      if (!ue) return;
      for (var fe = 0; fe < ye && (re = fi(ue, fe * 4)) !== G; ++fe)
        ee.push(re);
      h(fi(ue, Y - 4), Z - 1, K, Y, ee);
    }
  }
  function _(j, Z, K, Y, ee) {
    var re = [], ue = [];
    ee || (ee = []);
    var ye = Y - 1, fe = 0, de = 0;
    for (fe = Z; fe >= 0; ) {
      ee[fe] = !0, re[re.length] = fe, ue.push(j[fe]);
      var pe = K[Math.floor(fe * 4 / Y)];
      if (de = fe * 4 & ye, Y < 4 + de) throw new Error("FAT boundary crossed: " + fe + " 4 " + Y);
      if (!j[pe]) break;
      fe = fi(j[pe], de);
    }
    return { nodes: re, data: Ay([ue]) };
  }
  function g(j, Z, K, Y) {
    var ee = j.length, re = [], ue = [], ye = [], fe = [], de = Y - 1, pe = 0, Oe = 0, Ie = 0, qe = 0;
    for (pe = 0; pe < ee; ++pe)
      if (ye = [], Ie = pe + Z, Ie >= ee && (Ie -= ee), !ue[Ie]) {
        fe = [];
        var Ce = [];
        for (Oe = Ie; Oe >= 0; ) {
          Ce[Oe] = !0, ue[Oe] = !0, ye[ye.length] = Oe, fe.push(j[Oe]);
          var Le = K[Math.floor(Oe * 4 / Y)];
          if (qe = Oe * 4 & de, Y < 4 + qe) throw new Error("FAT boundary crossed: " + Oe + " 4 " + Y);
          if (!j[Le] || (Oe = fi(j[Le], qe), Ce[Oe])) break;
        }
        re[Ie] = { nodes: ye, data: Ay([fe]) };
      }
    return re;
  }
  function y(j, Z, K, Y, ee, re, ue, ye) {
    for (var fe = 0, de = Y.length ? 2 : 0, pe = Z[j].data, Oe = 0, Ie = 0, qe; Oe < pe.length; Oe += 128) {
      var Ce = (
        /*::(*/
        pe.slice(Oe, Oe + 128)
      );
      $r(Ce, 64), Ie = Ce.read_shift(2), qe = K0(Ce, 0, Ie - de), Y.push(qe);
      var Le = {
        name: qe,
        type: Ce.read_shift(1),
        color: Ce.read_shift(1),
        L: Ce.read_shift(4, "i"),
        R: Ce.read_shift(4, "i"),
        C: Ce.read_shift(4, "i"),
        clsid: Ce.read_shift(16),
        state: Ce.read_shift(4, "i"),
        start: 0,
        size: 0
      }, Ke = Ce.read_shift(2) + Ce.read_shift(2) + Ce.read_shift(2) + Ce.read_shift(2);
      Ke !== 0 && (Le.ct = x(Ce, Ce.l - 8));
      var Tt = Ce.read_shift(2) + Ce.read_shift(2) + Ce.read_shift(2) + Ce.read_shift(2);
      Tt !== 0 && (Le.mt = x(Ce, Ce.l - 8)), Le.start = Ce.read_shift(4, "i"), Le.size = Ce.read_shift(4, "i"), Le.size < 0 && Le.start < 0 && (Le.size = Le.type = 0, Le.start = G, Le.name = ""), Le.type === 5 ? (fe = Le.start, ee > 0 && fe !== G && (Z[fe].name = "!StreamData")) : Le.size >= 4096 ? (Le.storage = "fat", Z[Le.start] === void 0 && (Z[Le.start] = _(K, Le.start, Z.fat_addrs, Z.ssz)), Z[Le.start].name = Le.name, Le.content = Z[Le.start].data.slice(0, Le.size)) : (Le.storage = "minifat", Le.size < 0 ? Le.size = 0 : fe !== G && Le.start !== G && Z[fe] && (Le.content = m(Le, Z[fe].data, (Z[ye] || {}).data))), Le.content && $r(Le.content, 0), re[qe] = Le, ue.push(Le);
    }
  }
  function x(j, Z) {
    return new Date((Nr(j, Z + 4) / 1e7 * Math.pow(2, 32) + Nr(j, Z) / 1e7 - 11644473600) * 1e3);
  }
  function S(j, Z) {
    return u(), l(c.readFileSync(j), Z);
  }
  function w(j, Z) {
    var K = Z && Z.type;
    switch (K || ft && Buffer.isBuffer(j) && (K = "buffer"), K || "base64") {
      case "file":
        return S(j, Z);
      case "base64":
        return l(Gr(Sn(j)), Z);
      case "binary":
        return l(Gr(j), Z);
    }
    return l(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      j,
      Z
    );
  }
  function E(j, Z) {
    var K = Z || {}, Y = K.root || "Root Entry";
    if (j.FullPaths || (j.FullPaths = []), j.FileIndex || (j.FileIndex = []), j.FullPaths.length !== j.FileIndex.length) throw new Error("inconsistent CFB structure");
    j.FullPaths.length === 0 && (j.FullPaths[0] = Y + "/", j.FileIndex[0] = { name: Y, type: 5 }), K.CLSID && (j.FileIndex[0].clsid = K.CLSID), R(j);
  }
  function R(j) {
    var Z = "Sh33tJ5";
    if (!xt.find(j, "/" + Z)) {
      var K = ve(4);
      K[0] = 55, K[1] = K[3] = 50, K[2] = 54, j.FileIndex.push({ name: Z, type: 2, content: K, size: 4, L: 69, R: 69, C: 69 }), j.FullPaths.push(j.FullPaths[0] + Z), N(j);
    }
  }
  function N(j, Z) {
    E(j);
    for (var K = !1, Y = !1, ee = j.FullPaths.length - 1; ee >= 0; --ee) {
      var re = j.FileIndex[ee];
      switch (re.type) {
        case 0:
          Y ? K = !0 : (j.FileIndex.pop(), j.FullPaths.pop());
          break;
        case 1:
        case 2:
        case 5:
          Y = !0, isNaN(re.R * re.L * re.C) && (K = !0), re.R > -1 && re.L > -1 && re.R == re.L && (K = !0);
          break;
        default:
          K = !0;
          break;
      }
    }
    if (!(!K && !Z)) {
      var ue = new Date(1987, 1, 19), ye = 0, fe = Object.create ? /* @__PURE__ */ Object.create(null) : {}, de = [];
      for (ee = 0; ee < j.FullPaths.length; ++ee)
        fe[j.FullPaths[ee]] = !0, j.FileIndex[ee].type !== 0 && de.push([j.FullPaths[ee], j.FileIndex[ee]]);
      for (ee = 0; ee < de.length; ++ee) {
        var pe = n(de[ee][0]);
        Y = fe[pe], Y || (de.push([pe, {
          name: i(pe).replace("/", ""),
          type: 1,
          clsid: ie,
          ct: ue,
          mt: ue,
          content: null
        }]), fe[pe] = !0);
      }
      for (de.sort(function(qe, Ce) {
        return r(qe[0], Ce[0]);
      }), j.FullPaths = [], j.FileIndex = [], ee = 0; ee < de.length; ++ee)
        j.FullPaths[ee] = de[ee][0], j.FileIndex[ee] = de[ee][1];
      for (ee = 0; ee < de.length; ++ee) {
        var Oe = j.FileIndex[ee], Ie = j.FullPaths[ee];
        if (Oe.name = i(Ie).replace("/", ""), Oe.L = Oe.R = Oe.C = -(Oe.color = 1), Oe.size = Oe.content ? Oe.content.length : 0, Oe.start = 0, Oe.clsid = Oe.clsid || ie, ee === 0)
          Oe.C = de.length > 1 ? 1 : -1, Oe.size = 0, Oe.type = 5;
        else if (Ie.slice(-1) == "/") {
          for (ye = ee + 1; ye < de.length && n(j.FullPaths[ye]) != Ie; ++ye) ;
          for (Oe.C = ye >= de.length ? -1 : ye, ye = ee + 1; ye < de.length && n(j.FullPaths[ye]) != n(Ie); ++ye) ;
          Oe.R = ye >= de.length ? -1 : ye, Oe.type = 1;
        } else
          n(j.FullPaths[ee + 1] || "") == n(Ie) && (Oe.R = ee + 1), Oe.type = 2;
      }
    }
  }
  function B(j, Z) {
    var K = Z || {};
    if (K.fileType == "mad") return Ol(j, K);
    switch (N(j), K.fileType) {
      case "zip":
        return Ve(j, K);
    }
    var Y = (function(qe) {
      for (var Ce = 0, Le = 0, Ke = 0; Ke < qe.FileIndex.length; ++Ke) {
        var Tt = qe.FileIndex[Ke];
        if (Tt.content) {
          var Et = Tt.content.length;
          Et > 0 && (Et < 4096 ? Ce += Et + 63 >> 6 : Le += Et + 511 >> 9);
        }
      }
      for (var Lt = qe.FullPaths.length + 3 >> 2, Kn = Ce + 7 >> 3, gr = Ce + 127 >> 7, Yn = Kn + Le + Lt + gr, un = Yn + 127 >> 7, ca = un <= 109 ? 0 : Math.ceil((un - 109) / 127); Yn + un + ca + 127 >> 7 > un; ) ca = ++un <= 109 ? 0 : Math.ceil((un - 109) / 127);
      var Ur = [1, ca, un, gr, Lt, Le, Ce, 0];
      return qe.FileIndex[0].size = Ce << 6, Ur[7] = (qe.FileIndex[0].start = Ur[0] + Ur[1] + Ur[2] + Ur[3] + Ur[4] + Ur[5]) + (Ur[6] + 7 >> 3), Ur;
    })(j), ee = ve(Y[7] << 9), re = 0, ue = 0;
    {
      for (re = 0; re < 8; ++re) ee.write_shift(1, V[re]);
      for (re = 0; re < 8; ++re) ee.write_shift(2, 0);
      for (ee.write_shift(2, 62), ee.write_shift(2, 3), ee.write_shift(2, 65534), ee.write_shift(2, 9), ee.write_shift(2, 6), re = 0; re < 3; ++re) ee.write_shift(2, 0);
      for (ee.write_shift(4, 0), ee.write_shift(4, Y[2]), ee.write_shift(4, Y[0] + Y[1] + Y[2] + Y[3] - 1), ee.write_shift(4, 0), ee.write_shift(4, 4096), ee.write_shift(4, Y[3] ? Y[0] + Y[1] + Y[2] - 1 : G), ee.write_shift(4, Y[3]), ee.write_shift(-4, Y[1] ? Y[0] - 1 : G), ee.write_shift(4, Y[1]), re = 0; re < 109; ++re) ee.write_shift(-4, re < Y[2] ? Y[1] + re : -1);
    }
    if (Y[1])
      for (ue = 0; ue < Y[1]; ++ue) {
        for (; re < 236 + ue * 127; ++re) ee.write_shift(-4, re < Y[2] ? Y[1] + re : -1);
        ee.write_shift(-4, ue === Y[1] - 1 ? G : ue + 1);
      }
    var ye = function(qe) {
      for (ue += qe; re < ue - 1; ++re) ee.write_shift(-4, re + 1);
      qe && (++re, ee.write_shift(-4, G));
    };
    for (ue = re = 0, ue += Y[1]; re < ue; ++re) ee.write_shift(-4, W.DIFSECT);
    for (ue += Y[2]; re < ue; ++re) ee.write_shift(-4, W.FATSECT);
    ye(Y[3]), ye(Y[4]);
    for (var fe = 0, de = 0, pe = j.FileIndex[0]; fe < j.FileIndex.length; ++fe)
      pe = j.FileIndex[fe], pe.content && (de = pe.content.length, !(de < 4096) && (pe.start = ue, ye(de + 511 >> 9)));
    for (ye(Y[6] + 7 >> 3); ee.l & 511; ) ee.write_shift(-4, W.ENDOFCHAIN);
    for (ue = re = 0, fe = 0; fe < j.FileIndex.length; ++fe)
      pe = j.FileIndex[fe], pe.content && (de = pe.content.length, !(!de || de >= 4096) && (pe.start = ue, ye(de + 63 >> 6)));
    for (; ee.l & 511; ) ee.write_shift(-4, W.ENDOFCHAIN);
    for (re = 0; re < Y[4] << 2; ++re) {
      var Oe = j.FullPaths[re];
      if (!Oe || Oe.length === 0) {
        for (fe = 0; fe < 17; ++fe) ee.write_shift(4, 0);
        for (fe = 0; fe < 3; ++fe) ee.write_shift(4, -1);
        for (fe = 0; fe < 12; ++fe) ee.write_shift(4, 0);
        continue;
      }
      pe = j.FileIndex[re], re === 0 && (pe.start = pe.size ? pe.start - 1 : G);
      var Ie = re === 0 && K.root || pe.name;
      if (de = 2 * (Ie.length + 1), ee.write_shift(64, Ie, "utf16le"), ee.write_shift(2, de), ee.write_shift(1, pe.type), ee.write_shift(1, pe.color), ee.write_shift(-4, pe.L), ee.write_shift(-4, pe.R), ee.write_shift(-4, pe.C), pe.clsid) ee.write_shift(16, pe.clsid, "hex");
      else for (fe = 0; fe < 4; ++fe) ee.write_shift(4, 0);
      ee.write_shift(4, pe.state || 0), ee.write_shift(4, 0), ee.write_shift(4, 0), ee.write_shift(4, 0), ee.write_shift(4, 0), ee.write_shift(4, pe.start), ee.write_shift(4, pe.size), ee.write_shift(4, 0);
    }
    for (re = 1; re < j.FileIndex.length; ++re)
      if (pe = j.FileIndex[re], pe.size >= 4096)
        if (ee.l = pe.start + 1 << 9, ft && Buffer.isBuffer(pe.content))
          pe.content.copy(ee, ee.l, 0, pe.size), ee.l += pe.size + 511 & -512;
        else {
          for (fe = 0; fe < pe.size; ++fe) ee.write_shift(1, pe.content[fe]);
          for (; fe & 511; ++fe) ee.write_shift(1, 0);
        }
    for (re = 1; re < j.FileIndex.length; ++re)
      if (pe = j.FileIndex[re], pe.size > 0 && pe.size < 4096)
        if (ft && Buffer.isBuffer(pe.content))
          pe.content.copy(ee, ee.l, 0, pe.size), ee.l += pe.size + 63 & -64;
        else {
          for (fe = 0; fe < pe.size; ++fe) ee.write_shift(1, pe.content[fe]);
          for (; fe & 63; ++fe) ee.write_shift(1, 0);
        }
    if (ft)
      ee.l = ee.length;
    else
      for (; ee.l < ee.length; ) ee.write_shift(1, 0);
    return ee;
  }
  function F(j, Z) {
    var K = j.FullPaths.map(function(fe) {
      return fe.toUpperCase();
    }), Y = K.map(function(fe) {
      var de = fe.split("/");
      return de[de.length - (fe.slice(-1) == "/" ? 2 : 1)];
    }), ee = !1;
    Z.charCodeAt(0) === 47 ? (ee = !0, Z = K[0].slice(0, -1) + Z) : ee = Z.indexOf("/") !== -1;
    var re = Z.toUpperCase(), ue = ee === !0 ? K.indexOf(re) : Y.indexOf(re);
    if (ue !== -1) return j.FileIndex[ue];
    var ye = !re.match(_c);
    for (re = re.replace(Ba, ""), ye && (re = re.replace(_c, "!")), ue = 0; ue < K.length; ++ue)
      if ((ye ? K[ue].replace(_c, "!") : K[ue]).replace(Ba, "") == re || (ye ? Y[ue].replace(_c, "!") : Y[ue]).replace(Ba, "") == re) return j.FileIndex[ue];
    return null;
  }
  var U = 64, G = -2, M = "d0cf11e0a1b11ae1", V = [208, 207, 17, 224, 161, 177, 26, 225], ie = "00000000000000000000000000000000", W = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN: G,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE: M,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID: ie,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function ae(j, Z, K) {
    u();
    var Y = B(j, K);
    c.writeFileSync(Z, Y);
  }
  function se(j) {
    for (var Z = new Array(j.length), K = 0; K < j.length; ++K) Z[K] = String.fromCharCode(j[K]);
    return Z.join("");
  }
  function X(j, Z) {
    var K = B(j, Z);
    switch (Z && Z.type || "buffer") {
      case "file":
        return u(), c.writeFileSync(Z.filename, K), K;
      case "binary":
        return typeof K == "string" ? K : se(K);
      case "base64":
        return Xa(typeof K == "string" ? K : se(K));
      case "buffer":
        if (ft) return Buffer.isBuffer(K) ? K : Rn(K);
      /* falls through */
      case "array":
        return typeof K == "string" ? Gr(K) : K;
    }
    return K;
  }
  var k;
  function I(j) {
    try {
      var Z = j.InflateRaw, K = new Z();
      if (K._processChunk(new Uint8Array([3, 0]), K._finishFlushFlag), K.bytesRead) k = j;
      else throw new Error("zlib does not expose bytesRead");
    } catch (Y) {
      console.error("cannot use native zlib: " + (Y.message || Y));
    }
  }
  function C(j, Z) {
    if (!k) return Te(j, Z);
    var K = k.InflateRaw, Y = new K(), ee = Y._processChunk(j.slice(j.l), Y._finishFlushFlag);
    return j.l += Y.bytesRead, ee;
  }
  function T(j) {
    return k ? k.deflateRawSync(j) : Me(j);
  }
  var A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], L = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], b = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function P(j) {
    var Z = (j << 1 | j << 11) & 139536 | (j << 5 | j << 15) & 558144;
    return (Z >> 16 | Z >> 8 | Z) & 255;
  }
  for (var te = typeof Uint8Array < "u", H = te ? new Uint8Array(256) : [], D = 0; D < 256; ++D) H[D] = P(D);
  function q(j, Z) {
    var K = H[j & 255];
    return Z <= 8 ? K >>> 8 - Z : (K = K << 8 | H[j >> 8 & 255], Z <= 16 ? K >>> 16 - Z : (K = K << 8 | H[j >> 16 & 255], K >>> 24 - Z));
  }
  function J(j, Z) {
    var K = Z & 7, Y = Z >>> 3;
    return (j[Y] | (K <= 6 ? 0 : j[Y + 1] << 8)) >>> K & 3;
  }
  function ne(j, Z) {
    var K = Z & 7, Y = Z >>> 3;
    return (j[Y] | (K <= 5 ? 0 : j[Y + 1] << 8)) >>> K & 7;
  }
  function ce(j, Z) {
    var K = Z & 7, Y = Z >>> 3;
    return (j[Y] | (K <= 4 ? 0 : j[Y + 1] << 8)) >>> K & 15;
  }
  function Ee(j, Z) {
    var K = Z & 7, Y = Z >>> 3;
    return (j[Y] | (K <= 3 ? 0 : j[Y + 1] << 8)) >>> K & 31;
  }
  function ge(j, Z) {
    var K = Z & 7, Y = Z >>> 3;
    return (j[Y] | (K <= 1 ? 0 : j[Y + 1] << 8)) >>> K & 127;
  }
  function Ge(j, Z, K) {
    var Y = Z & 7, ee = Z >>> 3, re = (1 << K) - 1, ue = j[ee] >>> Y;
    return K < 8 - Y || (ue |= j[ee + 1] << 8 - Y, K < 16 - Y) || (ue |= j[ee + 2] << 16 - Y, K < 24 - Y) || (ue |= j[ee + 3] << 24 - Y), ue & re;
  }
  function ze(j, Z, K) {
    var Y = Z & 7, ee = Z >>> 3;
    return Y <= 5 ? j[ee] |= (K & 7) << Y : (j[ee] |= K << Y & 255, j[ee + 1] = (K & 7) >> 8 - Y), Z + 3;
  }
  function Xe(j, Z, K) {
    var Y = Z & 7, ee = Z >>> 3;
    return K = (K & 1) << Y, j[ee] |= K, Z + 1;
  }
  function He(j, Z, K) {
    var Y = Z & 7, ee = Z >>> 3;
    return K <<= Y, j[ee] |= K & 255, K >>>= 8, j[ee + 1] = K, Z + 8;
  }
  function O(j, Z, K) {
    var Y = Z & 7, ee = Z >>> 3;
    return K <<= Y, j[ee] |= K & 255, K >>>= 8, j[ee + 1] = K & 255, j[ee + 2] = K >>> 8, Z + 16;
  }
  function le(j, Z) {
    var K = j.length, Y = 2 * K > Z ? 2 * K : Z + 5, ee = 0;
    if (K >= Z) return j;
    if (ft) {
      var re = uy(Y);
      if (j.copy) j.copy(re);
      else for (; ee < j.length; ++ee) re[ee] = j[ee];
      return re;
    } else if (te) {
      var ue = new Uint8Array(Y);
      if (ue.set) ue.set(j);
      else for (; ee < K; ++ee) ue[ee] = j[ee];
      return ue;
    }
    return j.length = Y, j;
  }
  function me(j) {
    for (var Z = new Array(j), K = 0; K < j; ++K) Z[K] = 0;
    return Z;
  }
  function Ne(j, Z, K) {
    var Y = 1, ee = 0, re = 0, ue = 0, ye = 0, fe = j.length, de = te ? new Uint16Array(32) : me(32);
    for (re = 0; re < 32; ++re) de[re] = 0;
    for (re = fe; re < K; ++re) j[re] = 0;
    fe = j.length;
    var pe = te ? new Uint16Array(fe) : me(fe);
    for (re = 0; re < fe; ++re)
      de[ee = j[re]]++, Y < ee && (Y = ee), pe[re] = 0;
    for (de[0] = 0, re = 1; re <= Y; ++re) de[re + 16] = ye = ye + de[re - 1] << 1;
    for (re = 0; re < fe; ++re)
      ye = j[re], ye != 0 && (pe[re] = de[ye + 16]++);
    var Oe = 0;
    for (re = 0; re < fe; ++re)
      if (Oe = j[re], Oe != 0)
        for (ye = q(pe[re], Y) >> Y - Oe, ue = (1 << Y + 4 - Oe) - 1; ue >= 0; --ue)
          Z[ye | ue << Oe] = Oe & 15 | re << 4;
    return Y;
  }
  var _e = te ? new Uint16Array(512) : me(512), $e = te ? new Uint16Array(32) : me(32);
  if (!te) {
    for (var Ae = 0; Ae < 512; ++Ae) _e[Ae] = 0;
    for (Ae = 0; Ae < 32; ++Ae) $e[Ae] = 0;
  }
  (function() {
    for (var j = [], Z = 0; Z < 32; Z++) j.push(5);
    Ne(j, $e, 32);
    var K = [];
    for (Z = 0; Z <= 143; Z++) K.push(8);
    for (; Z <= 255; Z++) K.push(9);
    for (; Z <= 279; Z++) K.push(7);
    for (; Z <= 287; Z++) K.push(8);
    Ne(K, _e, 288);
  })();
  var De = /* @__PURE__ */ (function() {
    for (var Z = te ? new Uint8Array(32768) : [], K = 0, Y = 0; K < b.length - 1; ++K)
      for (; Y < b[K + 1]; ++Y) Z[Y] = K;
    for (; Y < 32768; ++Y) Z[Y] = 29;
    var ee = te ? new Uint8Array(259) : [];
    for (K = 0, Y = 0; K < L.length - 1; ++K)
      for (; Y < L[K + 1]; ++Y) ee[Y] = K;
    function re(ye, fe) {
      for (var de = 0; de < ye.length; ) {
        var pe = Math.min(65535, ye.length - de), Oe = de + pe == ye.length;
        for (fe.write_shift(1, +Oe), fe.write_shift(2, pe), fe.write_shift(2, ~pe & 65535); pe-- > 0; ) fe[fe.l++] = ye[de++];
      }
      return fe.l;
    }
    function ue(ye, fe) {
      for (var de = 0, pe = 0, Oe = te ? new Uint16Array(32768) : []; pe < ye.length; ) {
        var Ie = (
          /* data.length - boff; */
          Math.min(65535, ye.length - pe)
        );
        if (Ie < 10) {
          for (de = ze(fe, de, +(pe + Ie == ye.length)), de & 7 && (de += 8 - (de & 7)), fe.l = de / 8 | 0, fe.write_shift(2, Ie), fe.write_shift(2, ~Ie & 65535); Ie-- > 0; ) fe[fe.l++] = ye[pe++];
          de = fe.l * 8;
          continue;
        }
        de = ze(fe, de, +(pe + Ie == ye.length) + 2);
        for (var qe = 0; Ie-- > 0; ) {
          var Ce = ye[pe];
          qe = (qe << 5 ^ Ce) & 32767;
          var Le = -1, Ke = 0;
          if ((Le = Oe[qe]) && (Le |= pe & -32768, Le > pe && (Le -= 32768), Le < pe))
            for (; ye[Le + Ke] == ye[pe + Ke] && Ke < 250; ) ++Ke;
          if (Ke > 2) {
            Ce = ee[Ke], Ce <= 22 ? de = He(fe, de, H[Ce + 1] >> 1) - 1 : (He(fe, de, 3), de += 5, He(fe, de, H[Ce - 23] >> 5), de += 3);
            var Tt = Ce < 8 ? 0 : Ce - 4 >> 2;
            Tt > 0 && (O(fe, de, Ke - L[Ce]), de += Tt), Ce = Z[pe - Le], de = He(fe, de, H[Ce] >> 3), de -= 3;
            var Et = Ce < 4 ? 0 : Ce - 2 >> 1;
            Et > 0 && (O(fe, de, pe - Le - b[Ce]), de += Et);
            for (var Lt = 0; Lt < Ke; ++Lt)
              Oe[qe] = pe & 32767, qe = (qe << 5 ^ ye[pe]) & 32767, ++pe;
            Ie -= Ke - 1;
          } else
            Ce <= 143 ? Ce = Ce + 48 : de = Xe(fe, de, 1), de = He(fe, de, H[Ce]), Oe[qe] = pe & 32767, ++pe;
        }
        de = He(fe, de, 0) - 1;
      }
      return fe.l = (de + 7) / 8 | 0, fe.l;
    }
    return function(fe, de) {
      return fe.length < 8 ? re(fe, de) : ue(fe, de);
    };
  })();
  function Me(j) {
    var Z = ve(50 + Math.floor(j.length * 1.1)), K = De(j, Z);
    return Z.slice(0, K);
  }
  var it = te ? new Uint16Array(32768) : me(32768), at = te ? new Uint16Array(32768) : me(32768), je = te ? new Uint16Array(128) : me(128), z = 1, he = 1;
  function we(j, Z) {
    var K = Ee(j, Z) + 257;
    Z += 5;
    var Y = Ee(j, Z) + 1;
    Z += 5;
    var ee = ce(j, Z) + 4;
    Z += 4;
    for (var re = 0, ue = te ? new Uint8Array(19) : me(19), ye = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], fe = 1, de = te ? new Uint8Array(8) : me(8), pe = te ? new Uint8Array(8) : me(8), Oe = ue.length, Ie = 0; Ie < ee; ++Ie)
      ue[A[Ie]] = re = ne(j, Z), fe < re && (fe = re), de[re]++, Z += 3;
    var qe = 0;
    for (de[0] = 0, Ie = 1; Ie <= fe; ++Ie) pe[Ie] = qe = qe + de[Ie - 1] << 1;
    for (Ie = 0; Ie < Oe; ++Ie) (qe = ue[Ie]) != 0 && (ye[Ie] = pe[qe]++);
    var Ce = 0;
    for (Ie = 0; Ie < Oe; ++Ie)
      if (Ce = ue[Ie], Ce != 0) {
        qe = H[ye[Ie]] >> 8 - Ce;
        for (var Le = (1 << 7 - Ce) - 1; Le >= 0; --Le) je[qe | Le << Ce] = Ce & 7 | Ie << 3;
      }
    var Ke = [];
    for (fe = 1; Ke.length < K + Y; )
      switch (qe = je[ge(j, Z)], Z += qe & 7, qe >>>= 3) {
        case 16:
          for (re = 3 + J(j, Z), Z += 2, qe = Ke[Ke.length - 1]; re-- > 0; ) Ke.push(qe);
          break;
        case 17:
          for (re = 3 + ne(j, Z), Z += 3; re-- > 0; ) Ke.push(0);
          break;
        case 18:
          for (re = 11 + ge(j, Z), Z += 7; re-- > 0; ) Ke.push(0);
          break;
        default:
          Ke.push(qe), fe < qe && (fe = qe);
          break;
      }
    var Tt = Ke.slice(0, K), Et = Ke.slice(K);
    for (Ie = K; Ie < 286; ++Ie) Tt[Ie] = 0;
    for (Ie = Y; Ie < 30; ++Ie) Et[Ie] = 0;
    return z = Ne(Tt, it, 286), he = Ne(Et, at, 30), Z;
  }
  function xe(j, Z) {
    if (j[0] == 3 && !(j[1] & 3))
      return [mi(Z), 2];
    for (var K = 0, Y = 0, ee = uy(Z || 1 << 18), re = 0, ue = ee.length >>> 0, ye = 0, fe = 0; (Y & 1) == 0; ) {
      if (Y = ne(j, K), K += 3, Y >>> 1)
        Y >> 1 == 1 ? (ye = 9, fe = 5) : (K = we(j, K), ye = z, fe = he);
      else {
        K & 7 && (K += 8 - (K & 7));
        var de = j[K >>> 3] | j[(K >>> 3) + 1] << 8;
        if (K += 32, de > 0)
          for (!Z && ue < re + de && (ee = le(ee, re + de), ue = ee.length); de-- > 0; )
            ee[re++] = j[K >>> 3], K += 8;
        continue;
      }
      for (; ; ) {
        !Z && ue < re + 32767 && (ee = le(ee, re + 32767), ue = ee.length);
        var pe = Ge(j, K, ye), Oe = Y >>> 1 == 1 ? _e[pe] : it[pe];
        if (K += Oe & 15, Oe >>>= 4, (Oe >>> 8 & 255) === 0) ee[re++] = Oe;
        else {
          if (Oe == 256) break;
          Oe -= 257;
          var Ie = Oe < 8 ? 0 : Oe - 4 >> 2;
          Ie > 5 && (Ie = 0);
          var qe = re + L[Oe];
          Ie > 0 && (qe += Ge(j, K, Ie), K += Ie), pe = Ge(j, K, fe), Oe = Y >>> 1 == 1 ? $e[pe] : at[pe], K += Oe & 15, Oe >>>= 4;
          var Ce = Oe < 4 ? 0 : Oe - 2 >> 1, Le = b[Oe];
          for (Ce > 0 && (Le += Ge(j, K, Ce), K += Ce), !Z && ue < qe && (ee = le(ee, qe + 100), ue = ee.length); re < qe; )
            ee[re] = ee[re - Le], ++re;
        }
      }
    }
    return Z ? [ee, K + 7 >>> 3] : [ee.slice(0, re), K + 7 >>> 3];
  }
  function Te(j, Z) {
    var K = j.slice(j.l || 0), Y = xe(K, Z);
    return j.l += Y[1], Y[0];
  }
  function ke(j, Z) {
    if (j)
      typeof console < "u" && console.error(Z);
    else throw new Error(Z);
  }
  function Pe(j, Z) {
    var K = (
      /*::(*/
      j
    );
    $r(K, 0);
    var Y = [], ee = [], re = {
      FileIndex: Y,
      FullPaths: ee
    };
    E(re, { root: Z.root });
    for (var ue = K.length - 4; (K[ue] != 80 || K[ue + 1] != 75 || K[ue + 2] != 5 || K[ue + 3] != 6) && ue >= 0; ) --ue;
    K.l = ue + 4, K.l += 4;
    var ye = K.read_shift(2);
    K.l += 6;
    var fe = K.read_shift(4);
    for (K.l = fe, ue = 0; ue < ye; ++ue) {
      K.l += 20;
      var de = K.read_shift(4), pe = K.read_shift(4), Oe = K.read_shift(2), Ie = K.read_shift(2), qe = K.read_shift(2);
      K.l += 8;
      var Ce = K.read_shift(4), Le = o(
        /*::(*/
        K.slice(K.l + Oe, K.l + Oe + Ie)
        /*:: :any)*/
      );
      K.l += Oe + Ie + qe;
      var Ke = K.l;
      K.l = Ce + 4, Ue(K, de, pe, re, Le), K.l = Ke;
    }
    return re;
  }
  function Ue(j, Z, K, Y, ee) {
    j.l += 2;
    var re = j.read_shift(2), ue = j.read_shift(2), ye = s(j);
    if (re & 8257) throw new Error("Unsupported ZIP encryption");
    for (var fe = j.read_shift(4), de = j.read_shift(4), pe = j.read_shift(4), Oe = j.read_shift(2), Ie = j.read_shift(2), qe = "", Ce = 0; Ce < Oe; ++Ce) qe += String.fromCharCode(j[j.l++]);
    if (Ie) {
      var Le = o(
        /*::(*/
        j.slice(j.l, j.l + Ie)
        /*:: :any)*/
      );
      (Le[21589] || {}).mt && (ye = Le[21589].mt), ((ee || {})[21589] || {}).mt && (ye = ee[21589].mt);
    }
    j.l += Ie;
    var Ke = j.slice(j.l, j.l + de);
    switch (ue) {
      case 8:
        Ke = C(j, pe);
        break;
      case 0:
        break;
      // TODO: scan for magic number
      default:
        throw new Error("Unsupported ZIP Compression method " + ue);
    }
    var Tt = !1;
    re & 8 && (fe = j.read_shift(4), fe == 134695760 && (fe = j.read_shift(4), Tt = !0), de = j.read_shift(4), pe = j.read_shift(4)), de != Z && ke(Tt, "Bad compressed size: " + Z + " != " + de), pe != K && ke(Tt, "Bad uncompressed size: " + K + " != " + pe), sa(Y, qe, Ke, { unsafe: !0, mt: ye });
  }
  function Ve(j, Z) {
    var K = Z || {}, Y = [], ee = [], re = ve(1), ue = K.compression ? 8 : 0, ye = 0, fe = 0, de = 0, pe = 0, Oe = 0, Ie = j.FullPaths[0], qe = Ie, Ce = j.FileIndex[0], Le = [], Ke = 0;
    for (fe = 1; fe < j.FullPaths.length; ++fe)
      if (qe = j.FullPaths[fe].slice(Ie.length), Ce = j.FileIndex[fe], !(!Ce.size || !Ce.content || qe == "Sh33tJ5")) {
        var Tt = pe, Et = ve(qe.length);
        for (de = 0; de < qe.length; ++de) Et.write_shift(1, qe.charCodeAt(de) & 127);
        Et = Et.slice(0, Et.l), Le[Oe] = lN.buf(
          /*::((*/
          Ce.content,
          0
        );
        var Lt = Ce.content;
        ue == 8 && (Lt = T(Lt)), re = ve(30), re.write_shift(4, 67324752), re.write_shift(2, 20), re.write_shift(2, ye), re.write_shift(2, ue), Ce.mt ? a(re, Ce.mt) : re.write_shift(4, 0), re.write_shift(-4, Le[Oe]), re.write_shift(4, Lt.length), re.write_shift(
          4,
          /*::(*/
          Ce.content.length
        ), re.write_shift(2, Et.length), re.write_shift(2, 0), pe += re.length, Y.push(re), pe += Et.length, Y.push(Et), pe += Lt.length, Y.push(Lt), re = ve(46), re.write_shift(4, 33639248), re.write_shift(2, 0), re.write_shift(2, 20), re.write_shift(2, ye), re.write_shift(2, ue), re.write_shift(4, 0), re.write_shift(-4, Le[Oe]), re.write_shift(4, Lt.length), re.write_shift(
          4,
          /*::(*/
          Ce.content.length
        ), re.write_shift(2, Et.length), re.write_shift(2, 0), re.write_shift(2, 0), re.write_shift(2, 0), re.write_shift(2, 0), re.write_shift(4, 0), re.write_shift(4, Tt), Ke += re.l, ee.push(re), Ke += Et.length, ee.push(Et), ++Oe;
      }
    return re = ve(22), re.write_shift(4, 101010256), re.write_shift(2, 0), re.write_shift(2, 0), re.write_shift(2, Oe), re.write_shift(2, Oe), re.write_shift(4, Ke), re.write_shift(4, pe), re.write_shift(2, 0), Wt([Wt(Y), Wt(ee), re]);
  }
  var We = {
    htm: "text/html",
    xml: "text/xml",
    gif: "image/gif",
    jpg: "image/jpeg",
    png: "image/png",
    mso: "application/x-mso",
    thmx: "application/vnd.ms-officetheme",
    sh33tj5: "application/octet-stream"
  };
  function yt(j, Z) {
    if (j.ctype) return j.ctype;
    var K = j.name || "", Y = K.match(/\.([^\.]+)$/);
    return Y && We[Y[1]] || Z && (Y = (K = Z).match(/[\.\\]([^\.\\])+$/), Y && We[Y[1]]) ? We[Y[1]] : "application/octet-stream";
  }
  function Rt(j) {
    for (var Z = Xa(j), K = [], Y = 0; Y < Z.length; Y += 76) K.push(Z.slice(Y, Y + 76));
    return K.join(`\r
`) + `\r
`;
  }
  function ot(j) {
    var Z = j.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(de) {
      var pe = de.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (pe.length == 1 ? "0" + pe : pe);
    });
    Z = Z.replace(/ $/mg, "=20").replace(/\t$/mg, "=09"), Z.charAt(0) == `
` && (Z = "=0D" + Z.slice(1)), Z = Z.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, `
=0A`).replace(/([^\r\n])\n/mg, "$1=0A");
    for (var K = [], Y = Z.split(`\r
`), ee = 0; ee < Y.length; ++ee) {
      var re = Y[ee];
      if (re.length == 0) {
        K.push("");
        continue;
      }
      for (var ue = 0; ue < re.length; ) {
        var ye = 76, fe = re.slice(ue, ue + ye);
        fe.charAt(ye - 1) == "=" ? ye-- : fe.charAt(ye - 2) == "=" ? ye -= 2 : fe.charAt(ye - 3) == "=" && (ye -= 3), fe = re.slice(ue, ue + ye), ue += ye, ue < re.length && (fe += "="), K.push(fe);
      }
    }
    return K.join(`\r
`);
  }
  function $n(j) {
    for (var Z = [], K = 0; K < j.length; ++K) {
      for (var Y = j[K]; K <= j.length && Y.charAt(Y.length - 1) == "="; ) Y = Y.slice(0, Y.length - 1) + j[++K];
      Z.push(Y);
    }
    for (var ee = 0; ee < Z.length; ++ee) Z[ee] = Z[ee].replace(/[=][0-9A-Fa-f]{2}/g, function(re) {
      return String.fromCharCode(parseInt(re.slice(1), 16));
    });
    return Gr(Z.join(`\r
`));
  }
  function wr(j, Z, K) {
    for (var Y = "", ee = "", re = "", ue, ye = 0; ye < 10; ++ye) {
      var fe = Z[ye];
      if (!fe || fe.match(/^\s*$/)) break;
      var de = fe.match(/^(.*?):\s*([^\s].*)$/);
      if (de) switch (de[1].toLowerCase()) {
        case "content-location":
          Y = de[2].trim();
          break;
        case "content-type":
          re = de[2].trim();
          break;
        case "content-transfer-encoding":
          ee = de[2].trim();
          break;
      }
    }
    switch (++ye, ee.toLowerCase()) {
      case "base64":
        ue = Gr(Sn(Z.slice(ye).join("")));
        break;
      case "quoted-printable":
        ue = $n(Z.slice(ye));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + ee);
    }
    var pe = sa(j, Y.slice(K.length), ue, { unsafe: !0 });
    re && (pe.ctype = re);
  }
  function ln(j, Z) {
    if (se(j.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
    var K = Z && Z.root || "", Y = (ft && Buffer.isBuffer(j) ? j.toString("binary") : se(j)).split(`\r
`), ee = 0, re = "";
    for (ee = 0; ee < Y.length; ++ee)
      if (re = Y[ee], !!/^Content-Location:/i.test(re) && (re = re.slice(re.indexOf("file")), K || (K = re.slice(0, re.lastIndexOf("/") + 1)), re.slice(0, K.length) != K))
        for (; K.length > 0 && (K = K.slice(0, K.length - 1), K = K.slice(0, K.lastIndexOf("/") + 1), re.slice(0, K.length) != K); )
          ;
    var ue = (Y[1] || "").match(/boundary="(.*?)"/);
    if (!ue) throw new Error("MAD cannot find boundary");
    var ye = "--" + (ue[1] || ""), fe = [], de = [], pe = {
      FileIndex: fe,
      FullPaths: de
    };
    E(pe);
    var Oe, Ie = 0;
    for (ee = 0; ee < Y.length; ++ee) {
      var qe = Y[ee];
      qe !== ye && qe !== ye + "--" || (Ie++ && wr(pe, Y.slice(Oe, ee), K), Oe = ee);
    }
    return pe;
  }
  function Ol(j, Z) {
    var K = Z || {}, Y = K.boundary || "SheetJS";
    Y = "------=" + Y;
    for (var ee = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + Y.slice(2) + '"',
      "",
      "",
      ""
    ], re = j.FullPaths[0], ue = re, ye = j.FileIndex[0], fe = 1; fe < j.FullPaths.length; ++fe)
      if (ue = j.FullPaths[fe].slice(re.length), ye = j.FileIndex[fe], !(!ye.size || !ye.content || ue == "Sh33tJ5")) {
        ue = ue.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(Ke) {
          return "_x" + Ke.charCodeAt(0).toString(16) + "_";
        }).replace(/[\u0080-\uFFFF]/g, function(Ke) {
          return "_u" + Ke.charCodeAt(0).toString(16) + "_";
        });
        for (var de = ye.content, pe = ft && Buffer.isBuffer(de) ? de.toString("binary") : se(de), Oe = 0, Ie = Math.min(1024, pe.length), qe = 0, Ce = 0; Ce <= Ie; ++Ce) (qe = pe.charCodeAt(Ce)) >= 32 && qe < 128 && ++Oe;
        var Le = Oe >= Ie * 4 / 5;
        ee.push(Y), ee.push("Content-Location: " + (K.root || "file:///C:/SheetJS/") + ue), ee.push("Content-Transfer-Encoding: " + (Le ? "quoted-printable" : "base64")), ee.push("Content-Type: " + yt(ye, ue)), ee.push(""), ee.push(Le ? ot(pe) : Rt(pe));
      }
    return ee.push(Y + `--\r
`), ee.join(`\r
`);
  }
  function Nl(j) {
    var Z = {};
    return E(Z, j), Z;
  }
  function sa(j, Z, K, Y) {
    var ee = Y && Y.unsafe;
    ee || E(j);
    var re = !ee && xt.find(j, Z);
    if (!re) {
      var ue = j.FullPaths[0];
      Z.slice(0, ue.length) == ue ? ue = Z : (ue.slice(-1) != "/" && (ue += "/"), ue = (ue + Z).replace("//", "/")), re = { name: i(Z), type: 2 }, j.FileIndex.push(re), j.FullPaths.push(ue), ee || xt.utils.cfb_gc(j);
    }
    return re.content = K, re.size = K ? K.length : 0, Y && (Y.CLSID && (re.clsid = Y.CLSID), Y.mt && (re.mt = Y.mt), Y.ct && (re.ct = Y.ct)), re;
  }
  function Pl(j, Z) {
    E(j);
    var K = xt.find(j, Z);
    if (K) {
      for (var Y = 0; Y < j.FileIndex.length; ++Y) if (j.FileIndex[Y] == K)
        return j.FileIndex.splice(Y, 1), j.FullPaths.splice(Y, 1), !0;
    }
    return !1;
  }
  function ds(j, Z, K) {
    E(j);
    var Y = xt.find(j, Z);
    if (Y) {
      for (var ee = 0; ee < j.FileIndex.length; ++ee) if (j.FileIndex[ee] == Y)
        return j.FileIndex[ee].name = i(K), j.FullPaths[ee] = K, !0;
    }
    return !1;
  }
  function oa(j) {
    N(j, !0);
  }
  return t.find = F, t.read = w, t.parse = l, t.write = X, t.writeFile = ae, t.utils = {
    cfb_new: Nl,
    cfb_add: sa,
    cfb_del: Pl,
    cfb_mov: ds,
    cfb_gc: oa,
    ReadShift: Va,
    CheckField: Lw,
    prep_blob: $r,
    bconcat: Wt,
    use_zlib: I,
    _deflateRaw: Me,
    _inflateRaw: Te,
    consts: W
  }, t;
})();
function uN(e) {
  return typeof e == "string" ? El(e) : Array.isArray(e) ? kO(e) : e;
}
function os(e, t, r) {
  if (typeof Deno < "u") {
    if (r && typeof t == "string") switch (r) {
      case "utf8":
        t = new TextEncoder(r).encode(t);
        break;
      case "binary":
        t = El(t);
        break;
      /* TODO: binary equivalent */
      default:
        throw new Error("Unsupported encoding " + r);
    }
    return Deno.writeFileSync(e, t);
  }
  var n = r == "utf8" ? Ya(t) : t;
  if (typeof IE_SaveFile < "u") return IE_SaveFile(n, e);
  if (typeof Blob < "u") {
    var i = new Blob([uN(n)], { type: "application/octet-stream" });
    if (typeof navigator < "u" && navigator.msSaveBlob) return navigator.msSaveBlob(i, e);
    if (typeof saveAs < "u") return saveAs(i, e);
    if (typeof URL < "u" && typeof document < "u" && document.createElement && URL.createObjectURL) {
      var a = URL.createObjectURL(i);
      if (typeof chrome == "object" && typeof (chrome.downloads || {}).download == "function")
        return URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
          URL.revokeObjectURL(a);
        }, 6e4), chrome.downloads.download({ url: a, filename: e, saveAs: !0 });
      var s = document.createElement("a");
      if (s.download != null)
        return s.download = e, s.href = a, document.body.appendChild(s), s.click(), document.body.removeChild(s), URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
          URL.revokeObjectURL(a);
        }, 6e4), a;
    }
  }
  if (typeof $ < "u" && typeof File < "u" && typeof Folder < "u") try {
    var o = File(e);
    return o.open("w"), o.encoding = "binary", Array.isArray(t) && (t = ss(t)), o.write(t), o.close(), t;
  } catch (c) {
    if (!c.message || !c.message.match(/onstruct/)) throw c;
  }
  throw new Error("cannot save file " + e);
}
function Yt(e) {
  for (var t = Object.keys(e), r = [], n = 0; n < t.length; ++n) Object.prototype.hasOwnProperty.call(e, t[n]) && r.push(t[n]);
  return r;
}
function _y(e, t) {
  for (var r = [], n = Yt(e), i = 0; i !== n.length; ++i) r[e[n[i]][t]] == null && (r[e[n[i]][t]] = n[i]);
  return r;
}
function G0(e) {
  for (var t = [], r = Yt(e), n = 0; n !== r.length; ++n) t[e[r[n]]] = r[n];
  return t;
}
function Tl(e) {
  for (var t = [], r = Yt(e), n = 0; n !== r.length; ++n) t[e[r[n]]] = parseInt(r[n], 10);
  return t;
}
function fN(e) {
  for (var t = [], r = Yt(e), n = 0; n !== r.length; ++n)
    t[e[r[n]]] == null && (t[e[r[n]]] = []), t[e[r[n]]].push(r[n]);
  return t;
}
var Mc = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
function _r(e, t) {
  var r = /* @__PURE__ */ e.getTime(), n = /* @__PURE__ */ Mc.getTime() + (/* @__PURE__ */ e.getTimezoneOffset() - /* @__PURE__ */ Mc.getTimezoneOffset()) * 6e4;
  return (r - n) / (1440 * 60 * 1e3);
}
var Ew = /* @__PURE__ */ new Date(), dN = /* @__PURE__ */ Mc.getTime() + (/* @__PURE__ */ Ew.getTimezoneOffset() - /* @__PURE__ */ Mc.getTimezoneOffset()) * 6e4, yy = /* @__PURE__ */ Ew.getTimezoneOffset();
function ww(e) {
  var t = /* @__PURE__ */ new Date();
  return t.setTime(e * 24 * 60 * 60 * 1e3 + dN), t.getTimezoneOffset() !== yy && t.setTime(t.getTime() + (t.getTimezoneOffset() - yy) * 6e4), t;
}
var Ey = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z"), xw = /* @__PURE__ */ isNaN(/* @__PURE__ */ Ey.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : Ey, hN = /* @__PURE__ */ xw.getFullYear() == 2017;
function dr(e, t) {
  var r = new Date(e);
  if (hN)
    return t > 0 ? r.setTime(r.getTime() + r.getTimezoneOffset() * 60 * 1e3) : t < 0 && r.setTime(r.getTime() - r.getTimezoneOffset() * 60 * 1e3), r;
  if (e instanceof Date) return e;
  if (xw.getFullYear() == 1917 && !isNaN(r.getFullYear())) {
    var n = r.getFullYear();
    return e.indexOf("" + n) > -1 || r.setFullYear(r.getFullYear() + 100), r;
  }
  var i = e.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"], a = new Date(+i[0], +i[1] - 1, +i[2], +i[3] || 0, +i[4] || 0, +i[5] || 0);
  return e.indexOf("Z") > -1 && (a = new Date(a.getTime() - a.getTimezoneOffset() * 60 * 1e3)), a;
}
function Sl(e, t) {
  if (ft && Buffer.isBuffer(e))
    return e.toString("binary");
  if (typeof TextDecoder < "u") try {
    var r = {
      "": "",
      "": "",
      : "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      : "",
      "": "",
      : "",
      : "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      : "",
      "": "",
      : "",
      : "",
      : ""
    };
    return Array.isArray(e) && (e = new Uint8Array(e)), new TextDecoder("latin1").decode(e).replace(/[]/g, function(a) {
      return r[a] || a;
    });
  } catch {
  }
  for (var n = [], i = 0; i != e.length; ++i) n.push(String.fromCharCode(e[i]));
  return n.join("");
}
function yr(e) {
  if (typeof JSON < "u" && !Array.isArray(e)) return JSON.parse(JSON.stringify(e));
  if (typeof e != "object" || e == null) return e;
  if (e instanceof Date) return new Date(e.getTime());
  var t = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = yr(e[r]));
  return t;
}
function Pt(e, t) {
  for (var r = ""; r.length < t; ) r += e;
  return r;
}
function wn(e) {
  var t = Number(e);
  if (!isNaN(t)) return isFinite(t) ? t : NaN;
  if (!/\d/.test(e)) return t;
  var r = 1, n = e.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    return r *= 100, "";
  });
  return !isNaN(t = Number(n)) || (n = n.replace(/[(](.*)[)]/, function(i, a) {
    return r = -r, a;
  }), !isNaN(t = Number(n))) ? t / r : t;
}
var pN = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function Ka(e) {
  var t = new Date(e), r = /* @__PURE__ */ new Date(NaN), n = t.getYear(), i = t.getMonth(), a = t.getDate();
  if (isNaN(a)) return r;
  var s = e.toLowerCase();
  if (s.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    if (s = s.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, ""), s.length > 3 && pN.indexOf(s) == -1) return r;
  } else if (s.match(/[a-z]/)) return r;
  return n < 0 || n > 8099 ? r : (i > 0 || a > 1) && n != 101 ? t : e.match(/[^-0-9:,\/\\]/) ? r : t;
}
function et(e, t, r) {
  if (e.FullPaths) {
    if (typeof r == "string") {
      var n;
      return ft ? n = Rn(r) : n = LO(r), xt.utils.cfb_add(e, t, n);
    }
    xt.utils.cfb_add(e, t, r);
  } else e.file(t, r);
}
function z0() {
  return xt.utils.cfb_new();
}
var Dt = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r
`, mN = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
}, W0 = /* @__PURE__ */ G0(mN), X0 = /[&<>'"]/g, gN = /[\u0000-\u0008\u000b-\u001f]/g;
function gt(e) {
  var t = e + "";
  return t.replace(X0, function(r) {
    return W0[r];
  }).replace(gN, function(r) {
    return "_x" + ("000" + r.charCodeAt(0).toString(16)).slice(-4) + "_";
  });
}
function wy(e) {
  return gt(e).replace(/ /g, "_x0020_");
}
var Tw = /[\u0000-\u001f]/g;
function vN(e) {
  var t = e + "";
  return t.replace(X0, function(r) {
    return W0[r];
  }).replace(/\n/g, "<br/>").replace(Tw, function(r) {
    return "&#x" + ("000" + r.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
function _N(e) {
  var t = e + "";
  return t.replace(X0, function(r) {
    return W0[r];
  }).replace(Tw, function(r) {
    return "&#x" + r.charCodeAt(0).toString(16).toUpperCase() + ";";
  });
}
function yN(e) {
  return e.replace(/(\r\n|[\r\n])/g, "&#10;");
}
function EN(e) {
  switch (e) {
    case 1:
    case !0:
    case "1":
    case "true":
    case "TRUE":
      return !0;
    /* case '0': case 'false': case 'FALSE':*/
    default:
      return !1;
  }
}
function Kd(e) {
  for (var t = "", r = 0, n = 0, i = 0, a = 0, s = 0, o = 0; r < e.length; ) {
    if (n = e.charCodeAt(r++), n < 128) {
      t += String.fromCharCode(n);
      continue;
    }
    if (i = e.charCodeAt(r++), n > 191 && n < 224) {
      s = (n & 31) << 6, s |= i & 63, t += String.fromCharCode(s);
      continue;
    }
    if (a = e.charCodeAt(r++), n < 240) {
      t += String.fromCharCode((n & 15) << 12 | (i & 63) << 6 | a & 63);
      continue;
    }
    s = e.charCodeAt(r++), o = ((n & 7) << 18 | (i & 63) << 12 | (a & 63) << 6 | s & 63) - 65536, t += String.fromCharCode(55296 + (o >>> 10 & 1023)), t += String.fromCharCode(56320 + (o & 1023));
  }
  return t;
}
function xy(e) {
  var t = mi(2 * e.length), r, n, i = 1, a = 0, s = 0, o;
  for (n = 0; n < e.length; n += i)
    i = 1, (o = e.charCodeAt(n)) < 128 ? r = o : o < 224 ? (r = (o & 31) * 64 + (e.charCodeAt(n + 1) & 63), i = 2) : o < 240 ? (r = (o & 15) * 4096 + (e.charCodeAt(n + 1) & 63) * 64 + (e.charCodeAt(n + 2) & 63), i = 3) : (i = 4, r = (o & 7) * 262144 + (e.charCodeAt(n + 1) & 63) * 4096 + (e.charCodeAt(n + 2) & 63) * 64 + (e.charCodeAt(n + 3) & 63), r -= 65536, s = 55296 + (r >>> 10 & 1023), r = 56320 + (r & 1023)), s !== 0 && (t[a++] = s & 255, t[a++] = s >>> 8, s = 0), t[a++] = r % 256, t[a++] = r >>> 8;
  return t.slice(0, a).toString("ucs2");
}
function Ty(e) {
  return Rn(e, "binary").toString("utf8");
}
var Ec = "foo bar baz", ja = ft && (/* @__PURE__ */ Ty(Ec) == /* @__PURE__ */ Kd(Ec) && Ty || /* @__PURE__ */ xy(Ec) == /* @__PURE__ */ Kd(Ec) && xy) || Kd, Ya = ft ? function(e) {
  return Rn(e, "utf8").toString("binary");
} : function(e) {
  for (var t = [], r = 0, n = 0, i = 0; r < e.length; )
    switch (n = e.charCodeAt(r++), !0) {
      case n < 128:
        t.push(String.fromCharCode(n));
        break;
      case n < 2048:
        t.push(String.fromCharCode(192 + (n >> 6))), t.push(String.fromCharCode(128 + (n & 63)));
        break;
      case (n >= 55296 && n < 57344):
        n -= 55296, i = e.charCodeAt(r++) - 56320 + (n << 10), t.push(String.fromCharCode(240 + (i >> 18 & 7))), t.push(String.fromCharCode(144 + (i >> 12 & 63))), t.push(String.fromCharCode(128 + (i >> 6 & 63))), t.push(String.fromCharCode(128 + (i & 63)));
        break;
      default:
        t.push(String.fromCharCode(224 + (n >> 12))), t.push(String.fromCharCode(128 + (n >> 6 & 63))), t.push(String.fromCharCode(128 + (n & 63)));
    }
  return t.join("");
}, wN = /* @__PURE__ */ (function() {
  var e = [
    ["nbsp", " "],
    ["middot", ""],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(t) {
    return [new RegExp("&" + t[0] + ";", "ig"), t[1]];
  });
  return function(r) {
    for (var n = r.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, `
`).replace(/<[^>]*>/g, ""), i = 0; i < e.length; ++i) n = n.replace(e[i][0], e[i][1]);
    return n;
  };
})(), Sw = /(^\s|\s$|\n)/;
function Xt(e, t) {
  return "<" + e + (t.match(Sw) ? ' xml:space="preserve"' : "") + ">" + t + "</" + e + ">";
}
function Ja(e) {
  return Yt(e).map(function(t) {
    return " " + t + '="' + e[t] + '"';
  }).join("");
}
function be(e, t, r) {
  return "<" + e + (r != null ? Ja(r) : "") + (t != null ? (t.match(Sw) ? ' xml:space="preserve"' : "") + ">" + t + "</" + e : "/") + ">";
}
function o0(e, t) {
  try {
    return e.toISOString().replace(/\.\d*/, "");
  } catch (r) {
    if (t) throw r;
  }
  return "";
}
function xN(e, t) {
  switch (typeof e) {
    case "string":
      var r = be("vt:lpwstr", gt(e));
      return r = r.replace(/&quot;/g, "_x0022_"), r;
    case "number":
      return be((e | 0) == e ? "vt:i4" : "vt:r8", gt(String(e)));
    case "boolean":
      return be("vt:bool", e ? "true" : "false");
  }
  if (e instanceof Date) return be("vt:filetime", o0(e));
  throw new Error("Unable to serialize " + e);
}
var Ut = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  dc: "http://purl.org/dc/elements/1.1/",
  dcterms: "http://purl.org/dc/terms/",
  dcmitype: "http://purl.org/dc/dcmitype/",
  r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  xsi: "http://www.w3.org/2001/XMLSchema-instance",
  xsd: "http://www.w3.org/2001/XMLSchema"
}, ra = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
], Or = {
  o: "urn:schemas-microsoft-com:office:office",
  x: "urn:schemas-microsoft-com:office:excel",
  ss: "urn:schemas-microsoft-com:office:spreadsheet",
  dt: "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
  mv: "http://macVmlSchemaUri",
  v: "urn:schemas-microsoft-com:vml",
  html: "http://www.w3.org/TR/REC-html40"
};
function TN(e, t) {
  for (var r = 1 - 2 * (e[t + 7] >>> 7), n = ((e[t + 7] & 127) << 4) + (e[t + 6] >>> 4 & 15), i = e[t + 6] & 15, a = 5; a >= 0; --a) i = i * 256 + e[t + a];
  return n == 2047 ? i == 0 ? r * (1 / 0) : NaN : (n == 0 ? n = -1022 : (n -= 1023, i += Math.pow(2, 52)), r * Math.pow(2, n - 52) * i);
}
function SN(e, t, r) {
  var n = (t < 0 || 1 / t == -1 / 0 ? 1 : 0) << 7, i = 0, a = 0, s = n ? -t : t;
  isFinite(s) ? s == 0 ? i = a = 0 : (i = Math.floor(Math.log(s) / Math.LN2), a = s * Math.pow(2, 52 - i), i <= -1023 && (!isFinite(a) || a < Math.pow(2, 52)) ? i = -1022 : (a -= Math.pow(2, 52), i += 1023)) : (i = 2047, a = isNaN(t) ? 26985 : 0);
  for (var o = 0; o <= 5; ++o, a /= 256) e[r + o] = a & 255;
  e[r + 6] = (i & 15) << 4 | a & 15, e[r + 7] = i >> 4 | n;
}
var Sy = function(e) {
  for (var t = [], r = 10240, n = 0; n < e[0].length; ++n) if (e[0][n]) for (var i = 0, a = e[0][n].length; i < a; i += r) t.push.apply(t, e[0][n].slice(i, i + r));
  return t;
}, Ay = ft ? function(e) {
  return e[0].length > 0 && Buffer.isBuffer(e[0][0]) ? Buffer.concat(e[0].map(function(t) {
    return Buffer.isBuffer(t) ? t : Rn(t);
  })) : Sy(e);
} : Sy, Ry = function(e, t, r) {
  for (var n = [], i = t; i < r; i += 2) n.push(String.fromCharCode(qa(e, i)));
  return n.join("").replace(Ba, "");
}, K0 = ft ? function(e, t, r) {
  return Buffer.isBuffer(e) ? e.toString("utf16le", t, r).replace(Ba, "") : Ry(e, t, r);
} : Ry, $y = function(e, t, r) {
  for (var n = [], i = t; i < t + r; ++i) n.push(("0" + e[i].toString(16)).slice(-2));
  return n.join("");
}, Aw = ft ? function(e, t, r) {
  return Buffer.isBuffer(e) ? e.toString("hex", t, t + r) : $y(e, t, r);
} : $y, Oy = function(e, t, r) {
  for (var n = [], i = t; i < r; i++) n.push(String.fromCharCode(Bi(e, i)));
  return n.join("");
}, cs = ft ? function(t, r, n) {
  return Buffer.isBuffer(t) ? t.toString("utf8", r, n) : Oy(t, r, n);
} : Oy, Rw = function(e, t) {
  var r = Nr(e, t);
  return r > 0 ? cs(e, t + 4, t + 4 + r - 1) : "";
}, $w = Rw, Ow = function(e, t) {
  var r = Nr(e, t);
  return r > 0 ? cs(e, t + 4, t + 4 + r - 1) : "";
}, Nw = Ow, Pw = function(e, t) {
  var r = 2 * Nr(e, t);
  return r > 0 ? cs(e, t + 4, t + 4 + r - 1) : "";
}, Cw = Pw, Iw = function(t, r) {
  var n = Nr(t, r);
  return n > 0 ? K0(t, r + 4, r + 4 + n) : "";
}, bw = Iw, Fw = function(e, t) {
  var r = Nr(e, t);
  return r > 0 ? cs(e, t + 4, t + 4 + r) : "";
}, Dw = Fw, kw = function(e, t) {
  return TN(e, t);
}, Uc = kw, Y0 = function(t) {
  return Array.isArray(t) || typeof Uint8Array < "u" && t instanceof Uint8Array;
};
ft && ($w = function(t, r) {
  if (!Buffer.isBuffer(t)) return Rw(t, r);
  var n = t.readUInt32LE(r);
  return n > 0 ? t.toString("utf8", r + 4, r + 4 + n - 1) : "";
}, Nw = function(t, r) {
  if (!Buffer.isBuffer(t)) return Ow(t, r);
  var n = t.readUInt32LE(r);
  return n > 0 ? t.toString("utf8", r + 4, r + 4 + n - 1) : "";
}, Cw = function(t, r) {
  if (!Buffer.isBuffer(t)) return Pw(t, r);
  var n = 2 * t.readUInt32LE(r);
  return t.toString("utf16le", r + 4, r + 4 + n - 1);
}, bw = function(t, r) {
  if (!Buffer.isBuffer(t)) return Iw(t, r);
  var n = t.readUInt32LE(r);
  return t.toString("utf16le", r + 4, r + 4 + n);
}, Dw = function(t, r) {
  if (!Buffer.isBuffer(t)) return Fw(t, r);
  var n = t.readUInt32LE(r);
  return t.toString("utf8", r + 4, r + 4 + n);
}, Uc = function(t, r) {
  return Buffer.isBuffer(t) ? t.readDoubleLE(r) : kw(t, r);
}, Y0 = function(t) {
  return Buffer.isBuffer(t) || Array.isArray(t) || typeof Uint8Array < "u" && t instanceof Uint8Array;
});
var Bi = function(e, t) {
  return e[t];
}, qa = function(e, t) {
  return e[t + 1] * 256 + e[t];
}, AN = function(e, t) {
  var r = e[t + 1] * 256 + e[t];
  return r < 32768 ? r : (65535 - r + 1) * -1;
}, Nr = function(e, t) {
  return e[t + 3] * (1 << 24) + (e[t + 2] << 16) + (e[t + 1] << 8) + e[t];
}, fi = function(e, t) {
  return e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t];
}, RN = function(e, t) {
  return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
};
function Va(e, t) {
  var r = "", n, i, a = [], s, o, c, u;
  switch (t) {
    case "dbcs":
      if (u = this.l, ft && Buffer.isBuffer(this)) r = this.slice(this.l, this.l + 2 * e).toString("utf16le");
      else for (c = 0; c < e; ++c)
        r += String.fromCharCode(qa(this, u)), u += 2;
      e *= 2;
      break;
    case "utf8":
      r = cs(this, this.l, this.l + e);
      break;
    case "utf16le":
      e *= 2, r = K0(this, this.l, this.l + e);
      break;
    case "wstr":
      return Va.call(this, e, "dbcs");
    /* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */
    case "lpstr-ansi":
      r = $w(this, this.l), e = 4 + Nr(this, this.l);
      break;
    case "lpstr-cp":
      r = Nw(this, this.l), e = 4 + Nr(this, this.l);
      break;
    /* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */
    case "lpwstr":
      r = Cw(this, this.l), e = 4 + 2 * Nr(this, this.l);
      break;
    /* [MS-OFFCRYPTO] 2.1.2 Length-Prefixed Padded Unicode String (UNICODE-LP-P4) */
    case "lpp4":
      e = 4 + Nr(this, this.l), r = bw(this, this.l), e & 2 && (e += 2);
      break;
    /* [MS-OFFCRYPTO] 2.1.3 Length-Prefixed UTF-8 String (UTF-8-LP-P4) */
    case "8lpp4":
      e = 4 + Nr(this, this.l), r = Dw(this, this.l), e & 3 && (e += 4 - (e & 3));
      break;
    case "cstr":
      for (e = 0, r = ""; (s = Bi(this, this.l + e++)) !== 0; ) a.push(vc(s));
      r = a.join("");
      break;
    case "_wstr":
      for (e = 0, r = ""; (s = qa(this, this.l + e)) !== 0; )
        a.push(vc(s)), e += 2;
      e += 2, r = a.join("");
      break;
    /* sbcs and dbcs support continue records in the SST way TODO codepages */
    case "dbcs-cont":
      for (r = "", u = this.l, c = 0; c < e; ++c) {
        if (this.lens && this.lens.indexOf(u) !== -1)
          return s = Bi(this, u), this.l = u + 1, o = Va.call(this, e - c, s ? "dbcs-cont" : "sbcs-cont"), a.join("") + o;
        a.push(vc(qa(this, u))), u += 2;
      }
      r = a.join(""), e *= 2;
      break;
    case "cpstr":
    /* falls through */
    case "sbcs-cont":
      for (r = "", u = this.l, c = 0; c != e; ++c) {
        if (this.lens && this.lens.indexOf(u) !== -1)
          return s = Bi(this, u), this.l = u + 1, o = Va.call(this, e - c, s ? "dbcs-cont" : "sbcs-cont"), a.join("") + o;
        a.push(vc(Bi(this, u))), u += 1;
      }
      r = a.join("");
      break;
    default:
      switch (e) {
        case 1:
          return n = Bi(this, this.l), this.l++, n;
        case 2:
          return n = (t === "i" ? AN : qa)(this, this.l), this.l += 2, n;
        case 4:
        case -4:
          return t === "i" || (this[this.l + 3] & 128) === 0 ? (n = (e > 0 ? fi : RN)(this, this.l), this.l += 4, n) : (i = Nr(this, this.l), this.l += 4, i);
        case 8:
        case -8:
          if (t === "f")
            return e == 8 ? i = Uc(this, this.l) : i = Uc([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0), this.l += 8, i;
          e = 8;
        /* falls through */
        case 16:
          r = Aw(this, this.l, e);
          break;
      }
  }
  return this.l += e, r;
}
var $N = function(e, t, r) {
  e[r] = t & 255, e[r + 1] = t >>> 8 & 255, e[r + 2] = t >>> 16 & 255, e[r + 3] = t >>> 24 & 255;
}, ON = function(e, t, r) {
  e[r] = t & 255, e[r + 1] = t >> 8 & 255, e[r + 2] = t >> 16 & 255, e[r + 3] = t >> 24 & 255;
}, NN = function(e, t, r) {
  e[r] = t & 255, e[r + 1] = t >>> 8 & 255;
};
function PN(e, t, r) {
  var n = 0, i = 0;
  if (r === "dbcs") {
    for (i = 0; i != t.length; ++i) NN(this, t.charCodeAt(i), this.l + 2 * i);
    n = 2 * t.length;
  } else if (r === "sbcs") {
    for (t = t.replace(/[^\x00-\x7F]/g, "_"), i = 0; i != t.length; ++i) this[this.l + i] = t.charCodeAt(i) & 255;
    n = t.length;
  } else if (r === "hex") {
    for (; i < e; ++i)
      this[this.l++] = parseInt(t.slice(2 * i, 2 * i + 2), 16) || 0;
    return this;
  } else if (r === "utf16le") {
    var a = Math.min(this.l + e, this.length);
    for (i = 0; i < Math.min(t.length, e); ++i) {
      var s = t.charCodeAt(i);
      this[this.l++] = s & 255, this[this.l++] = s >> 8;
    }
    for (; this.l < a; ) this[this.l++] = 0;
    return this;
  } else switch (e) {
    case 1:
      n = 1, this[this.l] = t & 255;
      break;
    case 2:
      n = 2, this[this.l] = t & 255, t >>>= 8, this[this.l + 1] = t & 255;
      break;
    case 3:
      n = 3, this[this.l] = t & 255, t >>>= 8, this[this.l + 1] = t & 255, t >>>= 8, this[this.l + 2] = t & 255;
      break;
    case 4:
      n = 4, $N(this, t, this.l);
      break;
    case 8:
      if (n = 8, r === "f") {
        SN(this, t, this.l);
        break;
      }
    /* falls through */
    case 16:
      break;
    case -4:
      n = 4, ON(this, t, this.l);
      break;
  }
  return this.l += n, this;
}
function Lw(e, t) {
  var r = Aw(this, this.l, e.length >> 1);
  if (r !== e) throw new Error(t + "Expected " + e + " saw " + r);
  this.l += e.length >> 1;
}
function $r(e, t) {
  e.l = t, e.read_shift = /*::(*/
  Va, e.chk = Lw, e.write_shift = PN;
}
function on(e, t) {
  e.l += t;
}
function ve(e) {
  var t = mi(e);
  return $r(t, 0), t;
}
function vr() {
  var e = [], t = ft ? 256 : 2048, r = function(u) {
    var l = ve(u);
    return $r(l, 0), l;
  }, n = r(t), i = function() {
    n && (n.length > n.l && (n = n.slice(0, n.l), n.l = n.length), n.length > 0 && e.push(n), n = null);
  }, a = function(u) {
    return n && u < n.length - n.l ? n : (i(), n = r(Math.max(u + 1, t)));
  }, s = function() {
    return i(), Wt(e);
  }, o = function(u) {
    i(), n = u, n.l == null && (n.l = n.length), a(t);
  };
  return { next: a, push: o, end: s, _bufs: e };
}
function Se(e, t, r, n) {
  var i = +t, a;
  if (!isNaN(i)) {
    n || (n = TD[i].p || (r || []).length || 0), a = 1 + (i >= 128 ? 1 : 0) + 1, n >= 128 && ++a, n >= 16384 && ++a, n >= 2097152 && ++a;
    var s = e.next(a);
    i <= 127 ? s.write_shift(1, i) : (s.write_shift(1, (i & 127) + 128), s.write_shift(1, i >> 7));
    for (var o = 0; o != 4; ++o)
      if (n >= 128)
        s.write_shift(1, (n & 127) + 128), n >>= 7;
      else {
        s.write_shift(1, n);
        break;
      }
    /*:: length != null &&*/
    n > 0 && Y0(r) && e.push(r);
  }
}
function Ha(e, t, r) {
  var n = yr(e);
  if (t.s ? (n.cRel && (n.c += t.s.c), n.rRel && (n.r += t.s.r)) : (n.cRel && (n.c += t.c), n.rRel && (n.r += t.r)), !r || r.biff < 12) {
    for (; n.c >= 256; ) n.c -= 256;
    for (; n.r >= 65536; ) n.r -= 65536;
  }
  return n;
}
function Ny(e, t, r) {
  var n = yr(e);
  return n.s = Ha(n.s, t.s, r), n.e = Ha(n.e, t.s, r), n;
}
function Ga(e, t) {
  if (e.cRel && e.c < 0)
    for (e = yr(e); e.c < 0; ) e.c += t > 8 ? 16384 : 256;
  if (e.rRel && e.r < 0)
    for (e = yr(e); e.r < 0; ) e.r += t > 8 ? 1048576 : t > 5 ? 65536 : 16384;
  var r = _t(e);
  return !e.cRel && e.cRel != null && (r = bN(r)), !e.rRel && e.rRel != null && (r = CN(r)), r;
}
function Yd(e, t) {
  return e.s.r == 0 && !e.s.rRel && e.e.r == (t.biff >= 12 ? 1048575 : t.biff >= 8 ? 65536 : 16384) && !e.e.rRel ? (e.s.cRel ? "" : "$") + ar(e.s.c) + ":" + (e.e.cRel ? "" : "$") + ar(e.e.c) : e.s.c == 0 && !e.s.cRel && e.e.c == (t.biff >= 12 ? 16383 : 255) && !e.e.cRel ? (e.s.rRel ? "" : "$") + Kt(e.s.r) + ":" + (e.e.rRel ? "" : "$") + Kt(e.e.r) : Ga(e.s, t.biff) + ":" + Ga(e.e, t.biff);
}
function J0(e) {
  return parseInt(IN(e), 10) - 1;
}
function Kt(e) {
  return "" + (e + 1);
}
function CN(e) {
  return e.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function IN(e) {
  return e.replace(/\$(\d+)$/, "$1");
}
function Q0(e) {
  for (var t = FN(e), r = 0, n = 0; n !== t.length; ++n) r = 26 * r + t.charCodeAt(n) - 64;
  return r - 1;
}
function ar(e) {
  if (e < 0) throw new Error("invalid column " + e);
  var t = "";
  for (++e; e; e = Math.floor((e - 1) / 26)) t = String.fromCharCode((e - 1) % 26 + 65) + t;
  return t;
}
function bN(e) {
  return e.replace(/^([A-Z])/, "$$$1");
}
function FN(e) {
  return e.replace(/^\$([A-Z])/, "$1");
}
function DN(e) {
  return e.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
function qt(e) {
  for (var t = 0, r = 0, n = 0; n < e.length; ++n) {
    var i = e.charCodeAt(n);
    i >= 48 && i <= 57 ? t = 10 * t + (i - 48) : i >= 65 && i <= 90 && (r = 26 * r + (i - 64));
  }
  return { c: r - 1, r: t - 1 };
}
function _t(e) {
  for (var t = e.c + 1, r = ""; t; t = (t - 1) / 26 | 0) r = String.fromCharCode((t - 1) % 26 + 65) + r;
  return r + (e.r + 1);
}
function Pr(e) {
  var t = e.indexOf(":");
  return t == -1 ? { s: qt(e), e: qt(e) } : { s: qt(e.slice(0, t)), e: qt(e.slice(t + 1)) };
}
function Ft(e, t) {
  return typeof t > "u" || typeof t == "number" ? Ft(e.s, e.e) : (typeof e != "string" && (e = _t(e)), typeof t != "string" && (t = _t(t)), e == t ? e : e + ":" + t);
}
function At(e) {
  var t = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }, r = 0, n = 0, i = 0, a = e.length;
  for (r = 0; n < a && !((i = e.charCodeAt(n) - 64) < 1 || i > 26); ++n)
    r = 26 * r + i;
  for (t.s.c = --r, r = 0; n < a && !((i = e.charCodeAt(n) - 48) < 0 || i > 9); ++n)
    r = 10 * r + i;
  if (t.s.r = --r, n === a || i != 10)
    return t.e.c = t.s.c, t.e.r = t.s.r, t;
  for (++n, r = 0; n != a && !((i = e.charCodeAt(n) - 64) < 1 || i > 26); ++n)
    r = 26 * r + i;
  for (t.e.c = --r, r = 0; n != a && !((i = e.charCodeAt(n) - 48) < 0 || i > 9); ++n)
    r = 10 * r + i;
  return t.e.r = --r, t;
}
function Py(e, t) {
  var r = e.t == "d" && t instanceof Date;
  if (e.z != null) try {
    return e.w = Vn(e.z, r ? _r(t) : t);
  } catch {
  }
  try {
    return e.w = Vn((e.XF || {}).numFmtId || (r ? 14 : 0), r ? _r(t) : t);
  } catch {
    return "" + t;
  }
}
function An(e, t, r) {
  return e == null || e.t == null || e.t == "z" ? "" : e.w !== void 0 ? e.w : (e.t == "d" && !e.z && r && r.dateNF && (e.z = r.dateNF), e.t == "e" ? ls[e.v] || e.v : t == null ? Py(e, e.v) : Py(e, t));
}
function wi(e, t) {
  var r = t && t.sheet ? t.sheet : "Sheet1", n = {};
  return n[r] = e, { SheetNames: [r], Sheets: n };
}
function Mw(e, t, r) {
  var n = r || {}, i = e ? Array.isArray(e) : n.dense, a = e || (i ? [] : {}), s = 0, o = 0;
  if (a && n.origin != null) {
    if (typeof n.origin == "number") s = n.origin;
    else {
      var c = typeof n.origin == "string" ? qt(n.origin) : n.origin;
      s = c.r, o = c.c;
    }
    a["!ref"] || (a["!ref"] = "A1:A1");
  }
  var u = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (a["!ref"]) {
    var l = At(a["!ref"]);
    u.s.c = l.s.c, u.s.r = l.s.r, u.e.c = Math.max(u.e.c, l.e.c), u.e.r = Math.max(u.e.r, l.e.r), s == -1 && (u.e.r = s = l.e.r + 1);
  }
  for (var d = 0; d != t.length; ++d)
    if (t[d]) {
      if (!Array.isArray(t[d])) throw new Error("aoa_to_sheet expects an array of arrays");
      for (var f = 0; f != t[d].length; ++f)
        if (!(typeof t[d][f] > "u")) {
          var p = { v: t[d][f] }, v = s + d, m = o + f;
          if (u.s.r > v && (u.s.r = v), u.s.c > m && (u.s.c = m), u.e.r < v && (u.e.r = v), u.e.c < m && (u.e.c = m), t[d][f] && typeof t[d][f] == "object" && !Array.isArray(t[d][f]) && !(t[d][f] instanceof Date)) p = t[d][f];
          else if (Array.isArray(p.v) && (p.f = t[d][f][1], p.v = p.v[0]), p.v === null)
            if (p.f) p.t = "n";
            else if (n.nullError)
              p.t = "e", p.v = 0;
            else if (n.sheetStubs) p.t = "z";
            else continue;
          else typeof p.v == "number" ? p.t = "n" : typeof p.v == "boolean" ? p.t = "b" : p.v instanceof Date ? (p.z = n.dateNF || It[14], n.cellDates ? (p.t = "d", p.w = Vn(p.z, _r(p.v))) : (p.t = "n", p.v = _r(p.v), p.w = Vn(p.z, p.v))) : p.t = "s";
          if (i)
            a[v] || (a[v] = []), a[v][m] && a[v][m].z && (p.z = a[v][m].z), a[v][m] = p;
          else {
            var h = _t({ c: m, r: v });
            a[h] && a[h].z && (p.z = a[h].z), a[h] = p;
          }
        }
    }
  return u.s.c < 1e7 && (a["!ref"] = Ft(u)), a;
}
function na(e, t) {
  return Mw(null, e, t);
}
function kN(e) {
  return e.read_shift(4, "i");
}
function Xr(e, t) {
  return t || (t = ve(4)), t.write_shift(4, e), t;
}
function sr(e) {
  var t = e.read_shift(4);
  return t === 0 ? "" : e.read_shift(t, "dbcs");
}
function Bt(e, t) {
  var r = !1;
  return t == null && (r = !0, t = ve(4 + 2 * e.length)), t.write_shift(4, e.length), e.length > 0 && t.write_shift(0, e, "dbcs"), r ? t.slice(0, t.l) : t;
}
function LN(e) {
  return { ich: e.read_shift(2), ifnt: e.read_shift(2) };
}
function MN(e, t) {
  return t || (t = ve(4)), t.write_shift(2, 0), t.write_shift(2, 0), t;
}
function Z0(e, t) {
  var r = e.l, n = e.read_shift(1), i = sr(e), a = [], s = { t: i, h: i };
  if ((n & 1) !== 0) {
    for (var o = e.read_shift(4), c = 0; c != o; ++c) a.push(LN(e));
    s.r = a;
  } else s.r = [{ ich: 0, ifnt: 0 }];
  return e.l = r + t, s;
}
function UN(e, t) {
  var r = !1;
  return t == null && (r = !0, t = ve(15 + 4 * e.t.length)), t.write_shift(1, 0), Bt(e.t, t), r ? t.slice(0, t.l) : t;
}
var qN = Z0;
function BN(e, t) {
  var r = !1;
  return t == null && (r = !0, t = ve(23 + 4 * e.t.length)), t.write_shift(1, 1), Bt(e.t, t), t.write_shift(4, 1), MN({}, t), r ? t.slice(0, t.l) : t;
}
function Mr(e) {
  var t = e.read_shift(4), r = e.read_shift(2);
  return r += e.read_shift(1) << 16, e.l++, { c: t, iStyleRef: r };
}
function xi(e, t) {
  return t == null && (t = ve(8)), t.write_shift(-4, e.c), t.write_shift(3, e.iStyleRef || e.s), t.write_shift(1, 0), t;
}
function Ti(e) {
  var t = e.read_shift(2);
  return t += e.read_shift(1) << 16, e.l++, { c: -1, iStyleRef: t };
}
function Si(e, t) {
  return t == null && (t = ve(4)), t.write_shift(3, e.iStyleRef || e.s), t.write_shift(1, 0), t;
}
var jN = sr, Uw = Bt;
function eh(e) {
  var t = e.read_shift(4);
  return t === 0 || t === 4294967295 ? "" : e.read_shift(t, "dbcs");
}
function qc(e, t) {
  var r = !1;
  return t == null && (r = !0, t = ve(127)), t.write_shift(4, e.length > 0 ? e.length : 4294967295), e.length > 0 && t.write_shift(0, e, "dbcs"), r ? t.slice(0, t.l) : t;
}
var VN = sr, c0 = eh, th = qc;
function qw(e) {
  var t = e.slice(e.l, e.l + 4), r = t[0] & 1, n = t[0] & 2;
  e.l += 4;
  var i = n === 0 ? Uc([0, 0, 0, 0, t[0] & 252, t[1], t[2], t[3]], 0) : fi(t, 0) >> 2;
  return r ? i / 100 : i;
}
function Bw(e, t) {
  t == null && (t = ve(4));
  var r = 0, n = 0, i = e * 100;
  if (e == (e | 0) && e >= -536870912 && e < 1 << 29 ? n = 1 : i == (i | 0) && i >= -536870912 && i < 1 << 29 && (n = 1, r = 1), n) t.write_shift(-4, ((r ? i : e) << 2) + (r + 2));
  else throw new Error("unsupported RkNumber " + e);
}
function jw(e) {
  var t = { s: {}, e: {} };
  return t.s.r = e.read_shift(4), t.e.r = e.read_shift(4), t.s.c = e.read_shift(4), t.e.c = e.read_shift(4), t;
}
function HN(e, t) {
  return t || (t = ve(16)), t.write_shift(4, e.s.r), t.write_shift(4, e.e.r), t.write_shift(4, e.s.c), t.write_shift(4, e.e.c), t;
}
var Ai = jw, ia = HN;
function aa(e) {
  if (e.length - e.l < 8) throw "XLS Xnum Buffer underflow";
  return e.read_shift(8, "f");
}
function gi(e, t) {
  return (t || ve(8)).write_shift(8, e, "f");
}
function GN(e) {
  var t = {}, r = e.read_shift(1), n = r >>> 1, i = e.read_shift(1), a = e.read_shift(2, "i"), s = e.read_shift(1), o = e.read_shift(1), c = e.read_shift(1);
  switch (e.l++, n) {
    case 0:
      t.auto = 1;
      break;
    case 1:
      t.index = i;
      var u = eP[i];
      u && (t.rgb = By(u));
      break;
    case 2:
      t.rgb = By([s, o, c]);
      break;
    case 3:
      t.theme = i;
      break;
  }
  return a != 0 && (t.tint = a > 0 ? a / 32767 : a / 32768), t;
}
function Bc(e, t) {
  if (t || (t = ve(8)), !e || e.auto)
    return t.write_shift(4, 0), t.write_shift(4, 0), t;
  e.index != null ? (t.write_shift(1, 2), t.write_shift(1, e.index)) : e.theme != null ? (t.write_shift(1, 6), t.write_shift(1, e.theme)) : (t.write_shift(1, 5), t.write_shift(1, 0));
  var r = e.tint || 0;
  if (r > 0 ? r *= 32767 : r < 0 && (r *= 32768), t.write_shift(2, r), !e.rgb || e.theme != null)
    t.write_shift(2, 0), t.write_shift(1, 0), t.write_shift(1, 0);
  else {
    var n = e.rgb || "FFFFFF";
    typeof n == "number" && (n = ("000000" + n.toString(16)).slice(-6)), t.write_shift(1, parseInt(n.slice(0, 2), 16)), t.write_shift(1, parseInt(n.slice(2, 4), 16)), t.write_shift(1, parseInt(n.slice(4, 6), 16)), t.write_shift(1, 255);
  }
  return t;
}
function zN(e) {
  var t = e.read_shift(1);
  e.l++;
  var r = {
    fBold: t & 1,
    fItalic: t & 2,
    fUnderline: t & 4,
    fStrikeout: t & 8,
    fOutline: t & 16,
    fShadow: t & 32,
    fCondense: t & 64,
    fExtend: t & 128
  };
  return r;
}
function WN(e, t) {
  t || (t = ve(2));
  var r = (e.italic ? 2 : 0) | (e.strike ? 8 : 0) | (e.outline ? 16 : 0) | (e.shadow ? 32 : 0) | (e.condense ? 64 : 0) | (e.extend ? 128 : 0);
  return t.write_shift(1, r), t.write_shift(1, 0), t;
}
var Vw = 2, Rr = 3, wc = 11, jc = 19, xc = 64, XN = 65, KN = 71, YN = 4108, JN = 4126, zt = 80, Cy = {
  /*::[*/
  1: { n: "CodePage", t: Vw },
  /*::[*/
  2: { n: "Category", t: zt },
  /*::[*/
  3: { n: "PresentationFormat", t: zt },
  /*::[*/
  4: { n: "ByteCount", t: Rr },
  /*::[*/
  5: { n: "LineCount", t: Rr },
  /*::[*/
  6: { n: "ParagraphCount", t: Rr },
  /*::[*/
  7: { n: "SlideCount", t: Rr },
  /*::[*/
  8: { n: "NoteCount", t: Rr },
  /*::[*/
  9: { n: "HiddenCount", t: Rr },
  /*::[*/
  10: { n: "MultimediaClipCount", t: Rr },
  /*::[*/
  11: { n: "ScaleCrop", t: wc },
  /*::[*/
  12: {
    n: "HeadingPairs",
    t: YN
    /* VT_VECTOR | VT_VARIANT */
  },
  /*::[*/
  13: {
    n: "TitlesOfParts",
    t: JN
    /* VT_VECTOR | VT_LPSTR */
  },
  /*::[*/
  14: { n: "Manager", t: zt },
  /*::[*/
  15: { n: "Company", t: zt },
  /*::[*/
  16: { n: "LinksUpToDate", t: wc },
  /*::[*/
  17: { n: "CharacterCount", t: Rr },
  /*::[*/
  19: { n: "SharedDoc", t: wc },
  /*::[*/
  22: { n: "HyperlinksChanged", t: wc },
  /*::[*/
  23: { n: "AppVersion", t: Rr, p: "version" },
  /*::[*/
  24: { n: "DigSig", t: XN },
  /*::[*/
  26: { n: "ContentType", t: zt },
  /*::[*/
  27: { n: "ContentStatus", t: zt },
  /*::[*/
  28: { n: "Language", t: zt },
  /*::[*/
  29: { n: "Version", t: zt },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: jc },
  /*::[*/
  2147483651: { n: "Behavior", t: jc },
  /*::[*/
  1919054434: {}
}, Iy = {
  /*::[*/
  1: { n: "CodePage", t: Vw },
  /*::[*/
  2: { n: "Title", t: zt },
  /*::[*/
  3: { n: "Subject", t: zt },
  /*::[*/
  4: { n: "Author", t: zt },
  /*::[*/
  5: { n: "Keywords", t: zt },
  /*::[*/
  6: { n: "Comments", t: zt },
  /*::[*/
  7: { n: "Template", t: zt },
  /*::[*/
  8: { n: "LastAuthor", t: zt },
  /*::[*/
  9: { n: "RevNumber", t: zt },
  /*::[*/
  10: { n: "EditTime", t: xc },
  /*::[*/
  11: { n: "LastPrinted", t: xc },
  /*::[*/
  12: { n: "CreatedDate", t: xc },
  /*::[*/
  13: { n: "ModifiedDate", t: xc },
  /*::[*/
  14: { n: "PageCount", t: Rr },
  /*::[*/
  15: { n: "WordCount", t: Rr },
  /*::[*/
  16: { n: "CharCount", t: Rr },
  /*::[*/
  17: { n: "Thumbnail", t: KN },
  /*::[*/
  18: { n: "Application", t: zt },
  /*::[*/
  19: { n: "DocSecurity", t: Rr },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: jc },
  /*::[*/
  2147483651: { n: "Behavior", t: jc },
  /*::[*/
  1919054434: {}
};
function QN(e) {
  return e.map(function(t) {
    return [t >> 16 & 255, t >> 8 & 255, t & 255];
  });
}
var ZN = /* @__PURE__ */ QN([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  16777215,
  /* 0x40 icvForeground ?? */
  0,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]), eP = /* @__PURE__ */ yr(ZN), ls = {
  /*::[*/
  0: "#NULL!",
  /*::[*/
  7: "#DIV/0!",
  /*::[*/
  15: "#VALUE!",
  /*::[*/
  23: "#REF!",
  /*::[*/
  29: "#NAME?",
  /*::[*/
  36: "#NUM!",
  /*::[*/
  42: "#N/A",
  /*::[*/
  43: "#GETTING_DATA",
  /*::[*/
  255: "#WTF?"
}, tP = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  sheet: "js"
}, Tc = {
  workbooks: {
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
    xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
  },
  strs: {
    /* Shared Strings */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
    xlsb: "application/vnd.ms-excel.sharedStrings"
  },
  comments: {
    /* Comments */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
    xlsb: "application/vnd.ms-excel.comments"
  },
  sheets: {
    /* Worksheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
    xlsb: "application/vnd.ms-excel.worksheet"
  },
  charts: {
    /* Chartsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
    xlsb: "application/vnd.ms-excel.chartsheet"
  },
  dialogs: {
    /* Dialogsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
    xlsb: "application/vnd.ms-excel.dialogsheet"
  },
  macros: {
    /* Macrosheet (Excel 4.0 Macros) */
    xlsx: "application/vnd.ms-excel.macrosheet+xml",
    xlsb: "application/vnd.ms-excel.macrosheet"
  },
  metadata: {
    /* Metadata (Stock/Geography and Dynamic Array) */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
    xlsb: "application/vnd.ms-excel.sheetMetadata"
  },
  styles: {
    /* Styles */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
    xlsb: "application/vnd.ms-excel.styles"
  }
};
function Hw() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function Gw(e, t) {
  var r = fN(tP), n = [], i;
  n[n.length] = Dt, n[n.length] = be("Types", null, {
    xmlns: Ut.CT,
    "xmlns:xsd": Ut.xsd,
    "xmlns:xsi": Ut.xsi
  }), n = n.concat([
    ["xml", "application/xml"],
    ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
    ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
    ["data", "application/vnd.openxmlformats-officedocument.model+data"],
    /* from test files */
    ["bmp", "image/bmp"],
    ["png", "image/png"],
    ["gif", "image/gif"],
    ["emf", "image/x-emf"],
    ["wmf", "image/x-wmf"],
    ["jpg", "image/jpeg"],
    ["jpeg", "image/jpeg"],
    ["tif", "image/tiff"],
    ["tiff", "image/tiff"],
    ["pdf", "application/pdf"],
    ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
  ].map(function(c) {
    return be("Default", null, { Extension: c[0], ContentType: c[1] });
  }));
  var a = function(c) {
    e[c] && e[c].length > 0 && (i = e[c][0], n[n.length] = be("Override", null, {
      PartName: (i[0] == "/" ? "" : "/") + i,
      ContentType: Tc[c][t.bookType] || Tc[c].xlsx
    }));
  }, s = function(c) {
    (e[c] || []).forEach(function(u) {
      n[n.length] = be("Override", null, {
        PartName: (u[0] == "/" ? "" : "/") + u,
        ContentType: Tc[c][t.bookType] || Tc[c].xlsx
      });
    });
  }, o = function(c) {
    (e[c] || []).forEach(function(u) {
      n[n.length] = be("Override", null, {
        PartName: (u[0] == "/" ? "" : "/") + u,
        ContentType: r[c][0]
      });
    });
  };
  return a("workbooks"), s("sheets"), s("charts"), o("themes"), ["strs", "styles"].forEach(a), ["coreprops", "extprops", "custprops"].forEach(o), o("vba"), o("comments"), o("threadedcomments"), o("drawings"), s("metadata"), o("people"), n.length > 2 && (n[n.length] = "</Types>", n[1] = n[1].replace("/>", ">")), n.join("");
}
var ct = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function zw(e) {
  var t = e.lastIndexOf("/");
  return e.slice(0, t + 1) + "_rels/" + e.slice(t + 1) + ".rels";
}
function zi(e) {
  var t = [Dt, be("Relationships", null, {
    //'xmlns:ns0': XMLNS.RELS,
    xmlns: Ut.RELS
  })];
  return Yt(e["!id"]).forEach(function(r) {
    t[t.length] = be("Relationship", null, e["!id"][r]);
  }), t.length > 2 && (t[t.length] = "</Relationships>", t[1] = t[1].replace("/>", ">")), t.join("");
}
function mt(e, t, r, n, i, a) {
  if (i || (i = {}), e["!id"] || (e["!id"] = {}), e["!idx"] || (e["!idx"] = 1), t < 0) for (t = e["!idx"]; e["!id"]["rId" + t]; ++t)
    ;
  if (e["!idx"] = t + 1, i.Id = "rId" + t, i.Type = n, i.Target = r, [ct.HLINK, ct.XPATH, ct.XMISS].indexOf(i.Type) > -1 && (i.TargetMode = "External"), e["!id"][i.Id]) throw new Error("Cannot rewrite rId " + t);
  return e["!id"][i.Id] = i, e[("/" + i.Target).replace("//", "/")] = i, t;
}
function rP(e) {
  var t = [Dt];
  t.push(`<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">
`), t.push(`  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>
`);
  for (var r = 0; r < e.length; ++r) t.push('  <manifest:file-entry manifest:full-path="' + e[r][0] + '" manifest:media-type="' + e[r][1] + `"/>
`);
  return t.push("</manifest:manifest>"), t.join("");
}
function by(e, t, r) {
  return [
    '  <rdf:Description rdf:about="' + e + `">
`,
    '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (r || "odf") + "#" + t + `"/>
`,
    `  </rdf:Description>
`
  ].join("");
}
function nP(e, t) {
  return [
    '  <rdf:Description rdf:about="' + e + `">
`,
    '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + t + `"/>
`,
    `  </rdf:Description>
`
  ].join("");
}
function iP(e) {
  var t = [Dt];
  t.push(`<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
`);
  for (var r = 0; r != e.length; ++r)
    t.push(by(e[r][0], e[r][1])), t.push(nP("", e[r][0]));
  return t.push(by("", "Document", "pkg")), t.push("</rdf:RDF>"), t.join("");
}
function Ww() {
  return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + bc.version + "</meta:generator></office:meta></office:document-meta>";
}
var di = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
];
function Jd(e, t, r, n, i) {
  i[e] != null || t == null || t === "" || (i[e] = t, t = gt(t), n[n.length] = r ? be(e, t, r) : Xt(e, t));
}
function Xw(e, t) {
  var r = t || {}, n = [Dt, be("cp:coreProperties", null, {
    //'xmlns': XMLNS.CORE_PROPS,
    "xmlns:cp": Ut.CORE_PROPS,
    "xmlns:dc": Ut.dc,
    "xmlns:dcterms": Ut.dcterms,
    "xmlns:dcmitype": Ut.dcmitype,
    "xmlns:xsi": Ut.xsi
  })], i = {};
  if (!e && !r.Props) return n.join("");
  e && (e.CreatedDate != null && Jd("dcterms:created", typeof e.CreatedDate == "string" ? e.CreatedDate : o0(e.CreatedDate, r.WTF), { "xsi:type": "dcterms:W3CDTF" }, n, i), e.ModifiedDate != null && Jd("dcterms:modified", typeof e.ModifiedDate == "string" ? e.ModifiedDate : o0(e.ModifiedDate, r.WTF), { "xsi:type": "dcterms:W3CDTF" }, n, i));
  for (var a = 0; a != di.length; ++a) {
    var s = di[a], o = r.Props && r.Props[s[1]] != null ? r.Props[s[1]] : e ? e[s[1]] : null;
    o === !0 ? o = "1" : o === !1 ? o = "0" : typeof o == "number" && (o = String(o)), o != null && Jd(s[0], o, null, n, i);
  }
  return n.length > 2 && (n[n.length] = "</cp:coreProperties>", n[1] = n[1].replace("/>", ">")), n.join("");
}
var Wi = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
], Kw = [
  "Worksheets",
  "SheetNames",
  "NamedRanges",
  "DefinedNames",
  "Chartsheets",
  "ChartNames"
];
function Yw(e) {
  var t = [], r = be;
  return e || (e = {}), e.Application = "SheetJS", t[t.length] = Dt, t[t.length] = be("Properties", null, {
    xmlns: Ut.EXT_PROPS,
    "xmlns:vt": Ut.vt
  }), Wi.forEach(function(n) {
    if (e[n[1]] !== void 0) {
      var i;
      switch (n[2]) {
        case "string":
          i = gt(String(e[n[1]]));
          break;
        case "bool":
          i = e[n[1]] ? "true" : "false";
          break;
      }
      i !== void 0 && (t[t.length] = r(n[0], i));
    }
  }), t[t.length] = r("HeadingPairs", r("vt:vector", r("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + r("vt:variant", r("vt:i4", String(e.Worksheets))), { size: 2, baseType: "variant" })), t[t.length] = r("TitlesOfParts", r("vt:vector", e.SheetNames.map(function(n) {
    return "<vt:lpstr>" + gt(n) + "</vt:lpstr>";
  }).join(""), { size: e.Worksheets, baseType: "lpstr" })), t.length > 2 && (t[t.length] = "</Properties>", t[1] = t[1].replace("/>", ">")), t.join("");
}
function Jw(e) {
  var t = [Dt, be("Properties", null, {
    xmlns: Ut.CUST_PROPS,
    "xmlns:vt": Ut.vt
  })];
  if (!e) return t.join("");
  var r = 1;
  return Yt(e).forEach(function(i) {
    ++r, t[t.length] = be("property", xN(e[i]), {
      fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      pid: r,
      name: gt(i)
    });
  }), t.length > 2 && (t[t.length] = "</Properties>", t[1] = t[1].replace("/>", ">")), t.join("");
}
var Fy = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
};
function aP(e, t) {
  var r = [];
  return Yt(Fy).map(function(n) {
    for (var i = 0; i < di.length; ++i) if (di[i][1] == n) return di[i];
    for (i = 0; i < Wi.length; ++i) if (Wi[i][1] == n) return Wi[i];
    throw n;
  }).forEach(function(n) {
    if (e[n[1]] != null) {
      var i = t && t.Props && t.Props[n[1]] != null ? t.Props[n[1]] : e[n[1]];
      switch (n[2]) {
        case "date":
          i = new Date(i).toISOString().replace(/\.\d*Z/, "Z");
          break;
      }
      typeof i == "number" ? i = String(i) : i === !0 || i === !1 ? i = i ? "1" : "0" : i instanceof Date && (i = new Date(i).toISOString().replace(/\.\d*Z/, "")), r.push(Xt(Fy[n[1]] || n[1], i));
    }
  }), be("DocumentProperties", r.join(""), { xmlns: Or.o });
}
function sP(e, t) {
  var r = ["Worksheets", "SheetNames"], n = "CustomDocumentProperties", i = [];
  return e && Yt(e).forEach(function(a) {
    if (Object.prototype.hasOwnProperty.call(e, a)) {
      for (var s = 0; s < di.length; ++s) if (a == di[s][1]) return;
      for (s = 0; s < Wi.length; ++s) if (a == Wi[s][1]) return;
      for (s = 0; s < r.length; ++s) if (a == r[s]) return;
      var o = e[a], c = "string";
      typeof o == "number" ? (c = "float", o = String(o)) : o === !0 || o === !1 ? (c = "boolean", o = o ? "1" : "0") : o = String(o), i.push(be(wy(a), o, { "dt:dt": c }));
    }
  }), t && Yt(t).forEach(function(a) {
    if (Object.prototype.hasOwnProperty.call(t, a) && !(e && Object.prototype.hasOwnProperty.call(e, a))) {
      var s = t[a], o = "string";
      typeof s == "number" ? (o = "float", s = String(s)) : s === !0 || s === !1 ? (o = "boolean", s = s ? "1" : "0") : s instanceof Date ? (o = "dateTime.tz", s = s.toISOString()) : s = String(s), i.push(be(wy(a), s, { "dt:dt": o }));
    }
  }), "<" + n + ' xmlns="' + Or.o + '">' + i.join("") + "</" + n + ">";
}
function oP(e) {
  var t = typeof e == "string" ? new Date(Date.parse(e)) : e, r = t.getTime() / 1e3 + 11644473600, n = r % Math.pow(2, 32), i = (r - n) / Math.pow(2, 32);
  n *= 1e7, i *= 1e7;
  var a = n / Math.pow(2, 32) | 0;
  a > 0 && (n = n % Math.pow(2, 32), i += a);
  var s = ve(8);
  return s.write_shift(4, n), s.write_shift(4, i), s;
}
function Dy(e, t) {
  var r = ve(4), n = ve(4);
  switch (r.write_shift(4, e == 80 ? 31 : e), e) {
    case 3:
      n.write_shift(-4, t);
      break;
    case 5:
      n = ve(8), n.write_shift(8, t, "f");
      break;
    case 11:
      n.write_shift(4, t ? 1 : 0);
      break;
    case 64:
      n = oP(t);
      break;
    case 31:
    case 80:
      for (n = ve(4 + 2 * (t.length + 1) + (t.length % 2 ? 0 : 2)), n.write_shift(4, t.length + 1), n.write_shift(0, t, "dbcs"); n.l != n.length; ) n.write_shift(1, 0);
      break;
    default:
      throw new Error("TypedPropertyValue unrecognized type " + e + " " + t);
  }
  return Wt([r, n]);
}
var Qw = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
function cP(e) {
  switch (typeof e) {
    case "boolean":
      return 11;
    case "number":
      return (e | 0) == e ? 3 : 5;
    case "string":
      return 31;
    case "object":
      if (e instanceof Date) return 64;
      break;
  }
  return -1;
}
function ky(e, t, r) {
  var n = ve(8), i = [], a = [], s = 8, o = 0, c = ve(8), u = ve(8);
  if (c.write_shift(4, 2), c.write_shift(4, 1200), u.write_shift(4, 1), a.push(c), i.push(u), s += 8 + c.length, !t) {
    u = ve(8), u.write_shift(4, 0), i.unshift(u);
    var l = [ve(4)];
    for (l[0].write_shift(4, e.length), o = 0; o < e.length; ++o) {
      var d = e[o][0];
      for (c = ve(8 + 2 * (d.length + 1) + (d.length % 2 ? 0 : 2)), c.write_shift(4, o + 2), c.write_shift(4, d.length + 1), c.write_shift(0, d, "dbcs"); c.l != c.length; ) c.write_shift(1, 0);
      l.push(c);
    }
    c = Wt(l), a.unshift(c), s += 8 + c.length;
  }
  for (o = 0; o < e.length; ++o)
    if (!(t && !t[e[o][0]]) && !(Qw.indexOf(e[o][0]) > -1 || Kw.indexOf(e[o][0]) > -1) && e[o][1] != null) {
      var f = e[o][1], p = 0;
      if (t) {
        p = +t[e[o][0]];
        var v = r[p];
        if (v.p == "version" && typeof f == "string") {
          var m = f.split(".");
          f = (+m[0] << 16) + (+m[1] || 0);
        }
        c = Dy(v.t, f);
      } else {
        var h = cP(f);
        h == -1 && (h = 31, f = String(f)), c = Dy(h, f);
      }
      a.push(c), u = ve(8), u.write_shift(4, t ? p : 2 + o), i.push(u), s += 8 + c.length;
    }
  var _ = 8 * (a.length + 1);
  for (o = 0; o < a.length; ++o)
    i[o].write_shift(4, _), _ += a[o].length;
  return n.write_shift(4, s), n.write_shift(4, a.length), Wt([n].concat(i).concat(a));
}
function Ly(e, t, r, n, i, a) {
  var s = ve(i ? 68 : 48), o = [s];
  s.write_shift(2, 65534), s.write_shift(2, 0), s.write_shift(4, 842412599), s.write_shift(16, xt.utils.consts.HEADER_CLSID, "hex"), s.write_shift(4, i ? 2 : 1), s.write_shift(16, t, "hex"), s.write_shift(4, i ? 68 : 48);
  var c = ky(e, r, n);
  if (o.push(c), i) {
    var u = ky(i, null, null);
    s.write_shift(16, a, "hex"), s.write_shift(4, 68 + c.length), o.push(u);
  }
  return Wt(o);
}
function lP(e, t) {
  t || (t = ve(e));
  for (var r = 0; r < e; ++r) t.write_shift(1, 0);
  return t;
}
function uP(e, t) {
  return e.read_shift(t) === 1;
}
function ur(e, t) {
  return t || (t = ve(2)), t.write_shift(2, +!!e), t;
}
function Zw(e) {
  return e.read_shift(2, "u");
}
function Dr(e, t) {
  return t || (t = ve(2)), t.write_shift(2, e), t;
}
function ex(e, t, r) {
  return r || (r = ve(2)), r.write_shift(1, t == "e" ? +e : +!!e), r.write_shift(1, t == "e" ? 1 : 0), r;
}
function tx(e, t, r) {
  var n = e.read_shift(r && r.biff >= 12 ? 2 : 1), i = "sbcs-cont";
  if (r && r.biff >= 8, !r || r.biff == 8) {
    var a = e.read_shift(1);
    a && (i = "dbcs-cont");
  } else r.biff == 12 && (i = "wstr");
  r.biff >= 2 && r.biff <= 5 && (i = "cpstr");
  var s = n ? e.read_shift(n, i) : "";
  return s;
}
function fP(e) {
  var t = e.t || "", r = ve(3);
  r.write_shift(2, t.length), r.write_shift(1, 1);
  var n = ve(2 * t.length);
  n.write_shift(2 * t.length, t, "utf16le");
  var i = [r, n];
  return Wt(i);
}
function dP(e, t, r) {
  var n;
  if (r) {
    if (r.biff >= 2 && r.biff <= 5) return e.read_shift(t, "cpstr");
    if (r.biff >= 12) return e.read_shift(t, "dbcs-cont");
  }
  var i = e.read_shift(1);
  return i === 0 ? n = e.read_shift(t, "sbcs-cont") : n = e.read_shift(t, "dbcs-cont"), n;
}
function hP(e, t, r) {
  var n = e.read_shift(r && r.biff == 2 ? 1 : 2);
  return n === 0 ? (e.l++, "") : dP(e, n, r);
}
function pP(e, t, r) {
  if (r.biff > 5) return hP(e, t, r);
  var n = e.read_shift(1);
  return n === 0 ? (e.l++, "") : e.read_shift(n, r.biff <= 4 || !e.lens ? "cpstr" : "sbcs-cont");
}
function rx(e, t, r) {
  return r || (r = ve(3 + 2 * e.length)), r.write_shift(2, e.length), r.write_shift(1, 1), r.write_shift(31, e, "utf16le"), r;
}
function My(e, t) {
  t || (t = ve(6 + e.length * 2)), t.write_shift(4, 1 + e.length);
  for (var r = 0; r < e.length; ++r) t.write_shift(2, e.charCodeAt(r));
  return t.write_shift(2, 0), t;
}
function mP(e) {
  var t = ve(512), r = 0, n = e.Target;
  n.slice(0, 7) == "file://" && (n = n.slice(7));
  var i = n.indexOf("#"), a = i > -1 ? 31 : 23;
  switch (n.charAt(0)) {
    case "#":
      a = 28;
      break;
    case ".":
      a &= -3;
      break;
  }
  t.write_shift(4, 2), t.write_shift(4, a);
  var s = [8, 6815827, 6619237, 4849780, 83];
  for (r = 0; r < s.length; ++r) t.write_shift(4, s[r]);
  if (a == 28)
    n = n.slice(1), My(n, t);
  else if (a & 2) {
    for (s = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), r = 0; r < s.length; ++r) t.write_shift(1, parseInt(s[r], 16));
    var o = i > -1 ? n.slice(0, i) : n;
    for (t.write_shift(4, 2 * (o.length + 1)), r = 0; r < o.length; ++r) t.write_shift(2, o.charCodeAt(r));
    t.write_shift(2, 0), a & 8 && My(i > -1 ? n.slice(i + 1) : "", t);
  } else {
    for (s = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" "), r = 0; r < s.length; ++r) t.write_shift(1, parseInt(s[r], 16));
    for (var c = 0; n.slice(c * 3, c * 3 + 3) == "../" || n.slice(c * 3, c * 3 + 3) == "..\\"; ) ++c;
    for (t.write_shift(2, c), t.write_shift(4, n.length - 3 * c + 1), r = 0; r < n.length - 3 * c; ++r) t.write_shift(1, n.charCodeAt(r + 3 * c) & 255);
    for (t.write_shift(1, 0), t.write_shift(2, 65535), t.write_shift(2, 57005), r = 0; r < 6; ++r) t.write_shift(4, 0);
  }
  return t.slice(0, t.l);
}
function vi(e, t, r, n) {
  return n || (n = ve(6)), n.write_shift(2, e), n.write_shift(2, t), n.write_shift(2, r || 0), n;
}
function gP(e, t, r) {
  var n = r.biff > 8 ? 4 : 2, i = e.read_shift(n), a = e.read_shift(n, "i"), s = e.read_shift(n, "i");
  return [i, a, s];
}
function vP(e) {
  var t = e.read_shift(2), r = e.read_shift(2), n = e.read_shift(2), i = e.read_shift(2);
  return { s: { c: n, r: t }, e: { c: i, r } };
}
function nx(e, t) {
  return t || (t = ve(8)), t.write_shift(2, e.s.r), t.write_shift(2, e.e.r), t.write_shift(2, e.s.c), t.write_shift(2, e.e.c), t;
}
function rh(e, t, r) {
  var n = 1536, i = 16;
  switch (r.bookType) {
    case "biff8":
      break;
    case "biff5":
      n = 1280, i = 8;
      break;
    case "biff4":
      n = 4, i = 6;
      break;
    case "biff3":
      n = 3, i = 6;
      break;
    case "biff2":
      n = 2, i = 4;
      break;
    case "xla":
      break;
    default:
      throw new Error("unsupported BIFF version");
  }
  var a = ve(i);
  return a.write_shift(2, n), a.write_shift(2, t), i > 4 && a.write_shift(2, 29282), i > 6 && a.write_shift(2, 1997), i > 8 && (a.write_shift(2, 49161), a.write_shift(2, 1), a.write_shift(2, 1798), a.write_shift(2, 0)), a;
}
function _P(e, t) {
  var r = !t || t.biff == 8, n = ve(r ? 112 : 54);
  for (n.write_shift(t.biff == 8 ? 2 : 1, 7), r && n.write_shift(1, 0), n.write_shift(4, 859007059), n.write_shift(4, 5458548 | (r ? 0 : 536870912)); n.l < n.length; ) n.write_shift(1, r ? 0 : 32);
  return n;
}
function yP(e, t) {
  var r = !t || t.biff >= 8 ? 2 : 1, n = ve(8 + r * e.name.length);
  n.write_shift(4, e.pos), n.write_shift(1, e.hs || 0), n.write_shift(1, e.dt), n.write_shift(1, e.name.length), t.biff >= 8 && n.write_shift(1, 1), n.write_shift(r * e.name.length, e.name, t.biff < 8 ? "sbcs" : "utf16le");
  var i = n.slice(0, n.l);
  return i.l = n.l, i;
}
function EP(e, t) {
  var r = ve(8);
  r.write_shift(4, e.Count), r.write_shift(4, e.Unique);
  for (var n = [], i = 0; i < e.length; ++i) n[i] = fP(e[i]);
  var a = Wt([r].concat(n));
  return a.parts = [r.length].concat(n.map(function(s) {
    return s.length;
  })), a;
}
function wP() {
  var e = ve(18);
  return e.write_shift(2, 0), e.write_shift(2, 0), e.write_shift(2, 29280), e.write_shift(2, 17600), e.write_shift(2, 56), e.write_shift(2, 0), e.write_shift(2, 0), e.write_shift(2, 1), e.write_shift(2, 500), e;
}
function xP(e) {
  var t = ve(18), r = 1718;
  return e && e.RTL && (r |= 64), t.write_shift(2, r), t.write_shift(4, 0), t.write_shift(4, 64), t.write_shift(4, 0), t.write_shift(4, 0), t;
}
function TP(e, t) {
  var r = e.name || "Arial", n = t && t.biff == 5, i = n ? 15 + r.length : 16 + 2 * r.length, a = ve(i);
  return a.write_shift(2, e.sz * 20), a.write_shift(4, 0), a.write_shift(2, 400), a.write_shift(4, 0), a.write_shift(2, 0), a.write_shift(1, r.length), n || a.write_shift(1, 1), a.write_shift((n ? 1 : 2) * r.length, r, n ? "sbcs" : "utf16le"), a;
}
function SP(e, t, r, n) {
  var i = ve(10);
  return vi(e, t, n, i), i.write_shift(4, r), i;
}
function AP(e, t, r, n, i) {
  var a = !i || i.biff == 8, s = ve(8 + +a + (1 + a) * r.length);
  return vi(e, t, n, s), s.write_shift(2, r.length), a && s.write_shift(1, 1), s.write_shift((1 + a) * r.length, r, a ? "utf16le" : "sbcs"), s;
}
function RP(e, t, r, n) {
  var i = r && r.biff == 5;
  n || (n = ve(i ? 3 + t.length : 5 + 2 * t.length)), n.write_shift(2, e), n.write_shift(i ? 1 : 2, t.length), i || n.write_shift(1, 1), n.write_shift((i ? 1 : 2) * t.length, t, i ? "sbcs" : "utf16le");
  var a = n.length > n.l ? n.slice(0, n.l) : n;
  return a.l == null && (a.l = a.length), a;
}
function $P(e, t) {
  var r = t.biff == 8 || !t.biff ? 4 : 2, n = ve(2 * r + 6);
  return n.write_shift(r, e.s.r), n.write_shift(r, e.e.r + 1), n.write_shift(2, e.s.c), n.write_shift(2, e.e.c + 1), n.write_shift(2, 0), n;
}
function Uy(e, t, r, n) {
  var i = r && r.biff == 5;
  n || (n = ve(i ? 16 : 20)), n.write_shift(2, 0), e.style ? (n.write_shift(2, e.numFmtId || 0), n.write_shift(2, 65524)) : (n.write_shift(2, e.numFmtId || 0), n.write_shift(2, t << 4));
  var a = 0;
  return e.numFmtId > 0 && i && (a |= 1024), n.write_shift(4, a), n.write_shift(4, 0), i || n.write_shift(4, 0), n.write_shift(2, 0), n;
}
function OP(e) {
  var t = ve(8);
  return t.write_shift(4, 0), t.write_shift(2, 0), t.write_shift(2, 0), t;
}
function NP(e, t, r, n, i, a) {
  var s = ve(8);
  return vi(e, t, n, s), ex(r, a, s), s;
}
function PP(e, t, r, n) {
  var i = ve(14);
  return vi(e, t, n, i), gi(r, i), i;
}
function CP(e, t, r) {
  if (r.biff < 8) return IP(e, t, r);
  for (var n = [], i = e.l + t, a = e.read_shift(r.biff > 8 ? 4 : 2); a-- !== 0; ) n.push(gP(e, r.biff > 8 ? 12 : 6, r));
  if (e.l != i) throw new Error("Bad ExternSheet: " + e.l + " != " + i);
  return n;
}
function IP(e, t, r) {
  e[e.l + 1] == 3 && e[e.l]++;
  var n = tx(e, t, r);
  return n.charCodeAt(0) == 3 ? n.slice(1) : n;
}
function bP(e) {
  var t = ve(2 + e.length * 8);
  t.write_shift(2, e.length);
  for (var r = 0; r < e.length; ++r) nx(e[r], t);
  return t;
}
function FP(e) {
  var t = ve(24), r = qt(e[0]);
  t.write_shift(2, r.r), t.write_shift(2, r.r), t.write_shift(2, r.c), t.write_shift(2, r.c);
  for (var n = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), i = 0; i < 16; ++i) t.write_shift(1, parseInt(n[i], 16));
  return Wt([t, mP(e[1])]);
}
function DP(e) {
  var t = e[1].Tooltip, r = ve(10 + 2 * (t.length + 1));
  r.write_shift(2, 2048);
  var n = qt(e[0]);
  r.write_shift(2, n.r), r.write_shift(2, n.r), r.write_shift(2, n.c), r.write_shift(2, n.c);
  for (var i = 0; i < t.length; ++i) r.write_shift(2, t.charCodeAt(i));
  return r.write_shift(2, 0), r;
}
function kP(e) {
  return e || (e = ve(4)), e.write_shift(2, 1), e.write_shift(2, 1), e;
}
function LP(e, t, r) {
  if (!r.cellStyles) return on(e, t);
  var n = r && r.biff >= 12 ? 4 : 2, i = e.read_shift(n), a = e.read_shift(n), s = e.read_shift(n), o = e.read_shift(n), c = e.read_shift(2);
  n == 2 && (e.l += 2);
  var u = { s: i, e: a, w: s, ixfe: o, flags: c };
  return (r.biff >= 5 || !r.biff) && (u.level = c >> 8 & 7), u;
}
function MP(e, t) {
  var r = ve(12);
  r.write_shift(2, t), r.write_shift(2, t), r.write_shift(2, e.width * 256), r.write_shift(2, 0);
  var n = 0;
  return e.hidden && (n |= 1), r.write_shift(1, n), n = e.level || 0, r.write_shift(1, n), r.write_shift(2, 0), r;
}
function UP(e) {
  for (var t = ve(2 * e), r = 0; r < e; ++r) t.write_shift(2, r + 1);
  return t;
}
function qP(e, t, r) {
  var n = ve(15);
  return fs(n, e, t), n.write_shift(8, r, "f"), n;
}
function BP(e, t, r) {
  var n = ve(9);
  return fs(n, e, t), n.write_shift(2, r), n;
}
var jP = /* @__PURE__ */ (function() {
  var e = {
    /* Code Pages Supported by Visual FoxPro */
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /* shapefile DBF extension */
    /*::[*/
    0: 20127,
    /*::[*/
    8: 865,
    /*::[*/
    9: 437,
    /*::[*/
    10: 850,
    /*::[*/
    11: 437,
    /*::[*/
    13: 437,
    /*::[*/
    14: 850,
    /*::[*/
    15: 437,
    /*::[*/
    16: 850,
    /*::[*/
    17: 437,
    /*::[*/
    18: 850,
    /*::[*/
    19: 932,
    /*::[*/
    20: 850,
    /*::[*/
    21: 437,
    /*::[*/
    22: 850,
    /*::[*/
    23: 865,
    /*::[*/
    24: 437,
    /*::[*/
    25: 437,
    /*::[*/
    26: 850,
    /*::[*/
    27: 437,
    /*::[*/
    28: 863,
    /*::[*/
    29: 850,
    /*::[*/
    31: 852,
    /*::[*/
    34: 852,
    /*::[*/
    35: 852,
    /*::[*/
    36: 860,
    /*::[*/
    37: 850,
    /*::[*/
    38: 866,
    /*::[*/
    55: 850,
    /*::[*/
    64: 852,
    /*::[*/
    77: 936,
    /*::[*/
    78: 949,
    /*::[*/
    79: 950,
    /*::[*/
    80: 874,
    /*::[*/
    87: 1252,
    /*::[*/
    88: 1252,
    /*::[*/
    89: 1252,
    /*::[*/
    108: 863,
    /*::[*/
    134: 737,
    /*::[*/
    135: 852,
    /*::[*/
    136: 857,
    /*::[*/
    204: 1257,
    /*::[*/
    255: 16969
  }, t = G0({
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /*::[*/
    0: 20127
  });
  function r(o, c) {
    var u = [], l = mi(1);
    switch (c.type) {
      case "base64":
        l = Gr(Sn(o));
        break;
      case "binary":
        l = Gr(o);
        break;
      case "buffer":
      case "array":
        l = o;
        break;
    }
    $r(l, 0);
    var d = l.read_shift(1), f = !!(d & 136), p = !1, v = !1;
    switch (d) {
      case 2:
        break;
      // dBASE II
      case 3:
        break;
      // dBASE III
      case 48:
        p = !0, f = !0;
        break;
      // VFP
      case 49:
        p = !0, f = !0;
        break;
      // VFP with autoincrement
      // 0x43 dBASE IV SQL table files
      // 0x63 dBASE IV SQL system files
      case 131:
        break;
      // dBASE III with memo
      case 139:
        break;
      // dBASE IV with memo
      case 140:
        v = !0;
        break;
      // dBASE Level 7 with memo
      // case 0xCB dBASE IV SQL table files with memo
      case 245:
        break;
      // FoxPro 2.x with memo
      // case 0xFB FoxBASE
      default:
        throw new Error("DBF Unsupported Version: " + d.toString(16));
    }
    var m = 0, h = 521;
    d == 2 && (m = l.read_shift(2)), l.l += 3, d != 2 && (m = l.read_shift(4)), m > 1048576 && (m = 1e6), d != 2 && (h = l.read_shift(2));
    var _ = l.read_shift(2), g = c.codepage || 1252;
    d != 2 && (l.l += 16, l.read_shift(1), l[l.l] !== 0 && (g = e[l[l.l]]), l.l += 1, l.l += 2), v && (l.l += 36);
    for (var y = [], x = {}, S = Math.min(l.length, d == 2 ? 521 : h - 10 - (p ? 264 : 0)), w = v ? 32 : 11; l.l < S && l[l.l] != 13; )
      switch (x = {}, x.name = Fc.utils.decode(g, l.slice(l.l, l.l + w)).replace(/[\u0000\r\n].*$/g, ""), l.l += w, x.type = String.fromCharCode(l.read_shift(1)), d != 2 && !v && (x.offset = l.read_shift(4)), x.len = l.read_shift(1), d == 2 && (x.offset = l.read_shift(2)), x.dec = l.read_shift(1), x.name.length && y.push(x), d != 2 && (l.l += v ? 13 : 14), x.type) {
        case "B":
          (!p || x.len != 8) && c.WTF && console.log("Skipping " + x.name + ":" + x.type);
          break;
        case "G":
        // General (FoxPro and dBASE L7)
        case "P":
          c.WTF && console.log("Skipping " + x.name + ":" + x.type);
          break;
        case "+":
        // Autoincrement (dBASE L7 only)
        case "0":
        // _NullFlags (VFP only)
        case "@":
        // Timestamp (dBASE L7 only)
        case "C":
        // Character (dBASE II)
        case "D":
        // Date (dBASE III)
        case "F":
        // Float (dBASE IV)
        case "I":
        // Long (VFP and dBASE L7)
        case "L":
        // Logical (dBASE II)
        case "M":
        // Memo (dBASE III)
        case "N":
        // Number (dBASE II)
        case "O":
        // Double (dBASE L7 only)
        case "T":
        // Datetime (VFP only)
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + x.type);
      }
    if (l[l.l] !== 13 && (l.l = h - 1), l.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + l.l + " " + l[l.l]);
    l.l = h;
    var E = 0, R = 0;
    for (u[0] = [], R = 0; R != y.length; ++R) u[0][R] = y[R].name;
    for (; m-- > 0; ) {
      if (l[l.l] === 42) {
        l.l += _;
        continue;
      }
      for (++l.l, u[++E] = [], R = 0, R = 0; R != y.length; ++R) {
        var N = l.slice(l.l, l.l + y[R].len);
        l.l += y[R].len, $r(N, 0);
        var B = Fc.utils.decode(g, N);
        switch (y[R].type) {
          case "C":
            B.trim().length && (u[E][R] = B.replace(/\s+$/, ""));
            break;
          case "D":
            B.length === 8 ? u[E][R] = new Date(+B.slice(0, 4), +B.slice(4, 6) - 1, +B.slice(6, 8)) : u[E][R] = B;
            break;
          case "F":
            u[E][R] = parseFloat(B.trim());
            break;
          case "+":
          case "I":
            u[E][R] = v ? N.read_shift(-4, "i") ^ 2147483648 : N.read_shift(4, "i");
            break;
          case "L":
            switch (B.trim().toUpperCase()) {
              case "Y":
              case "T":
                u[E][R] = !0;
                break;
              case "N":
              case "F":
                u[E][R] = !1;
                break;
              case "":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + B + "|");
            }
            break;
          case "M":
            if (!f) throw new Error("DBF Unexpected MEMO for type " + d.toString(16));
            u[E][R] = "##MEMO##" + (v ? parseInt(B.trim(), 10) : N.read_shift(4));
            break;
          case "N":
            B = B.replace(/\u0000/g, "").trim(), B && B != "." && (u[E][R] = +B || 0);
            break;
          case "@":
            u[E][R] = new Date(N.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            u[E][R] = new Date((N.read_shift(4) - 2440588) * 864e5 + N.read_shift(4));
            break;
          case "Y":
            u[E][R] = N.read_shift(4, "i") / 1e4 + N.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            u[E][R] = -N.read_shift(-8, "f");
            break;
          case "B":
            if (p && y[R].len == 8) {
              u[E][R] = N.read_shift(8, "f");
              break;
            }
          /* falls through */
          case "G":
          case "P":
            N.l += y[R].len;
            break;
          case "0":
            if (y[R].name === "_NullFlags") break;
          /* falls through */
          default:
            throw new Error("DBF Unsupported data type " + y[R].type);
        }
      }
    }
    if (d != 2 && l.l < l.length && l[l.l++] != 26) throw new Error("DBF EOF Marker missing " + (l.l - 1) + " of " + l.length + " " + l[l.l - 1].toString(16));
    return c && c.sheetRows && (u = u.slice(0, c.sheetRows)), c.DBF = y, u;
  }
  function n(o, c) {
    var u = c || {};
    u.dateNF || (u.dateNF = "yyyymmdd");
    var l = na(r(o, u), u);
    return l["!cols"] = u.DBF.map(function(d) {
      return {
        wch: d.len,
        DBF: d
      };
    }), delete u.DBF, l;
  }
  function i(o, c) {
    try {
      return wi(n(o, c), c);
    } catch (u) {
      if (c && c.WTF) throw u;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var a = { B: 8, C: 250, L: 1, D: 8, "?": 0, "": 0 };
  function s(o, c) {
    var u = c || {};
    if (+u.codepage >= 0 && Wa(+u.codepage), u.type == "string") throw new Error("Cannot write DBF to JS string");
    var l = vr(), d = Wc(o, { header: 1, raw: !0, cellDates: !0 }), f = d[0], p = d.slice(1), v = o["!cols"] || [], m = 0, h = 0, _ = 0, g = 1;
    for (m = 0; m < f.length; ++m) {
      if (((v[m] || {}).DBF || {}).name) {
        f[m] = v[m].DBF.name, ++_;
        continue;
      }
      if (f[m] != null) {
        if (++_, typeof f[m] == "number" && (f[m] = f[m].toString(10)), typeof f[m] != "string") throw new Error("DBF Invalid column name " + f[m] + " |" + typeof f[m] + "|");
        if (f.indexOf(f[m]) !== m) {
          for (h = 0; h < 1024; ++h)
            if (f.indexOf(f[m] + "_" + h) == -1) {
              f[m] += "_" + h;
              break;
            }
        }
      }
    }
    var y = At(o["!ref"]), x = [], S = [], w = [];
    for (m = 0; m <= y.e.c - y.s.c; ++m) {
      var E = "", R = "", N = 0, B = [];
      for (h = 0; h < p.length; ++h)
        p[h][m] != null && B.push(p[h][m]);
      if (B.length == 0 || f[m] == null) {
        x[m] = "?";
        continue;
      }
      for (h = 0; h < B.length; ++h) {
        switch (typeof B[h]) {
          /* TODO: check if L2 compat is desired */
          case "number":
            R = "B";
            break;
          case "string":
            R = "C";
            break;
          case "boolean":
            R = "L";
            break;
          case "object":
            R = B[h] instanceof Date ? "D" : "C";
            break;
          default:
            R = "C";
        }
        N = Math.max(N, String(B[h]).length), E = E && E != R ? "C" : R;
      }
      N > 250 && (N = 250), R = ((v[m] || {}).DBF || {}).type, R == "C" && v[m].DBF.len > N && (N = v[m].DBF.len), E == "B" && R == "N" && (E = "N", w[m] = v[m].DBF.dec, N = v[m].DBF.len), S[m] = E == "C" || R == "N" ? N : a[E] || 0, g += S[m], x[m] = E;
    }
    var F = l.next(32);
    for (F.write_shift(4, 318902576), F.write_shift(4, p.length), F.write_shift(2, 296 + 32 * _), F.write_shift(2, g), m = 0; m < 4; ++m) F.write_shift(4, 0);
    for (F.write_shift(4, 0 | (+t[
      /*::String(*/
      aw
      /*::)*/
    ] || 3) << 8), m = 0, h = 0; m < f.length; ++m)
      if (f[m] != null) {
        var U = l.next(32), G = (f[m].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
        U.write_shift(1, G, "sbcs"), U.write_shift(1, x[m] == "?" ? "C" : x[m], "sbcs"), U.write_shift(4, h), U.write_shift(1, S[m] || a[x[m]] || 0), U.write_shift(1, w[m] || 0), U.write_shift(1, 2), U.write_shift(4, 0), U.write_shift(1, 0), U.write_shift(4, 0), U.write_shift(4, 0), h += S[m] || a[x[m]] || 0;
      }
    var M = l.next(264);
    for (M.write_shift(4, 13), m = 0; m < 65; ++m) M.write_shift(4, 0);
    for (m = 0; m < p.length; ++m) {
      var V = l.next(g);
      for (V.write_shift(1, 0), h = 0; h < f.length; ++h)
        if (f[h] != null)
          switch (x[h]) {
            case "L":
              V.write_shift(1, p[m][h] == null ? 63 : p[m][h] ? 84 : 70);
              break;
            case "B":
              V.write_shift(8, p[m][h] || 0, "f");
              break;
            case "N":
              var ie = "0";
              for (typeof p[m][h] == "number" && (ie = p[m][h].toFixed(w[h] || 0)), _ = 0; _ < S[h] - ie.length; ++_) V.write_shift(1, 32);
              V.write_shift(1, ie, "sbcs");
              break;
            case "D":
              p[m][h] ? (V.write_shift(4, ("0000" + p[m][h].getFullYear()).slice(-4), "sbcs"), V.write_shift(2, ("00" + (p[m][h].getMonth() + 1)).slice(-2), "sbcs"), V.write_shift(2, ("00" + p[m][h].getDate()).slice(-2), "sbcs")) : V.write_shift(8, "00000000", "sbcs");
              break;
            case "C":
              var W = String(p[m][h] != null ? p[m][h] : "").slice(0, S[h]);
              for (V.write_shift(1, W, "sbcs"), _ = 0; _ < S[h] - W.length; ++_) V.write_shift(1, 32);
              break;
          }
    }
    return l.next(1).write_shift(1, 26), l.end();
  }
  return {
    to_workbook: i,
    to_sheet: n,
    from_sheet: s
  };
})(), VP = /* @__PURE__ */ (function() {
  var e = {
    AA: "",
    BA: "",
    CA: "",
    DA: 195,
    HA: "",
    JA: 197,
    AE: "",
    BE: "",
    CE: "",
    HE: "",
    AI: "",
    BI: "",
    CI: "",
    HI: "",
    AO: "",
    BO: "",
    CO: "",
    DO: 213,
    HO: "",
    AU: "",
    BU: "",
    CU: "",
    HU: "",
    Aa: "",
    Ba: "",
    Ca: "",
    Da: 227,
    Ha: "",
    Ja: 229,
    Ae: "",
    Be: "",
    Ce: "",
    He: "",
    Ai: "",
    Bi: "",
    Ci: "",
    Hi: "",
    Ao: "",
    Bo: "",
    Co: "",
    Do: 245,
    Ho: "",
    Au: "",
    Bu: "",
    Cu: "",
    Hu: "",
    KC: "",
    Kc: "",
    q: "",
    z: "",
    a: "",
    j: "",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    /*::[*/
    0: 176,
    /*::[*/
    1: 177,
    /*::[*/
    2: 178,
    /*::[*/
    3: 179,
    /*::[*/
    5: 181,
    /*::[*/
    6: 182,
    /*::[*/
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  }, t = new RegExp("\x1BN(" + Yt(e).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm"), r = function(f, p) {
    var v = e[p];
    return typeof v == "number" ? ly(v) : v;
  }, n = function(f, p, v) {
    var m = p.charCodeAt(0) - 32 << 4 | v.charCodeAt(0) - 48;
    return m == 59 ? f : ly(m);
  };
  e["|"] = 254;
  function i(f, p) {
    switch (p.type) {
      case "base64":
        return a(Sn(f), p);
      case "binary":
        return a(f, p);
      case "buffer":
        return a(ft && Buffer.isBuffer(f) ? f.toString("binary") : ss(f), p);
      case "array":
        return a(Sl(f), p);
    }
    throw new Error("Unrecognized type " + p.type);
  }
  function a(f, p) {
    var v = f.split(/[\n\r]+/), m = -1, h = -1, _ = 0, g = 0, y = [], x = [], S = null, w = {}, E = [], R = [], N = [], B = 0, F;
    for (+p.codepage >= 0 && Wa(+p.codepage); _ !== v.length; ++_) {
      B = 0;
      var U = v[_].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, n).replace(t, r), G = U.replace(/;;/g, "\0").split(";").map(function(A) {
        return A.replace(/\u0000/g, ";");
      }), M = G[0], V;
      if (U.length > 0) switch (M) {
        case "ID":
          break;
        /* header */
        case "E":
          break;
        /* EOF */
        case "B":
          break;
        /* dimensions */
        case "O":
          break;
        /* options? */
        case "W":
          break;
        /* window? */
        case "P":
          G[1].charAt(0) == "P" && x.push(U.slice(3).replace(/;;/g, ";"));
          break;
        case "C":
          var ie = !1, W = !1, ae = !1, se = !1, X = -1, k = -1;
          for (g = 1; g < G.length; ++g) switch (G[g].charAt(0)) {
            case "A":
              break;
            // TODO: comment
            case "X":
              h = parseInt(G[g].slice(1)) - 1, W = !0;
              break;
            case "Y":
              for (m = parseInt(G[g].slice(1)) - 1, W || (h = 0), F = y.length; F <= m; ++F) y[F] = [];
              break;
            case "K":
              V = G[g].slice(1), V.charAt(0) === '"' ? V = V.slice(1, V.length - 1) : V === "TRUE" ? V = !0 : V === "FALSE" ? V = !1 : isNaN(wn(V)) ? isNaN(Ka(V).getDate()) || (V = dr(V)) : (V = wn(V), S !== null && vw(S) && (V = ww(V))), ie = !0;
              break;
            case "E":
              se = !0;
              var I = BC(G[g].slice(1), { r: m, c: h });
              y[m][h] = [y[m][h], I];
              break;
            case "S":
              ae = !0, y[m][h] = [y[m][h], "S5S"];
              break;
            case "G":
              break;
            // unknown
            case "R":
              X = parseInt(G[g].slice(1)) - 1;
              break;
            case "C":
              k = parseInt(G[g].slice(1)) - 1;
              break;
            default:
              if (p && p.WTF) throw new Error("SYLK bad record " + U);
          }
          if (ie && (y[m][h] && y[m][h].length == 2 ? y[m][h][0] = V : y[m][h] = V, S = null), ae) {
            if (se) throw new Error("SYLK shared formula cannot have own formula");
            var C = X > -1 && y[X][k];
            if (!C || !C[1]) throw new Error("SYLK shared formula cannot find base");
            y[m][h][1] = jC(C[1], { r: m - X, c: h - k });
          }
          break;
        case "F":
          var T = 0;
          for (g = 1; g < G.length; ++g) switch (G[g].charAt(0)) {
            case "X":
              h = parseInt(G[g].slice(1)) - 1, ++T;
              break;
            case "Y":
              for (m = parseInt(G[g].slice(1)) - 1, F = y.length; F <= m; ++F) y[F] = [];
              break;
            case "M":
              B = parseInt(G[g].slice(1)) / 20;
              break;
            case "F":
              break;
            /* ??? */
            case "G":
              break;
            /* hide grid */
            case "P":
              S = x[parseInt(G[g].slice(1))];
              break;
            case "S":
              break;
            /* cell style */
            case "D":
              break;
            /* column */
            case "N":
              break;
            /* font */
            case "W":
              for (N = G[g].slice(1).split(" "), F = parseInt(N[0], 10); F <= parseInt(N[1], 10); ++F)
                B = parseInt(N[2], 10), R[F - 1] = B === 0 ? { hidden: !0 } : { wch: B }, nh(R[F - 1]);
              break;
            case "C":
              h = parseInt(G[g].slice(1)) - 1, R[h] || (R[h] = {});
              break;
            case "R":
              m = parseInt(G[g].slice(1)) - 1, E[m] || (E[m] = {}), B > 0 ? (E[m].hpt = B, E[m].hpx = cx(B)) : B === 0 && (E[m].hidden = !0);
              break;
            default:
              if (p && p.WTF) throw new Error("SYLK bad record " + U);
          }
          T < 1 && (S = null);
          break;
        default:
          if (p && p.WTF) throw new Error("SYLK bad record " + U);
      }
    }
    return E.length > 0 && (w["!rows"] = E), R.length > 0 && (w["!cols"] = R), p && p.sheetRows && (y = y.slice(0, p.sheetRows)), [y, w];
  }
  function s(f, p) {
    var v = i(f, p), m = v[0], h = v[1], _ = na(m, p);
    return Yt(h).forEach(function(g) {
      _[g] = h[g];
    }), _;
  }
  function o(f, p) {
    return wi(s(f, p), p);
  }
  function c(f, p, v, m) {
    var h = "C;Y" + (v + 1) + ";X" + (m + 1) + ";K";
    switch (f.t) {
      case "n":
        h += f.v || 0, f.f && !f.F && (h += ";E" + ah(f.f, { r: v, c: m }));
        break;
      case "b":
        h += f.v ? "TRUE" : "FALSE";
        break;
      case "e":
        h += f.w || f.v;
        break;
      case "d":
        h += '"' + (f.w || f.v) + '"';
        break;
      case "s":
        h += '"' + f.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return h;
  }
  function u(f, p) {
    p.forEach(function(v, m) {
      var h = "F;W" + (m + 1) + " " + (m + 1) + " ";
      v.hidden ? h += "0" : (typeof v.width == "number" && !v.wpx && (v.wpx = Vc(v.width)), typeof v.wpx == "number" && !v.wch && (v.wch = Hc(v.wpx)), typeof v.wch == "number" && (h += Math.round(v.wch))), h.charAt(h.length - 1) != " " && f.push(h);
    });
  }
  function l(f, p) {
    p.forEach(function(v, m) {
      var h = "F;";
      v.hidden ? h += "M0;" : v.hpt ? h += "M" + 20 * v.hpt + ";" : v.hpx && (h += "M" + 20 * Gc(v.hpx) + ";"), h.length > 2 && f.push(h + "R" + (m + 1));
    });
  }
  function d(f, p) {
    var v = ["ID;PWXL;N;E"], m = [], h = At(f["!ref"]), _, g = Array.isArray(f), y = `\r
`;
    v.push("P;PGeneral"), v.push("F;P0;DG0G8;M255"), f["!cols"] && u(v, f["!cols"]), f["!rows"] && l(v, f["!rows"]), v.push("B;Y" + (h.e.r - h.s.r + 1) + ";X" + (h.e.c - h.s.c + 1) + ";D" + [h.s.c, h.s.r, h.e.c, h.e.r].join(" "));
    for (var x = h.s.r; x <= h.e.r; ++x)
      for (var S = h.s.c; S <= h.e.c; ++S) {
        var w = _t({ r: x, c: S });
        _ = g ? (f[x] || [])[S] : f[w], !(!_ || _.v == null && (!_.f || _.F)) && m.push(c(_, f, x, S));
      }
    return v.join(y) + y + m.join(y) + y + "E" + y;
  }
  return {
    to_workbook: o,
    to_sheet: s,
    from_sheet: d
  };
})(), HP = /* @__PURE__ */ (function() {
  function e(a, s) {
    switch (s.type) {
      case "base64":
        return t(Sn(a), s);
      case "binary":
        return t(a, s);
      case "buffer":
        return t(ft && Buffer.isBuffer(a) ? a.toString("binary") : ss(a), s);
      case "array":
        return t(Sl(a), s);
    }
    throw new Error("Unrecognized type " + s.type);
  }
  function t(a, s) {
    for (var o = a.split(`
`), c = -1, u = -1, l = 0, d = []; l !== o.length; ++l) {
      if (o[l].trim() === "BOT") {
        d[++c] = [], u = 0;
        continue;
      }
      if (!(c < 0)) {
        var f = o[l].trim().split(","), p = f[0], v = f[1];
        ++l;
        for (var m = o[l] || ""; (m.match(/["]/g) || []).length & 1 && l < o.length - 1; ) m += `
` + o[++l];
        switch (m = m.trim(), +p) {
          case -1:
            if (m === "BOT") {
              d[++c] = [], u = 0;
              continue;
            } else if (m !== "EOD") throw new Error("Unrecognized DIF special command " + m);
            break;
          case 0:
            m === "TRUE" ? d[c][u] = !0 : m === "FALSE" ? d[c][u] = !1 : isNaN(wn(v)) ? isNaN(Ka(v).getDate()) ? d[c][u] = v : d[c][u] = dr(v) : d[c][u] = wn(v), ++u;
            break;
          case 1:
            m = m.slice(1, m.length - 1), m = m.replace(/""/g, '"'), m && m.match(/^=".*"$/) && (m = m.slice(2, -1)), d[c][u++] = m !== "" ? m : null;
            break;
        }
        if (m === "EOD") break;
      }
    }
    return s && s.sheetRows && (d = d.slice(0, s.sheetRows)), d;
  }
  function r(a, s) {
    return na(e(a, s), s);
  }
  function n(a, s) {
    return wi(r(a, s), s);
  }
  var i = /* @__PURE__ */ (function() {
    var a = function(c, u, l, d, f) {
      c.push(u), c.push(l + "," + d), c.push('"' + f.replace(/"/g, '""') + '"');
    }, s = function(c, u, l, d) {
      c.push(u + "," + l), c.push(u == 1 ? '"' + d.replace(/"/g, '""') + '"' : d);
    };
    return function(c) {
      var u = [], l = At(c["!ref"]), d, f = Array.isArray(c);
      a(u, "TABLE", 0, 1, "sheetjs"), a(u, "VECTORS", 0, l.e.r - l.s.r + 1, ""), a(u, "TUPLES", 0, l.e.c - l.s.c + 1, ""), a(u, "DATA", 0, 0, "");
      for (var p = l.s.r; p <= l.e.r; ++p) {
        s(u, -1, 0, "BOT");
        for (var v = l.s.c; v <= l.e.c; ++v) {
          var m = _t({ r: p, c: v });
          if (d = f ? (c[p] || [])[v] : c[m], !d) {
            s(u, 1, 0, "");
            continue;
          }
          switch (d.t) {
            case "n":
              var h = d.w;
              !h && d.v != null && (h = d.v), h == null ? d.f && !d.F ? s(u, 1, 0, "=" + d.f) : s(u, 1, 0, "") : s(u, 0, h, "V");
              break;
            case "b":
              s(u, 0, d.v ? 1 : 0, d.v ? "TRUE" : "FALSE");
              break;
            case "s":
              s(u, 1, 0, isNaN(d.v) ? d.v : '="' + d.v + '"');
              break;
            case "d":
              d.w || (d.w = Vn(d.z || It[14], _r(dr(d.v)))), s(u, 0, d.w, "V");
              break;
            default:
              s(u, 1, 0, "");
          }
        }
      }
      s(u, -1, 0, "EOD");
      var _ = `\r
`, g = u.join(_);
      return g;
    };
  })();
  return {
    to_workbook: n,
    to_sheet: r,
    from_sheet: i
  };
})(), ix = /* @__PURE__ */ (function() {
  function e(d) {
    return d.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, `
`);
  }
  function t(d) {
    return d.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function r(d, f) {
    for (var p = d.split(`
`), v = -1, m = -1, h = 0, _ = []; h !== p.length; ++h) {
      var g = p[h].trim().split(":");
      if (g[0] === "cell") {
        var y = qt(g[1]);
        if (_.length <= y.r) for (v = _.length; v <= y.r; ++v) _[v] || (_[v] = []);
        switch (v = y.r, m = y.c, g[2]) {
          case "t":
            _[v][m] = e(g[3]);
            break;
          case "v":
            _[v][m] = +g[3];
            break;
          case "vtf":
            var x = g[g.length - 1];
          /* falls through */
          case "vtc":
            switch (g[3]) {
              case "nl":
                _[v][m] = !!+g[4];
                break;
              default:
                _[v][m] = +g[4];
                break;
            }
            g[2] == "vtf" && (_[v][m] = [_[v][m], x]);
        }
      }
    }
    return f && f.sheetRows && (_ = _.slice(0, f.sheetRows)), _;
  }
  function n(d, f) {
    return na(r(d, f), f);
  }
  function i(d, f) {
    return wi(n(d, f), f);
  }
  var a = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join(`
`), s = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join(`
`) + `
`, o = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join(`
`), c = "--SocialCalcSpreadsheetControlSave--";
  function u(d) {
    if (!d || !d["!ref"]) return "";
    for (var f = [], p = [], v, m = "", h = Pr(d["!ref"]), _ = Array.isArray(d), g = h.s.r; g <= h.e.r; ++g)
      for (var y = h.s.c; y <= h.e.c; ++y)
        if (m = _t({ r: g, c: y }), v = _ ? (d[g] || [])[y] : d[m], !(!v || v.v == null || v.t === "z")) {
          switch (p = ["cell", m, "t"], v.t) {
            case "s":
            case "str":
              p.push(t(v.v));
              break;
            case "n":
              v.f ? (p[2] = "vtf", p[3] = "n", p[4] = v.v, p[5] = t(v.f)) : (p[2] = "v", p[3] = v.v);
              break;
            case "b":
              p[2] = "vt" + (v.f ? "f" : "c"), p[3] = "nl", p[4] = v.v ? "1" : "0", p[5] = t(v.f || (v.v ? "TRUE" : "FALSE"));
              break;
            case "d":
              var x = _r(dr(v.v));
              p[2] = "vtc", p[3] = "nd", p[4] = "" + x, p[5] = v.w || Vn(v.z || It[14], x);
              break;
            case "e":
              continue;
          }
          f.push(p.join(":"));
        }
    return f.push("sheet:c:" + (h.e.c - h.s.c + 1) + ":r:" + (h.e.r - h.s.r + 1) + ":tvf:1"), f.push("valueformat:1:text-wiki"), f.join(`
`);
  }
  function l(d) {
    return [a, s, o, s, u(d), c].join(`
`);
  }
  return {
    to_workbook: i,
    to_sheet: n,
    from_sheet: l
  };
})(), GP = /* @__PURE__ */ (function() {
  function e(l, d, f, p, v) {
    v.raw ? d[f][p] = l : l === "" || (l === "TRUE" ? d[f][p] = !0 : l === "FALSE" ? d[f][p] = !1 : isNaN(wn(l)) ? isNaN(Ka(l).getDate()) ? d[f][p] = l : d[f][p] = dr(l) : d[f][p] = wn(l));
  }
  function t(l, d) {
    var f = d || {}, p = [];
    if (!l || l.length === 0) return p;
    for (var v = l.split(/[\r\n]/), m = v.length - 1; m >= 0 && v[m].length === 0; ) --m;
    for (var h = 10, _ = 0, g = 0; g <= m; ++g)
      _ = v[g].indexOf(" "), _ == -1 ? _ = v[g].length : _++, h = Math.max(h, _);
    for (g = 0; g <= m; ++g) {
      p[g] = [];
      var y = 0;
      for (e(v[g].slice(0, h).trim(), p, g, y, f), y = 1; y <= (v[g].length - h) / 10 + 1; ++y)
        e(v[g].slice(h + (y - 1) * 10, h + y * 10).trim(), p, g, y, f);
    }
    return f.sheetRows && (p = p.slice(0, f.sheetRows)), p;
  }
  var r = {
    /*::[*/
    44: ",",
    /*::[*/
    9: "	",
    /*::[*/
    59: ";",
    /*::[*/
    124: "|"
  }, n = {
    /*::[*/
    44: 3,
    /*::[*/
    9: 2,
    /*::[*/
    59: 1,
    /*::[*/
    124: 0
  };
  function i(l) {
    for (var d = {}, f = !1, p = 0, v = 0; p < l.length; ++p)
      (v = l.charCodeAt(p)) == 34 ? f = !f : !f && v in r && (d[v] = (d[v] || 0) + 1);
    v = [];
    for (p in d) Object.prototype.hasOwnProperty.call(d, p) && v.push([d[p], p]);
    if (!v.length) {
      d = n;
      for (p in d) Object.prototype.hasOwnProperty.call(d, p) && v.push([d[p], p]);
    }
    return v.sort(function(m, h) {
      return m[0] - h[0] || n[m[1]] - n[h[1]];
    }), r[v.pop()[1]] || 44;
  }
  function a(l, d) {
    var f = d || {}, p = "", v = f.dense ? [] : {}, m = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    l.slice(0, 4) == "sep=" ? l.charCodeAt(5) == 13 && l.charCodeAt(6) == 10 ? (p = l.charAt(4), l = l.slice(7)) : l.charCodeAt(5) == 13 || l.charCodeAt(5) == 10 ? (p = l.charAt(4), l = l.slice(6)) : p = i(l.slice(0, 1024)) : f && f.FS ? p = f.FS : p = i(l.slice(0, 1024));
    var h = 0, _ = 0, g = 0, y = 0, x = 0, S = p.charCodeAt(0), w = !1, E = 0, R = l.charCodeAt(0);
    l = l.replace(/\r\n/mg, `
`);
    var N = f.dateNF != null ? oN(f.dateNF) : null;
    function B() {
      var F = l.slice(y, x), U = {};
      if (F.charAt(0) == '"' && F.charAt(F.length - 1) == '"' && (F = F.slice(1, -1).replace(/""/g, '"')), F.length === 0) U.t = "z";
      else if (f.raw)
        U.t = "s", U.v = F;
      else if (F.trim().length === 0)
        U.t = "s", U.v = F;
      else if (F.charCodeAt(0) == 61)
        F.charCodeAt(1) == 34 && F.charCodeAt(F.length - 1) == 34 ? (U.t = "s", U.v = F.slice(2, -1).replace(/""/g, '"')) : VC(F) ? (U.t = "n", U.f = F.slice(1)) : (U.t = "s", U.v = F);
      else if (F == "TRUE")
        U.t = "b", U.v = !0;
      else if (F == "FALSE")
        U.t = "b", U.v = !1;
      else if (!isNaN(g = wn(F)))
        U.t = "n", f.cellText !== !1 && (U.w = F), U.v = g;
      else if (!isNaN(Ka(F).getDate()) || N && F.match(N)) {
        U.z = f.dateNF || It[14];
        var G = 0;
        N && F.match(N) && (F = cN(F, f.dateNF, F.match(N) || []), G = 1), f.cellDates ? (U.t = "d", U.v = dr(F, G)) : (U.t = "n", U.v = _r(dr(F, G))), f.cellText !== !1 && (U.w = Vn(U.z, U.v instanceof Date ? _r(U.v) : U.v)), f.cellNF || delete U.z;
      } else
        U.t = "s", U.v = F;
      if (U.t == "z" || (f.dense ? (v[h] || (v[h] = []), v[h][_] = U) : v[_t({ c: _, r: h })] = U), y = x + 1, R = l.charCodeAt(y), m.e.c < _ && (m.e.c = _), m.e.r < h && (m.e.r = h), E == S) ++_;
      else if (_ = 0, ++h, f.sheetRows && f.sheetRows <= h) return !0;
    }
    e: for (; x < l.length; ++x) switch (E = l.charCodeAt(x)) {
      case 34:
        R === 34 && (w = !w);
        break;
      case S:
      case 10:
      case 13:
        if (!w && B()) break e;
        break;
    }
    return x - y > 0 && B(), v["!ref"] = Ft(m), v;
  }
  function s(l, d) {
    return !(d && d.PRN) || d.FS || l.slice(0, 4) == "sep=" || l.indexOf("	") >= 0 || l.indexOf(",") >= 0 || l.indexOf(";") >= 0 ? a(l, d) : na(t(l, d), d);
  }
  function o(l, d) {
    var f = "", p = d.type == "string" ? [0, 0, 0, 0] : n4(l, d);
    switch (d.type) {
      case "base64":
        f = Sn(l);
        break;
      case "binary":
        f = l;
        break;
      case "buffer":
        d.codepage == 65001 ? f = l.toString("utf8") : d.codepage && typeof Fc < "u" || (f = ft && Buffer.isBuffer(l) ? l.toString("binary") : ss(l));
        break;
      case "array":
        f = Sl(l);
        break;
      case "string":
        f = l;
        break;
      default:
        throw new Error("Unrecognized type " + d.type);
    }
    return p[0] == 239 && p[1] == 187 && p[2] == 191 ? f = ja(f.slice(3)) : d.type != "string" && d.type != "buffer" && d.codepage == 65001 ? f = ja(f) : d.type == "binary" && typeof Fc < "u", f.slice(0, 19) == "socialcalc:version:" ? ix.to_sheet(d.type == "string" ? f : ja(f), d) : s(f, d);
  }
  function c(l, d) {
    return wi(o(l, d), d);
  }
  function u(l) {
    for (var d = [], f = At(l["!ref"]), p, v = Array.isArray(l), m = f.s.r; m <= f.e.r; ++m) {
      for (var h = [], _ = f.s.c; _ <= f.e.c; ++_) {
        var g = _t({ r: m, c: _ });
        if (p = v ? (l[m] || [])[_] : l[g], !p || p.v == null) {
          h.push("          ");
          continue;
        }
        for (var y = (p.w || (An(p), p.w) || "").slice(0, 10); y.length < 10; ) y += " ";
        h.push(y + (_ === 0 ? " " : ""));
      }
      d.push(h.join(""));
    }
    return d.join(`
`);
  }
  return {
    to_workbook: c,
    to_sheet: o,
    from_sheet: u
  };
})(), qy = /* @__PURE__ */ (function() {
  function e(I, C, T) {
    if (I) {
      $r(I, I.l || 0);
      for (var A = T.Enum || X; I.l < I.length; ) {
        var L = I.read_shift(2), b = A[L] || A[65535], P = I.read_shift(2), te = I.l + P, H = b.f && b.f(I, P, T);
        if (I.l = te, C(H, b, L)) return;
      }
    }
  }
  function t(I, C) {
    switch (C.type) {
      case "base64":
        return r(Gr(Sn(I)), C);
      case "binary":
        return r(Gr(I), C);
      case "buffer":
      case "array":
        return r(I, C);
    }
    throw "Unsupported type " + C.type;
  }
  function r(I, C) {
    if (!I) return I;
    var T = C || {}, A = T.dense ? [] : {}, L = "Sheet1", b = "", P = 0, te = {}, H = [], D = [], q = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, J = T.sheetRows || 0;
    if (I[2] == 0 && (I[3] == 8 || I[3] == 9) && I.length >= 16 && I[14] == 5 && I[15] === 108)
      throw new Error("Unsupported Works 3 for Mac file");
    if (I[2] == 2)
      T.Enum = X, e(I, function(ge, Ge, ze) {
        switch (ze) {
          case 0:
            T.vers = ge, ge >= 4096 && (T.qpro = !0);
            break;
          case 6:
            q = ge;
            break;
          /* RANGE */
          case 204:
            ge && (b = ge);
            break;
          /* SHEETNAMECS */
          case 222:
            b = ge;
            break;
          /* SHEETNAMELP */
          case 15:
          /* LABEL */
          case 51:
            T.qpro || (ge[1].v = ge[1].v.slice(1));
          /* falls through */
          case 13:
          /* INTEGER */
          case 14:
          /* NUMBER */
          case 16:
            ze == 14 && (ge[2] & 112) == 112 && (ge[2] & 15) > 1 && (ge[2] & 15) < 15 && (ge[1].z = T.dateNF || It[14], T.cellDates && (ge[1].t = "d", ge[1].v = ww(ge[1].v))), T.qpro && ge[3] > P && (A["!ref"] = Ft(q), te[L] = A, H.push(L), A = T.dense ? [] : {}, q = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, P = ge[3], L = b || "Sheet" + (P + 1), b = "");
            var Xe = T.dense ? (A[ge[0].r] || [])[ge[0].c] : A[_t(ge[0])];
            if (Xe) {
              Xe.t = ge[1].t, Xe.v = ge[1].v, ge[1].z != null && (Xe.z = ge[1].z), ge[1].f != null && (Xe.f = ge[1].f);
              break;
            }
            T.dense ? (A[ge[0].r] || (A[ge[0].r] = []), A[ge[0].r][ge[0].c] = ge[1]) : A[_t(ge[0])] = ge[1];
            break;
        }
      }, T);
    else if (I[2] == 26 || I[2] == 14)
      T.Enum = k, I[2] == 14 && (T.qpro = !0, I.l = 0), e(I, function(ge, Ge, ze) {
        switch (ze) {
          case 204:
            L = ge;
            break;
          /* SHEETNAMECS */
          case 22:
            ge[1].v = ge[1].v.slice(1);
          /* falls through */
          case 23:
          /* NUMBER17 */
          case 24:
          /* NUMBER18 */
          case 25:
          /* FORMULA19 */
          case 37:
          /* NUMBER25 */
          case 39:
          /* NUMBER27 */
          case 40:
            if (ge[3] > P && (A["!ref"] = Ft(q), te[L] = A, H.push(L), A = T.dense ? [] : {}, q = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, P = ge[3], L = "Sheet" + (P + 1)), J > 0 && ge[0].r >= J) break;
            T.dense ? (A[ge[0].r] || (A[ge[0].r] = []), A[ge[0].r][ge[0].c] = ge[1]) : A[_t(ge[0])] = ge[1], q.e.c < ge[0].c && (q.e.c = ge[0].c), q.e.r < ge[0].r && (q.e.r = ge[0].r);
            break;
          case 27:
            ge[14e3] && (D[ge[14e3][0]] = ge[14e3][1]);
            break;
          case 1537:
            D[ge[0]] = ge[1], ge[0] == P && (L = ge[1]);
            break;
        }
      }, T);
    else throw new Error("Unrecognized LOTUS BOF " + I[2]);
    if (A["!ref"] = Ft(q), te[b || L] = A, H.push(b || L), !D.length) return { SheetNames: H, Sheets: te };
    for (var ne = {}, ce = [], Ee = 0; Ee < D.length; ++Ee) te[H[Ee]] ? (ce.push(D[Ee] || H[Ee]), ne[D[Ee]] = te[D[Ee]] || te[H[Ee]]) : (ce.push(D[Ee]), ne[D[Ee]] = { "!ref": "A1" });
    return { SheetNames: ce, Sheets: ne };
  }
  function n(I, C) {
    var T = C || {};
    if (+T.codepage >= 0 && Wa(+T.codepage), T.type == "string") throw new Error("Cannot write WK1 to JS string");
    var A = vr(), L = At(I["!ref"]), b = Array.isArray(I), P = [];
    Fe(A, 0, a(1030)), Fe(A, 6, c(L));
    for (var te = Math.min(L.e.r, 8191), H = L.s.r; H <= te; ++H)
      for (var D = Kt(H), q = L.s.c; q <= L.e.c; ++q) {
        H === L.s.r && (P[q] = ar(q));
        var J = P[q] + D, ne = b ? (I[H] || [])[q] : I[J];
        if (!(!ne || ne.t == "z"))
          if (ne.t == "n")
            (ne.v | 0) == ne.v && ne.v >= -32768 && ne.v <= 32767 ? Fe(A, 13, p(H, q, ne.v)) : Fe(A, 14, m(H, q, ne.v));
          else {
            var ce = An(ne);
            Fe(A, 15, d(H, q, ce.slice(0, 239)));
          }
      }
    return Fe(A, 1), A.end();
  }
  function i(I, C) {
    var T = C || {};
    if (+T.codepage >= 0 && Wa(+T.codepage), T.type == "string") throw new Error("Cannot write WK3 to JS string");
    var A = vr();
    Fe(A, 0, s(I));
    for (var L = 0, b = 0; L < I.SheetNames.length; ++L) (I.Sheets[I.SheetNames[L]] || {})["!ref"] && Fe(A, 27, se(I.SheetNames[L], b++));
    var P = 0;
    for (L = 0; L < I.SheetNames.length; ++L) {
      var te = I.Sheets[I.SheetNames[L]];
      if (!(!te || !te["!ref"])) {
        for (var H = At(te["!ref"]), D = Array.isArray(te), q = [], J = Math.min(H.e.r, 8191), ne = H.s.r; ne <= J; ++ne)
          for (var ce = Kt(ne), Ee = H.s.c; Ee <= H.e.c; ++Ee) {
            ne === H.s.r && (q[Ee] = ar(Ee));
            var ge = q[Ee] + ce, Ge = D ? (te[ne] || [])[Ee] : te[ge];
            if (!(!Ge || Ge.t == "z"))
              if (Ge.t == "n")
                Fe(A, 23, B(ne, Ee, P, Ge.v));
              else {
                var ze = An(Ge);
                Fe(A, 22, E(ne, Ee, P, ze.slice(0, 239)));
              }
          }
        ++P;
      }
    }
    return Fe(A, 1), A.end();
  }
  function a(I) {
    var C = ve(2);
    return C.write_shift(2, I), C;
  }
  function s(I) {
    var C = ve(26);
    C.write_shift(2, 4096), C.write_shift(2, 4), C.write_shift(4, 0);
    for (var T = 0, A = 0, L = 0, b = 0; b < I.SheetNames.length; ++b) {
      var P = I.SheetNames[b], te = I.Sheets[P];
      if (!(!te || !te["!ref"])) {
        ++L;
        var H = Pr(te["!ref"]);
        T < H.e.r && (T = H.e.r), A < H.e.c && (A = H.e.c);
      }
    }
    return T > 8191 && (T = 8191), C.write_shift(2, T), C.write_shift(1, L), C.write_shift(1, A), C.write_shift(2, 0), C.write_shift(2, 0), C.write_shift(1, 1), C.write_shift(1, 2), C.write_shift(4, 0), C.write_shift(4, 0), C;
  }
  function o(I, C, T) {
    var A = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    return C == 8 && T.qpro ? (A.s.c = I.read_shift(1), I.l++, A.s.r = I.read_shift(2), A.e.c = I.read_shift(1), I.l++, A.e.r = I.read_shift(2), A) : (A.s.c = I.read_shift(2), A.s.r = I.read_shift(2), C == 12 && T.qpro && (I.l += 2), A.e.c = I.read_shift(2), A.e.r = I.read_shift(2), C == 12 && T.qpro && (I.l += 2), A.s.c == 65535 && (A.s.c = A.e.c = A.s.r = A.e.r = 0), A);
  }
  function c(I) {
    var C = ve(8);
    return C.write_shift(2, I.s.c), C.write_shift(2, I.s.r), C.write_shift(2, I.e.c), C.write_shift(2, I.e.r), C;
  }
  function u(I, C, T) {
    var A = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    return T.qpro && T.vers != 20768 ? (A[0].c = I.read_shift(1), A[3] = I.read_shift(1), A[0].r = I.read_shift(2), I.l += 2) : (A[2] = I.read_shift(1), A[0].c = I.read_shift(2), A[0].r = I.read_shift(2)), A;
  }
  function l(I, C, T) {
    var A = I.l + C, L = u(I, C, T);
    if (L[1].t = "s", T.vers == 20768) {
      I.l++;
      var b = I.read_shift(1);
      return L[1].v = I.read_shift(b, "utf8"), L;
    }
    return T.qpro && I.l++, L[1].v = I.read_shift(A - I.l, "cstr"), L;
  }
  function d(I, C, T) {
    var A = ve(7 + T.length);
    A.write_shift(1, 255), A.write_shift(2, C), A.write_shift(2, I), A.write_shift(1, 39);
    for (var L = 0; L < A.length; ++L) {
      var b = T.charCodeAt(L);
      A.write_shift(1, b >= 128 ? 95 : b);
    }
    return A.write_shift(1, 0), A;
  }
  function f(I, C, T) {
    var A = u(I, C, T);
    return A[1].v = I.read_shift(2, "i"), A;
  }
  function p(I, C, T) {
    var A = ve(7);
    return A.write_shift(1, 255), A.write_shift(2, C), A.write_shift(2, I), A.write_shift(2, T, "i"), A;
  }
  function v(I, C, T) {
    var A = u(I, C, T);
    return A[1].v = I.read_shift(8, "f"), A;
  }
  function m(I, C, T) {
    var A = ve(13);
    return A.write_shift(1, 255), A.write_shift(2, C), A.write_shift(2, I), A.write_shift(8, T, "f"), A;
  }
  function h(I, C, T) {
    var A = I.l + C, L = u(I, C, T);
    if (L[1].v = I.read_shift(8, "f"), T.qpro) I.l = A;
    else {
      var b = I.read_shift(2);
      x(I.slice(I.l, I.l + b), L), I.l += b;
    }
    return L;
  }
  function _(I, C, T) {
    var A = C & 32768;
    return C &= -32769, C = (A ? I : 0) + (C >= 8192 ? C - 16384 : C), (A ? "" : "$") + (T ? ar(C) : Kt(C));
  }
  var g = {
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    70: ["LEN", 1],
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    111: ["T", 1]
  }, y = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function x(I, C) {
    $r(I, 0);
    for (var T = [], A = 0, L = "", b = "", P = "", te = ""; I.l < I.length; ) {
      var H = I[I.l++];
      switch (H) {
        case 0:
          T.push(I.read_shift(8, "f"));
          break;
        case 1:
          b = _(C[0].c, I.read_shift(2), !0), L = _(C[0].r, I.read_shift(2), !1), T.push(b + L);
          break;
        case 2:
          {
            var D = _(C[0].c, I.read_shift(2), !0), q = _(C[0].r, I.read_shift(2), !1);
            b = _(C[0].c, I.read_shift(2), !0), L = _(C[0].r, I.read_shift(2), !1), T.push(D + q + ":" + b + L);
          }
          break;
        case 3:
          if (I.l < I.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          T.push("(" + T.pop() + ")");
          break;
        case 5:
          T.push(I.read_shift(2));
          break;
        case 6:
          {
            for (var J = ""; H = I[I.l++]; ) J += String.fromCharCode(H);
            T.push('"' + J.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          T.push("-" + T.pop());
          break;
        case 23:
          T.push("+" + T.pop());
          break;
        case 22:
          T.push("NOT(" + T.pop() + ")");
          break;
        case 20:
        case 21:
          te = T.pop(), P = T.pop(), T.push(["AND", "OR"][H - 20] + "(" + P + "," + te + ")");
          break;
        default:
          if (H < 32 && y[H])
            te = T.pop(), P = T.pop(), T.push(P + y[H] + te);
          else if (g[H]) {
            if (A = g[H][1], A == 69 && (A = I[I.l++]), A > T.length) {
              console.error("WK1 bad formula parse 0x" + H.toString(16) + ":|" + T.join("|") + "|");
              return;
            }
            var ne = T.slice(-A);
            T.length -= A, T.push(g[H][0] + "(" + ne.join(",") + ")");
          } else return H <= 7 ? console.error("WK1 invalid opcode " + H.toString(16)) : H <= 24 ? console.error("WK1 unsupported op " + H.toString(16)) : H <= 30 ? console.error("WK1 invalid opcode " + H.toString(16)) : H <= 115 ? console.error("WK1 unsupported function opcode " + H.toString(16)) : console.error("WK1 unrecognized opcode " + H.toString(16));
      }
    }
    T.length == 1 ? C[1].f = "" + T[0] : console.error("WK1 bad formula parse |" + T.join("|") + "|");
  }
  function S(I) {
    var C = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    return C[0].r = I.read_shift(2), C[3] = I[I.l++], C[0].c = I[I.l++], C;
  }
  function w(I, C) {
    var T = S(I);
    return T[1].t = "s", T[1].v = I.read_shift(C - 4, "cstr"), T;
  }
  function E(I, C, T, A) {
    var L = ve(6 + A.length);
    L.write_shift(2, I), L.write_shift(1, T), L.write_shift(1, C), L.write_shift(1, 39);
    for (var b = 0; b < A.length; ++b) {
      var P = A.charCodeAt(b);
      L.write_shift(1, P >= 128 ? 95 : P);
    }
    return L.write_shift(1, 0), L;
  }
  function R(I, C) {
    var T = S(I);
    T[1].v = I.read_shift(2);
    var A = T[1].v >> 1;
    if (T[1].v & 1)
      switch (A & 7) {
        case 0:
          A = (A >> 3) * 5e3;
          break;
        case 1:
          A = (A >> 3) * 500;
          break;
        case 2:
          A = (A >> 3) / 20;
          break;
        case 3:
          A = (A >> 3) / 200;
          break;
        case 4:
          A = (A >> 3) / 2e3;
          break;
        case 5:
          A = (A >> 3) / 2e4;
          break;
        case 6:
          A = (A >> 3) / 16;
          break;
        case 7:
          A = (A >> 3) / 64;
          break;
      }
    return T[1].v = A, T;
  }
  function N(I, C) {
    var T = S(I), A = I.read_shift(4), L = I.read_shift(4), b = I.read_shift(2);
    if (b == 65535)
      return A === 0 && L === 3221225472 ? (T[1].t = "e", T[1].v = 15) : A === 0 && L === 3489660928 ? (T[1].t = "e", T[1].v = 42) : T[1].v = 0, T;
    var P = b & 32768;
    return b = (b & 32767) - 16446, T[1].v = (1 - P * 2) * (L * Math.pow(2, b + 32) + A * Math.pow(2, b)), T;
  }
  function B(I, C, T, A) {
    var L = ve(14);
    if (L.write_shift(2, I), L.write_shift(1, T), L.write_shift(1, C), A == 0)
      return L.write_shift(4, 0), L.write_shift(4, 0), L.write_shift(2, 65535), L;
    var b = 0, P = 0, te = 0, H = 0;
    return A < 0 && (b = 1, A = -A), P = Math.log2(A) | 0, A /= Math.pow(2, P - 31), H = A >>> 0, (H & 2147483648) == 0 && (A /= 2, ++P, H = A >>> 0), A -= H, H |= 2147483648, H >>>= 0, A *= Math.pow(2, 32), te = A >>> 0, L.write_shift(4, te), L.write_shift(4, H), P += 16383 + (b ? 32768 : 0), L.write_shift(2, P), L;
  }
  function F(I, C) {
    var T = N(I);
    return I.l += C - 14, T;
  }
  function U(I, C) {
    var T = S(I), A = I.read_shift(4);
    return T[1].v = A >> 6, T;
  }
  function G(I, C) {
    var T = S(I), A = I.read_shift(8, "f");
    return T[1].v = A, T;
  }
  function M(I, C) {
    var T = G(I);
    return I.l += C - 10, T;
  }
  function V(I, C) {
    return I[I.l + C - 1] == 0 ? I.read_shift(C, "cstr") : "";
  }
  function ie(I, C) {
    var T = I[I.l++];
    T > C - 1 && (T = C - 1);
    for (var A = ""; A.length < T; ) A += String.fromCharCode(I[I.l++]);
    return A;
  }
  function W(I, C, T) {
    if (!(!T.qpro || C < 21)) {
      var A = I.read_shift(1);
      I.l += 17, I.l += 1, I.l += 2;
      var L = I.read_shift(C - 21, "cstr");
      return [A, L];
    }
  }
  function ae(I, C) {
    for (var T = {}, A = I.l + C; I.l < A; ) {
      var L = I.read_shift(2);
      if (L == 14e3) {
        for (T[L] = [0, ""], T[L][0] = I.read_shift(2); I[I.l]; )
          T[L][1] += String.fromCharCode(I[I.l]), I.l++;
        I.l++;
      }
    }
    return T;
  }
  function se(I, C) {
    var T = ve(5 + I.length);
    T.write_shift(2, 14e3), T.write_shift(2, C);
    for (var A = 0; A < I.length; ++A) {
      var L = I.charCodeAt(A);
      T[T.l++] = L > 127 ? 95 : L;
    }
    return T[T.l++] = 0, T;
  }
  var X = {
    /*::[*/
    0: { n: "BOF", f: Zw },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "CALCMODE" },
    /*::[*/
    3: { n: "CALCORDER" },
    /*::[*/
    4: { n: "SPLIT" },
    /*::[*/
    5: { n: "SYNC" },
    /*::[*/
    6: { n: "RANGE", f: o },
    /*::[*/
    7: { n: "WINDOW1" },
    /*::[*/
    8: { n: "COLW1" },
    /*::[*/
    9: { n: "WINTWO" },
    /*::[*/
    10: { n: "COLW2" },
    /*::[*/
    11: { n: "NAME" },
    /*::[*/
    12: { n: "BLANK" },
    /*::[*/
    13: { n: "INTEGER", f },
    /*::[*/
    14: { n: "NUMBER", f: v },
    /*::[*/
    15: { n: "LABEL", f: l },
    /*::[*/
    16: { n: "FORMULA", f: h },
    /*::[*/
    24: { n: "TABLE" },
    /*::[*/
    25: { n: "ORANGE" },
    /*::[*/
    26: { n: "PRANGE" },
    /*::[*/
    27: { n: "SRANGE" },
    /*::[*/
    28: { n: "FRANGE" },
    /*::[*/
    29: { n: "KRANGE1" },
    /*::[*/
    32: { n: "HRANGE" },
    /*::[*/
    35: { n: "KRANGE2" },
    /*::[*/
    36: { n: "PROTEC" },
    /*::[*/
    37: { n: "FOOTER" },
    /*::[*/
    38: { n: "HEADER" },
    /*::[*/
    39: { n: "SETUP" },
    /*::[*/
    40: { n: "MARGINS" },
    /*::[*/
    41: { n: "LABELFMT" },
    /*::[*/
    42: { n: "TITLES" },
    /*::[*/
    43: { n: "SHEETJS" },
    /*::[*/
    45: { n: "GRAPH" },
    /*::[*/
    46: { n: "NGRAPH" },
    /*::[*/
    47: { n: "CALCCOUNT" },
    /*::[*/
    48: { n: "UNFORMATTED" },
    /*::[*/
    49: { n: "CURSORW12" },
    /*::[*/
    50: { n: "WINDOW" },
    /*::[*/
    51: { n: "STRING", f: l },
    /*::[*/
    55: { n: "PASSWORD" },
    /*::[*/
    56: { n: "LOCKED" },
    /*::[*/
    60: { n: "QUERY" },
    /*::[*/
    61: { n: "QUERYNAME" },
    /*::[*/
    62: { n: "PRINT" },
    /*::[*/
    63: { n: "PRINTNAME" },
    /*::[*/
    64: { n: "GRAPH2" },
    /*::[*/
    65: { n: "GRAPHNAME" },
    /*::[*/
    66: { n: "ZOOM" },
    /*::[*/
    67: { n: "SYMSPLIT" },
    /*::[*/
    68: { n: "NSROWS" },
    /*::[*/
    69: { n: "NSCOLS" },
    /*::[*/
    70: { n: "RULER" },
    /*::[*/
    71: { n: "NNAME" },
    /*::[*/
    72: { n: "ACOMM" },
    /*::[*/
    73: { n: "AMACRO" },
    /*::[*/
    74: { n: "PARSE" },
    /*::[*/
    102: { n: "PRANGES??" },
    /*::[*/
    103: { n: "RRANGES??" },
    /*::[*/
    104: { n: "FNAME??" },
    /*::[*/
    105: { n: "MRANGES??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: V },
    /*::[*/
    222: { n: "SHEETNAMELP", f: ie },
    /*::[*/
    65535: { n: "" }
  }, k = {
    /*::[*/
    0: { n: "BOF" },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "PASSWORD" },
    /*::[*/
    3: { n: "CALCSET" },
    /*::[*/
    4: { n: "WINDOWSET" },
    /*::[*/
    5: { n: "SHEETCELLPTR" },
    /*::[*/
    6: { n: "SHEETLAYOUT" },
    /*::[*/
    7: { n: "COLUMNWIDTH" },
    /*::[*/
    8: { n: "HIDDENCOLUMN" },
    /*::[*/
    9: { n: "USERRANGE" },
    /*::[*/
    10: { n: "SYSTEMRANGE" },
    /*::[*/
    11: { n: "ZEROFORCE" },
    /*::[*/
    12: { n: "SORTKEYDIR" },
    /*::[*/
    13: { n: "FILESEAL" },
    /*::[*/
    14: { n: "DATAFILLNUMS" },
    /*::[*/
    15: { n: "PRINTMAIN" },
    /*::[*/
    16: { n: "PRINTSTRING" },
    /*::[*/
    17: { n: "GRAPHMAIN" },
    /*::[*/
    18: { n: "GRAPHSTRING" },
    /*::[*/
    19: { n: "??" },
    /*::[*/
    20: { n: "ERRCELL" },
    /*::[*/
    21: { n: "NACELL" },
    /*::[*/
    22: { n: "LABEL16", f: w },
    /*::[*/
    23: { n: "NUMBER17", f: N },
    /*::[*/
    24: { n: "NUMBER18", f: R },
    /*::[*/
    25: { n: "FORMULA19", f: F },
    /*::[*/
    26: { n: "FORMULA1A" },
    /*::[*/
    27: { n: "XFORMAT", f: ae },
    /*::[*/
    28: { n: "DTLABELMISC" },
    /*::[*/
    29: { n: "DTLABELCELL" },
    /*::[*/
    30: { n: "GRAPHWINDOW" },
    /*::[*/
    31: { n: "CPA" },
    /*::[*/
    32: { n: "LPLAUTO" },
    /*::[*/
    33: { n: "QUERY" },
    /*::[*/
    34: { n: "HIDDENSHEET" },
    /*::[*/
    35: { n: "??" },
    /*::[*/
    37: { n: "NUMBER25", f: U },
    /*::[*/
    38: { n: "??" },
    /*::[*/
    39: { n: "NUMBER27", f: G },
    /*::[*/
    40: { n: "FORMULA28", f: M },
    /*::[*/
    142: { n: "??" },
    /*::[*/
    147: { n: "??" },
    /*::[*/
    150: { n: "??" },
    /*::[*/
    151: { n: "??" },
    /*::[*/
    152: { n: "??" },
    /*::[*/
    153: { n: "??" },
    /*::[*/
    154: { n: "??" },
    /*::[*/
    155: { n: "??" },
    /*::[*/
    156: { n: "??" },
    /*::[*/
    163: { n: "??" },
    /*::[*/
    174: { n: "??" },
    /*::[*/
    175: { n: "??" },
    /*::[*/
    176: { n: "??" },
    /*::[*/
    177: { n: "??" },
    /*::[*/
    184: { n: "??" },
    /*::[*/
    185: { n: "??" },
    /*::[*/
    186: { n: "??" },
    /*::[*/
    187: { n: "??" },
    /*::[*/
    188: { n: "??" },
    /*::[*/
    195: { n: "??" },
    /*::[*/
    201: { n: "??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: V },
    /*::[*/
    205: { n: "??" },
    /*::[*/
    206: { n: "??" },
    /*::[*/
    207: { n: "??" },
    /*::[*/
    208: { n: "??" },
    /*::[*/
    256: { n: "??" },
    /*::[*/
    259: { n: "??" },
    /*::[*/
    260: { n: "??" },
    /*::[*/
    261: { n: "??" },
    /*::[*/
    262: { n: "??" },
    /*::[*/
    263: { n: "??" },
    /*::[*/
    265: { n: "??" },
    /*::[*/
    266: { n: "??" },
    /*::[*/
    267: { n: "??" },
    /*::[*/
    268: { n: "??" },
    /*::[*/
    270: { n: "??" },
    /*::[*/
    271: { n: "??" },
    /*::[*/
    384: { n: "??" },
    /*::[*/
    389: { n: "??" },
    /*::[*/
    390: { n: "??" },
    /*::[*/
    393: { n: "??" },
    /*::[*/
    396: { n: "??" },
    /*::[*/
    512: { n: "??" },
    /*::[*/
    514: { n: "??" },
    /*::[*/
    513: { n: "??" },
    /*::[*/
    516: { n: "??" },
    /*::[*/
    517: { n: "??" },
    /*::[*/
    640: { n: "??" },
    /*::[*/
    641: { n: "??" },
    /*::[*/
    642: { n: "??" },
    /*::[*/
    643: { n: "??" },
    /*::[*/
    644: { n: "??" },
    /*::[*/
    645: { n: "??" },
    /*::[*/
    646: { n: "??" },
    /*::[*/
    647: { n: "??" },
    /*::[*/
    648: { n: "??" },
    /*::[*/
    658: { n: "??" },
    /*::[*/
    659: { n: "??" },
    /*::[*/
    660: { n: "??" },
    /*::[*/
    661: { n: "??" },
    /*::[*/
    662: { n: "??" },
    /*::[*/
    665: { n: "??" },
    /*::[*/
    666: { n: "??" },
    /*::[*/
    768: { n: "??" },
    /*::[*/
    772: { n: "??" },
    /*::[*/
    1537: { n: "SHEETINFOQP", f: W },
    /*::[*/
    1600: { n: "??" },
    /*::[*/
    1602: { n: "??" },
    /*::[*/
    1793: { n: "??" },
    /*::[*/
    1794: { n: "??" },
    /*::[*/
    1795: { n: "??" },
    /*::[*/
    1796: { n: "??" },
    /*::[*/
    1920: { n: "??" },
    /*::[*/
    2048: { n: "??" },
    /*::[*/
    2049: { n: "??" },
    /*::[*/
    2052: { n: "??" },
    /*::[*/
    2688: { n: "??" },
    /*::[*/
    10998: { n: "??" },
    /*::[*/
    12849: { n: "??" },
    /*::[*/
    28233: { n: "??" },
    /*::[*/
    28484: { n: "??" },
    /*::[*/
    65535: { n: "" }
  };
  return {
    sheet_to_wk1: n,
    book_to_wk3: i,
    to_workbook: t
  };
})(), zP = /^\s|\s$|[\t\n\r]/;
function ax(e, t) {
  if (!t.bookSST) return "";
  var r = [Dt];
  r[r.length] = be("sst", null, {
    xmlns: ra[0],
    count: e.Count,
    uniqueCount: e.Unique
  });
  for (var n = 0; n != e.length; ++n)
    if (e[n] != null) {
      var i = e[n], a = "<si>";
      i.r ? a += i.r : (a += "<t", i.t || (i.t = ""), i.t.match(zP) && (a += ' xml:space="preserve"'), a += ">" + gt(i.t) + "</t>"), a += "</si>", r[r.length] = a;
    }
  return r.length > 2 && (r[r.length] = "</sst>", r[1] = r[1].replace("/>", ">")), r.join("");
}
function WP(e) {
  return [e.read_shift(4), e.read_shift(4)];
}
function XP(e, t) {
  return t || (t = ve(8)), t.write_shift(4, e.Count), t.write_shift(4, e.Unique), t;
}
var KP = UN;
function YP(e) {
  var t = vr();
  Se(t, 159, XP(e));
  for (var r = 0; r < e.length; ++r) Se(t, 19, KP(e[r]));
  return Se(
    t,
    160
    /* BrtEndSst */
  ), t.end();
}
function JP(e) {
  for (var t = [], r = e.split(""), n = 0; n < r.length; ++n) t[n] = r[n].charCodeAt(0);
  return t;
}
function sx(e) {
  var t = 0, r, n = JP(e), i = n.length + 1, a, s, o, c, u;
  for (r = mi(i), r[0] = n.length, a = 1; a != i; ++a) r[a] = n[a - 1];
  for (a = i - 1; a >= 0; --a)
    s = r[a], o = (t & 16384) === 0 ? 0 : 1, c = t << 1 & 32767, u = o | c, t = u ^ s;
  return t ^ 52811;
}
var QP = /* @__PURE__ */ (function() {
  function e(i, a) {
    switch (a.type) {
      case "base64":
        return t(Sn(i), a);
      case "binary":
        return t(i, a);
      case "buffer":
        return t(ft && Buffer.isBuffer(i) ? i.toString("binary") : ss(i), a);
      case "array":
        return t(Sl(i), a);
    }
    throw new Error("Unrecognized type " + a.type);
  }
  function t(i, a) {
    var s = a || {}, o = s.dense ? [] : {}, c = i.match(/\\trowd.*?\\row\b/g);
    if (!c.length) throw new Error("RTF missing table");
    var u = { s: { c: 0, r: 0 }, e: { c: 0, r: c.length - 1 } };
    return c.forEach(function(l, d) {
      Array.isArray(o) && (o[d] = []);
      for (var f = /\\\w+\b/g, p = 0, v, m = -1; v = f.exec(l); ) {
        switch (v[0]) {
          case "\\cell":
            var h = l.slice(p, f.lastIndex - v[0].length);
            if (h[0] == " " && (h = h.slice(1)), ++m, h.length) {
              var _ = { v: h, t: "s" };
              Array.isArray(o) ? o[d][m] = _ : o[_t({ r: d, c: m })] = _;
            }
            break;
        }
        p = f.lastIndex;
      }
      m > u.e.c && (u.e.c = m);
    }), o["!ref"] = Ft(u), o;
  }
  function r(i, a) {
    return wi(e(i, a), a);
  }
  function n(i) {
    for (var a = ["{\\rtf1\\ansi"], s = At(i["!ref"]), o, c = Array.isArray(i), u = s.s.r; u <= s.e.r; ++u) {
      a.push("\\trowd\\trautofit1");
      for (var l = s.s.c; l <= s.e.c; ++l) a.push("\\cellx" + (l + 1));
      for (a.push("\\pard\\intbl"), l = s.s.c; l <= s.e.c; ++l) {
        var d = _t({ r: u, c: l });
        o = c ? (i[u] || [])[l] : i[d], !(!o || o.v == null && (!o.f || o.F)) && (a.push(" " + (o.w || (An(o), o.w))), a.push("\\cell"));
      }
      a.push("\\pard\\intbl\\row");
    }
    return a.join("") + "}";
  }
  return {
    to_workbook: r,
    to_sheet: e,
    from_sheet: n
  };
})();
function By(e) {
  for (var t = 0, r = 1; t != 3; ++t) r = r * 256 + (e[t] > 255 ? 255 : e[t] < 0 ? 0 : e[t]);
  return r.toString(16).toUpperCase().slice(1);
}
var ZP = 6, xn = ZP;
function Vc(e) {
  return Math.floor((e + Math.round(128 / xn) / 256) * xn);
}
function Hc(e) {
  return Math.floor((e - 5) / xn * 100 + 0.5) / 100;
}
function l0(e) {
  return Math.round((e * xn + 5) / xn * 256) / 256;
}
function nh(e) {
  e.width ? (e.wpx = Vc(e.width), e.wch = Hc(e.wpx), e.MDW = xn) : e.wpx ? (e.wch = Hc(e.wpx), e.width = l0(e.wch), e.MDW = xn) : typeof e.wch == "number" && (e.width = l0(e.wch), e.wpx = Vc(e.width), e.MDW = xn), e.customWidth && delete e.customWidth;
}
var eC = 96, ox = eC;
function Gc(e) {
  return e * 96 / ox;
}
function cx(e) {
  return e * ox / 96;
}
function tC(e) {
  var t = ["<numFmts>"];
  return [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var n = r[0]; n <= r[1]; ++n) e[n] != null && (t[t.length] = be("numFmt", null, { numFmtId: n, formatCode: gt(e[n]) }));
  }), t.length === 1 ? "" : (t[t.length] = "</numFmts>", t[0] = be("numFmts", null, { count: t.length - 2 }).replace("/>", ">"), t.join(""));
}
function rC(e) {
  var t = [];
  return t[t.length] = be("cellXfs", null), e.forEach(function(r) {
    t[t.length] = be("xf", null, r);
  }), t[t.length] = "</cellXfs>", t.length === 2 ? "" : (t[0] = be("cellXfs", null, { count: t.length - 2 }).replace("/>", ">"), t.join(""));
}
function lx(e, t) {
  var r = [Dt, be("styleSheet", null, {
    xmlns: ra[0],
    "xmlns:vt": Ut.vt
  })], n;
  return e.SSF && (n = tC(e.SSF)) != null && (r[r.length] = n), r[r.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>', r[r.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>', r[r.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>', r[r.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>', (n = rC(t.cellXfs)) && (r[r.length] = n), r[r.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>', r[r.length] = '<dxfs count="0"/>', r[r.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>', r.length > 2 && (r[r.length] = "</styleSheet>", r[1] = r[1].replace("/>", ">")), r.join("");
}
function nC(e, t) {
  var r = e.read_shift(2), n = sr(e);
  return [r, n];
}
function iC(e, t, r) {
  r || (r = ve(6 + 4 * t.length)), r.write_shift(2, e), Bt(t, r);
  var n = r.length > r.l ? r.slice(0, r.l) : r;
  return r.l == null && (r.l = r.length), n;
}
function aC(e, t, r) {
  var n = {};
  n.sz = e.read_shift(2) / 20;
  var i = zN(e);
  i.fItalic && (n.italic = 1), i.fCondense && (n.condense = 1), i.fExtend && (n.extend = 1), i.fShadow && (n.shadow = 1), i.fOutline && (n.outline = 1), i.fStrikeout && (n.strike = 1);
  var a = e.read_shift(2);
  switch (a === 700 && (n.bold = 1), e.read_shift(2)) {
    /* case 0: out.vertAlign = "baseline"; break; */
    case 1:
      n.vertAlign = "superscript";
      break;
    case 2:
      n.vertAlign = "subscript";
      break;
  }
  var s = e.read_shift(1);
  s != 0 && (n.underline = s);
  var o = e.read_shift(1);
  o > 0 && (n.family = o);
  var c = e.read_shift(1);
  switch (c > 0 && (n.charset = c), e.l++, n.color = GN(e), e.read_shift(1)) {
    /* case 0: out.scheme = "none": break; */
    case 1:
      n.scheme = "major";
      break;
    case 2:
      n.scheme = "minor";
      break;
  }
  return n.name = sr(e), n;
}
function sC(e, t) {
  t || (t = ve(153)), t.write_shift(2, e.sz * 20), WN(e, t), t.write_shift(2, e.bold ? 700 : 400);
  var r = 0;
  e.vertAlign == "superscript" ? r = 1 : e.vertAlign == "subscript" && (r = 2), t.write_shift(2, r), t.write_shift(1, e.underline || 0), t.write_shift(1, e.family || 0), t.write_shift(1, e.charset || 0), t.write_shift(1, 0), Bc(e.color, t);
  var n = 0;
  return n = 2, t.write_shift(1, n), Bt(e.name, t), t.length > t.l ? t.slice(0, t.l) : t;
}
var oC = [
  "none",
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
], Qd, cC = on;
function jy(e, t) {
  t || (t = ve(84)), Qd || (Qd = G0(oC));
  var r = Qd[e.patternType];
  r == null && (r = 40), t.write_shift(4, r);
  var n = 0;
  if (r != 40)
    for (Bc({ auto: 1 }, t), Bc({ auto: 1 }, t); n < 12; ++n) t.write_shift(4, 0);
  else {
    for (; n < 4; ++n) t.write_shift(4, 0);
    for (; n < 12; ++n) t.write_shift(4, 0);
  }
  return t.length > t.l ? t.slice(0, t.l) : t;
}
function lC(e, t) {
  var r = e.l + t, n = e.read_shift(2), i = e.read_shift(2);
  return e.l = r, { ixfe: n, numFmtId: i };
}
function ux(e, t, r) {
  r || (r = ve(16)), r.write_shift(2, t || 0), r.write_shift(2, e.numFmtId || 0), r.write_shift(2, 0), r.write_shift(2, 0), r.write_shift(2, 0), r.write_shift(1, 0), r.write_shift(1, 0);
  var n = 0;
  return r.write_shift(1, n), r.write_shift(1, 0), r.write_shift(1, 0), r.write_shift(1, 0), r;
}
function Ma(e, t) {
  return t || (t = ve(10)), t.write_shift(1, 0), t.write_shift(1, 0), t.write_shift(4, 0), t.write_shift(4, 0), t;
}
var uC = on;
function fC(e, t) {
  return t || (t = ve(51)), t.write_shift(1, 0), Ma(null, t), Ma(null, t), Ma(null, t), Ma(null, t), Ma(null, t), t.length > t.l ? t.slice(0, t.l) : t;
}
function dC(e, t) {
  return t || (t = ve(52)), t.write_shift(4, e.xfId), t.write_shift(2, 1), t.write_shift(1, 0), t.write_shift(1, 0), qc(e.name || "", t), t.length > t.l ? t.slice(0, t.l) : t;
}
function hC(e, t, r) {
  var n = ve(2052);
  return n.write_shift(4, e), qc(t, n), qc(r, n), n.length > n.l ? n.slice(0, n.l) : n;
}
function pC(e, t) {
  if (t) {
    var r = 0;
    [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(n) {
      for (var i = n[0]; i <= n[1]; ++i) t[i] != null && ++r;
    }), r != 0 && (Se(e, 615, Xr(r)), [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(n) {
      for (var i = n[0]; i <= n[1]; ++i) t[i] != null && Se(e, 44, iC(i, t[i]));
    }), Se(
      e,
      616
      /* BrtEndFmts */
    ));
  }
}
function mC(e) {
  var t = 1;
  Se(e, 611, Xr(t)), Se(e, 43, sC({
    sz: 12,
    color: { theme: 1 },
    name: "Calibri",
    family: 2
  })), Se(
    e,
    612
    /* BrtEndFonts */
  );
}
function gC(e) {
  var t = 2;
  Se(e, 603, Xr(t)), Se(e, 45, jy({ patternType: "none" })), Se(e, 45, jy({ patternType: "gray125" })), Se(
    e,
    604
    /* BrtEndFills */
  );
}
function vC(e) {
  var t = 1;
  Se(e, 613, Xr(t)), Se(e, 46, fC()), Se(
    e,
    614
    /* BrtEndBorders */
  );
}
function _C(e) {
  var t = 1;
  Se(e, 626, Xr(t)), Se(e, 47, ux({
    numFmtId: 0
  }, 65535)), Se(
    e,
    627
    /* BrtEndCellStyleXFs */
  );
}
function yC(e, t) {
  Se(e, 617, Xr(t.length)), t.forEach(function(r) {
    Se(e, 47, ux(r, 0));
  }), Se(
    e,
    618
    /* BrtEndCellXFs */
  );
}
function EC(e) {
  var t = 1;
  Se(e, 619, Xr(t)), Se(e, 48, dC({
    xfId: 0,
    name: "Normal"
  })), Se(
    e,
    620
    /* BrtEndStyles */
  );
}
function wC(e) {
  var t = 0;
  Se(e, 505, Xr(t)), Se(
    e,
    506
    /* BrtEndDXFs */
  );
}
function xC(e) {
  var t = 0;
  Se(e, 508, hC(t, "TableStyleMedium9", "PivotStyleMedium4")), Se(
    e,
    509
    /* BrtEndTableStyles */
  );
}
function TC(e, t) {
  var r = vr();
  return Se(
    r,
    278
    /* BrtBeginStyleSheet */
  ), pC(r, e.SSF), mC(r), gC(r), vC(r), _C(r), yC(r, t.cellXfs), EC(r), wC(r), xC(r), Se(
    r,
    279
    /* BrtEndStyleSheet */
  ), r.end();
}
function fx(e, t) {
  if (t && t.themeXLSX) return t.themeXLSX;
  if (e && typeof e.raw == "string") return e.raw;
  var r = [Dt];
  return r[r.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">', r[r.length] = "<a:themeElements>", r[r.length] = '<a:clrScheme name="Office">', r[r.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>', r[r.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>', r[r.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>', r[r.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>', r[r.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>', r[r.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>', r[r.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>', r[r.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>', r[r.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>', r[r.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>', r[r.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>', r[r.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>', r[r.length] = "</a:clrScheme>", r[r.length] = '<a:fontScheme name="Office">', r[r.length] = "<a:majorFont>", r[r.length] = '<a:latin typeface="Cambria"/>', r[r.length] = '<a:ea typeface=""/>', r[r.length] = '<a:cs typeface=""/>', r[r.length] = '<a:font script="Jpan" typeface=" "/>', r[r.length] = '<a:font script="Hang" typeface=" "/>', r[r.length] = '<a:font script="Hans" typeface=""/>', r[r.length] = '<a:font script="Hant" typeface=""/>', r[r.length] = '<a:font script="Arab" typeface="Times New Roman"/>', r[r.length] = '<a:font script="Hebr" typeface="Times New Roman"/>', r[r.length] = '<a:font script="Thai" typeface="Tahoma"/>', r[r.length] = '<a:font script="Ethi" typeface="Nyala"/>', r[r.length] = '<a:font script="Beng" typeface="Vrinda"/>', r[r.length] = '<a:font script="Gujr" typeface="Shruti"/>', r[r.length] = '<a:font script="Khmr" typeface="MoolBoran"/>', r[r.length] = '<a:font script="Knda" typeface="Tunga"/>', r[r.length] = '<a:font script="Guru" typeface="Raavi"/>', r[r.length] = '<a:font script="Cans" typeface="Euphemia"/>', r[r.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', r[r.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', r[r.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', r[r.length] = '<a:font script="Thaa" typeface="MV Boli"/>', r[r.length] = '<a:font script="Deva" typeface="Mangal"/>', r[r.length] = '<a:font script="Telu" typeface="Gautami"/>', r[r.length] = '<a:font script="Taml" typeface="Latha"/>', r[r.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', r[r.length] = '<a:font script="Orya" typeface="Kalinga"/>', r[r.length] = '<a:font script="Mlym" typeface="Kartika"/>', r[r.length] = '<a:font script="Laoo" typeface="DokChampa"/>', r[r.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', r[r.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', r[r.length] = '<a:font script="Viet" typeface="Times New Roman"/>', r[r.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', r[r.length] = '<a:font script="Geor" typeface="Sylfaen"/>', r[r.length] = "</a:majorFont>", r[r.length] = "<a:minorFont>", r[r.length] = '<a:latin typeface="Calibri"/>', r[r.length] = '<a:ea typeface=""/>', r[r.length] = '<a:cs typeface=""/>', r[r.length] = '<a:font script="Jpan" typeface=" "/>', r[r.length] = '<a:font script="Hang" typeface=" "/>', r[r.length] = '<a:font script="Hans" typeface=""/>', r[r.length] = '<a:font script="Hant" typeface=""/>', r[r.length] = '<a:font script="Arab" typeface="Arial"/>', r[r.length] = '<a:font script="Hebr" typeface="Arial"/>', r[r.length] = '<a:font script="Thai" typeface="Tahoma"/>', r[r.length] = '<a:font script="Ethi" typeface="Nyala"/>', r[r.length] = '<a:font script="Beng" typeface="Vrinda"/>', r[r.length] = '<a:font script="Gujr" typeface="Shruti"/>', r[r.length] = '<a:font script="Khmr" typeface="DaunPenh"/>', r[r.length] = '<a:font script="Knda" typeface="Tunga"/>', r[r.length] = '<a:font script="Guru" typeface="Raavi"/>', r[r.length] = '<a:font script="Cans" typeface="Euphemia"/>', r[r.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', r[r.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', r[r.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', r[r.length] = '<a:font script="Thaa" typeface="MV Boli"/>', r[r.length] = '<a:font script="Deva" typeface="Mangal"/>', r[r.length] = '<a:font script="Telu" typeface="Gautami"/>', r[r.length] = '<a:font script="Taml" typeface="Latha"/>', r[r.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', r[r.length] = '<a:font script="Orya" typeface="Kalinga"/>', r[r.length] = '<a:font script="Mlym" typeface="Kartika"/>', r[r.length] = '<a:font script="Laoo" typeface="DokChampa"/>', r[r.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', r[r.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', r[r.length] = '<a:font script="Viet" typeface="Arial"/>', r[r.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', r[r.length] = '<a:font script="Geor" typeface="Sylfaen"/>', r[r.length] = "</a:minorFont>", r[r.length] = "</a:fontScheme>", r[r.length] = '<a:fmtScheme name="Office">', r[r.length] = "<a:fillStyleLst>", r[r.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', r[r.length] = '<a:gradFill rotWithShape="1">', r[r.length] = "<a:gsLst>", r[r.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', r[r.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', r[r.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', r[r.length] = "</a:gsLst>", r[r.length] = '<a:lin ang="16200000" scaled="1"/>', r[r.length] = "</a:gradFill>", r[r.length] = '<a:gradFill rotWithShape="1">', r[r.length] = "<a:gsLst>", r[r.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>', r[r.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', r[r.length] = "</a:gsLst>", r[r.length] = '<a:lin ang="16200000" scaled="0"/>', r[r.length] = "</a:gradFill>", r[r.length] = "</a:fillStyleLst>", r[r.length] = "<a:lnStyleLst>", r[r.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>', r[r.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', r[r.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', r[r.length] = "</a:lnStyleLst>", r[r.length] = "<a:effectStyleLst>", r[r.length] = "<a:effectStyle>", r[r.length] = "<a:effectLst>", r[r.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>', r[r.length] = "</a:effectLst>", r[r.length] = "</a:effectStyle>", r[r.length] = "<a:effectStyle>", r[r.length] = "<a:effectLst>", r[r.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', r[r.length] = "</a:effectLst>", r[r.length] = "</a:effectStyle>", r[r.length] = "<a:effectStyle>", r[r.length] = "<a:effectLst>", r[r.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', r[r.length] = "</a:effectLst>", r[r.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>', r[r.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>', r[r.length] = "</a:effectStyle>", r[r.length] = "</a:effectStyleLst>", r[r.length] = "<a:bgFillStyleLst>", r[r.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', r[r.length] = '<a:gradFill rotWithShape="1">', r[r.length] = "<a:gsLst>", r[r.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', r[r.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', r[r.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>', r[r.length] = "</a:gsLst>", r[r.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>', r[r.length] = "</a:gradFill>", r[r.length] = '<a:gradFill rotWithShape="1">', r[r.length] = "<a:gsLst>", r[r.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', r[r.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>', r[r.length] = "</a:gsLst>", r[r.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>', r[r.length] = "</a:gradFill>", r[r.length] = "</a:bgFillStyleLst>", r[r.length] = "</a:fmtScheme>", r[r.length] = "</a:themeElements>", r[r.length] = "<a:objectDefaults>", r[r.length] = "<a:spDef>", r[r.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>', r[r.length] = "</a:spDef>", r[r.length] = "<a:lnDef>", r[r.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>', r[r.length] = "</a:lnDef>", r[r.length] = "</a:objectDefaults>", r[r.length] = "<a:extraClrSchemeLst/>", r[r.length] = "</a:theme>", r.join("");
}
function SC(e, t) {
  return {
    flags: e.read_shift(4),
    version: e.read_shift(4),
    name: sr(e)
  };
}
function AC(e) {
  var t = ve(12 + 2 * e.name.length);
  return t.write_shift(4, e.flags), t.write_shift(4, e.version), Bt(e.name, t), t.slice(0, t.l);
}
function RC(e) {
  for (var t = [], r = e.read_shift(4); r-- > 0; )
    t.push([e.read_shift(4), e.read_shift(4)]);
  return t;
}
function $C(e) {
  var t = ve(4 + 8 * e.length);
  t.write_shift(4, e.length);
  for (var r = 0; r < e.length; ++r)
    t.write_shift(4, e[r][0]), t.write_shift(4, e[r][1]);
  return t;
}
function OC(e, t) {
  var r = ve(8 + 2 * t.length);
  return r.write_shift(4, e), Bt(t, r), r.slice(0, r.l);
}
function NC(e) {
  return e.l += 4, e.read_shift(4) != 0;
}
function PC(e, t) {
  var r = ve(8);
  return r.write_shift(4, e), r.write_shift(4, 1), r;
}
function CC() {
  var e = vr();
  return Se(e, 332), Se(e, 334, Xr(1)), Se(e, 335, AC({
    name: "XLDAPR",
    version: 12e4,
    flags: 3496657072
  })), Se(e, 336), Se(e, 339, OC(1, "XLDAPR")), Se(e, 52), Se(e, 35, Xr(514)), Se(e, 4096, Xr(0)), Se(e, 4097, Dr(1)), Se(e, 36), Se(e, 53), Se(e, 340), Se(e, 337, PC(1)), Se(e, 51, $C([[1, 0]])), Se(e, 338), Se(e, 333), e.end();
}
function dx() {
  var e = [Dt];
  return e.push(`<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">
  <metadataTypes count="1">
    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>
  </metadataTypes>
  <futureMetadata name="XLDAPR" count="1">
    <bk>
      <extLst>
        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">
          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>
        </ext>
      </extLst>
    </bk>
  </futureMetadata>
  <cellMetadata count="1">
    <bk>
      <rc t="1" v="0"/>
    </bk>
  </cellMetadata>
</metadata>`), e.join("");
}
function IC(e) {
  var t = {};
  t.i = e.read_shift(4);
  var r = {};
  r.r = e.read_shift(4), r.c = e.read_shift(4), t.r = _t(r);
  var n = e.read_shift(1);
  return n & 2 && (t.l = "1"), n & 8 && (t.a = "1"), t;
}
var Hi = 1024;
function hx(e, t) {
  for (var r = [21600, 21600], n = ["m0,0l0", r[1], r[0], r[1], r[0], "0xe"].join(","), i = [
    be("xml", null, { "xmlns:v": Or.v, "xmlns:o": Or.o, "xmlns:x": Or.x, "xmlns:mv": Or.mv }).replace(/\/>/, ">"),
    be("o:shapelayout", be("o:idmap", null, { "v:ext": "edit", data: e }), { "v:ext": "edit" }),
    be("v:shapetype", [
      be("v:stroke", null, { joinstyle: "miter" }),
      be("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
    ].join(""), { id: "_x0000_t202", "o:spt": 202, coordsize: r.join(","), path: n })
  ]; Hi < e * 1e3; ) Hi += 1e3;
  return t.forEach(function(a) {
    var s = qt(a[0]), o = (
      /*::(*/
      { color2: "#BEFF82", type: "gradient" }
    );
    o.type == "gradient" && (o.angle = "-180");
    var c = o.type == "gradient" ? be("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null, u = be("v:fill", c, o), l = { on: "t", obscured: "t" };
    ++Hi, i = i.concat([
      "<v:shape" + Ja({
        id: "_x0000_s" + Hi,
        type: "#_x0000_t202",
        style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (a[1].hidden ? ";visibility:hidden" : ""),
        fillcolor: "#ECFAD4",
        strokecolor: "#edeaa1"
      }) + ">",
      u,
      be("v:shadow", null, l),
      be("v:path", null, { "o:connecttype": "none" }),
      '<v:textbox><div style="text-align:left"></div></v:textbox>',
      '<x:ClientData ObjectType="Note">',
      "<x:MoveWithCells/>",
      "<x:SizeWithCells/>",
      /* Part 4 19.4.2.3 Anchor (Anchor) */
      Xt("x:Anchor", [s.c + 1, 0, s.r + 1, 0, s.c + 3, 20, s.r + 5, 20].join(",")),
      Xt("x:AutoFill", "False"),
      Xt("x:Row", String(s.r)),
      Xt("x:Column", String(s.c)),
      a[1].hidden ? "" : "<x:Visible/>",
      "</x:ClientData>",
      "</v:shape>"
    ]);
  }), i.push("</xml>"), i.join("");
}
function px(e) {
  var t = [Dt, be("comments", null, { xmlns: ra[0] })], r = [];
  return t.push("<authors>"), e.forEach(function(n) {
    n[1].forEach(function(i) {
      var a = gt(i.a);
      r.indexOf(a) == -1 && (r.push(a), t.push("<author>" + a + "</author>")), i.T && i.ID && r.indexOf("tc=" + i.ID) == -1 && (r.push("tc=" + i.ID), t.push("<author>tc=" + i.ID + "</author>"));
    });
  }), r.length == 0 && (r.push("SheetJ5"), t.push("<author>SheetJ5</author>")), t.push("</authors>"), t.push("<commentList>"), e.forEach(function(n) {
    var i = 0, a = [];
    if (n[1][0] && n[1][0].T && n[1][0].ID ? i = r.indexOf("tc=" + n[1][0].ID) : n[1].forEach(function(c) {
      c.a && (i = r.indexOf(gt(c.a))), a.push(c.t || "");
    }), t.push('<comment ref="' + n[0] + '" authorId="' + i + '"><text>'), a.length <= 1) t.push(Xt("t", gt(a[0] || "")));
    else {
      for (var s = `Comment:
    ` + a[0] + `
`, o = 1; o < a.length; ++o) s += `Reply:
    ` + a[o] + `
`;
      t.push(Xt("t", gt(s)));
    }
    t.push("</text></comment>");
  }), t.push("</commentList>"), t.length > 2 && (t[t.length] = "</comments>", t[1] = t[1].replace("/>", ">")), t.join("");
}
function bC(e, t, r) {
  var n = [Dt, be("ThreadedComments", null, { xmlns: Ut.TCMNT }).replace(/[\/]>/, ">")];
  return e.forEach(function(i) {
    var a = "";
    (i[1] || []).forEach(function(s, o) {
      if (!s.T) {
        delete s.ID;
        return;
      }
      s.a && t.indexOf(s.a) == -1 && t.push(s.a);
      var c = {
        ref: i[0],
        id: "{54EE7951-7262-4200-6969-" + ("000000000000" + r.tcid++).slice(-12) + "}"
      };
      o == 0 ? a = c.id : c.parentId = a, s.ID = c.id, s.a && (c.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + t.indexOf(s.a)).slice(-12) + "}"), n.push(be("threadedComment", Xt("text", s.t || ""), c));
    });
  }), n.push("</ThreadedComments>"), n.join("");
}
function FC(e) {
  var t = [Dt, be("personList", null, {
    xmlns: Ut.TCMNT,
    "xmlns:x": ra[0]
  }).replace(/[\/]>/, ">")];
  return e.forEach(function(r, n) {
    t.push(be("person", null, {
      displayName: r,
      id: "{54EE7950-7262-4200-6969-" + ("000000000000" + n).slice(-12) + "}",
      userId: r,
      providerId: "None"
    }));
  }), t.push("</personList>"), t.join("");
}
function DC(e) {
  var t = {};
  t.iauthor = e.read_shift(4);
  var r = Ai(e);
  return t.rfx = r.s, t.ref = _t(r.s), e.l += 16, t;
}
function kC(e, t) {
  return t == null && (t = ve(36)), t.write_shift(4, e[1].iauthor), ia(e[0], t), t.write_shift(4, 0), t.write_shift(4, 0), t.write_shift(4, 0), t.write_shift(4, 0), t;
}
var LC = sr;
function MC(e) {
  return Bt(e.slice(0, 54));
}
function UC(e) {
  var t = vr(), r = [];
  return Se(
    t,
    628
    /* BrtBeginComments */
  ), Se(
    t,
    630
    /* BrtBeginCommentAuthors */
  ), e.forEach(function(n) {
    n[1].forEach(function(i) {
      r.indexOf(i.a) > -1 || (r.push(i.a.slice(0, 54)), Se(t, 632, MC(i.a)));
    });
  }), Se(
    t,
    631
    /* BrtEndCommentAuthors */
  ), Se(
    t,
    633
    /* BrtBeginCommentList */
  ), e.forEach(function(n) {
    n[1].forEach(function(i) {
      i.iauthor = r.indexOf(i.a);
      var a = { s: qt(n[0]), e: qt(n[0]) };
      Se(t, 635, kC([a, i])), i.t && i.t.length > 0 && Se(t, 637, BN(i)), Se(
        t,
        636
        /* BrtEndComment */
      ), delete i.iauthor;
    });
  }), Se(
    t,
    634
    /* BrtEndCommentList */
  ), Se(
    t,
    629
    /* BrtEndComments */
  ), t.end();
}
function qC(e, t) {
  t.FullPaths.forEach(function(r, n) {
    if (n != 0) {
      var i = r.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
      i.slice(-1) !== "/" && xt.utils.cfb_add(e, i, t.FileIndex[n].content);
    }
  });
}
var mx = ["xlsb", "xlsm", "xlam", "biff8", "xla"], BC = /* @__PURE__ */ (function() {
  var e = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g, t = { r: 0, c: 0 };
  function r(n, i, a, s) {
    var o = !1, c = !1;
    a.length == 0 ? c = !0 : a.charAt(0) == "[" && (c = !0, a = a.slice(1, -1)), s.length == 0 ? o = !0 : s.charAt(0) == "[" && (o = !0, s = s.slice(1, -1));
    var u = a.length > 0 ? parseInt(a, 10) | 0 : 0, l = s.length > 0 ? parseInt(s, 10) | 0 : 0;
    return o ? l += t.c : --l, c ? u += t.r : --u, i + (o ? "" : "$") + ar(l) + (c ? "" : "$") + Kt(u);
  }
  return function(i, a) {
    return t = a, i.replace(e, r);
  };
})(), ih = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g, ah = /* @__PURE__ */ (function() {
  return function(t, r) {
    return t.replace(ih, function(n, i, a, s, o, c) {
      var u = Q0(s) - (a ? 0 : r.c), l = J0(c) - (o ? 0 : r.r), d = l == 0 ? "" : o ? l + 1 : "[" + l + "]", f = u == 0 ? "" : a ? u + 1 : "[" + u + "]";
      return i + "R" + d + "C" + f;
    });
  };
})();
function jC(e, t) {
  return e.replace(ih, function(r, n, i, a, s, o) {
    return n + (i == "$" ? i + a : ar(Q0(a) + t.c)) + (s == "$" ? s + o : Kt(J0(o) + t.r));
  });
}
function VC(e) {
  return e.length != 1;
}
function bt(e) {
  e.l += 1;
}
function Hn(e, t) {
  var r = e.read_shift(2);
  return [r & 16383, r >> 14 & 1, r >> 15 & 1];
}
function gx(e, t, r) {
  var n = 2;
  if (r) {
    if (r.biff >= 2 && r.biff <= 5) return vx(e);
    r.biff == 12 && (n = 4);
  }
  var i = e.read_shift(n), a = e.read_shift(n), s = Hn(e), o = Hn(e);
  return { s: { r: i, c: s[0], cRel: s[1], rRel: s[2] }, e: { r: a, c: o[0], cRel: o[1], rRel: o[2] } };
}
function vx(e) {
  var t = Hn(e), r = Hn(e), n = e.read_shift(1), i = e.read_shift(1);
  return { s: { r: t[0], c: n, cRel: t[1], rRel: t[2] }, e: { r: r[0], c: i, cRel: r[1], rRel: r[2] } };
}
function HC(e, t, r) {
  if (r.biff < 8) return vx(e);
  var n = e.read_shift(r.biff == 12 ? 4 : 2), i = e.read_shift(r.biff == 12 ? 4 : 2), a = Hn(e), s = Hn(e);
  return { s: { r: n, c: a[0], cRel: a[1], rRel: a[2] }, e: { r: i, c: s[0], cRel: s[1], rRel: s[2] } };
}
function _x(e, t, r) {
  if (r && r.biff >= 2 && r.biff <= 5) return GC(e);
  var n = e.read_shift(r && r.biff == 12 ? 4 : 2), i = Hn(e);
  return { r: n, c: i[0], cRel: i[1], rRel: i[2] };
}
function GC(e) {
  var t = Hn(e), r = e.read_shift(1);
  return { r: t[0], c: r, cRel: t[1], rRel: t[2] };
}
function zC(e) {
  var t = e.read_shift(2), r = e.read_shift(2);
  return { r: t, c: r & 255, fQuoted: !!(r & 16384), cRel: r >> 15, rRel: r >> 15 };
}
function WC(e, t, r) {
  var n = r && r.biff ? r.biff : 8;
  if (n >= 2 && n <= 5) return XC(e);
  var i = e.read_shift(n >= 12 ? 4 : 2), a = e.read_shift(2), s = (a & 16384) >> 14, o = (a & 32768) >> 15;
  if (a &= 16383, o == 1) for (; i > 524287; ) i -= 1048576;
  if (s == 1) for (; a > 8191; ) a = a - 16384;
  return { r: i, c: a, cRel: s, rRel: o };
}
function XC(e) {
  var t = e.read_shift(2), r = e.read_shift(1), n = (t & 32768) >> 15, i = (t & 16384) >> 14;
  return t &= 16383, n == 1 && t >= 8192 && (t = t - 16384), i == 1 && r >= 128 && (r = r - 256), { r: t, c: r, cRel: i, rRel: n };
}
function KC(e, t, r) {
  var n = (e[e.l++] & 96) >> 5, i = gx(e, r.biff >= 2 && r.biff <= 5 ? 6 : 8, r);
  return [n, i];
}
function YC(e, t, r) {
  var n = (e[e.l++] & 96) >> 5, i = e.read_shift(2, "i"), a = 8;
  if (r) switch (r.biff) {
    case 5:
      e.l += 12, a = 6;
      break;
    case 12:
      a = 12;
      break;
  }
  var s = gx(e, a, r);
  return [n, i, s];
}
function JC(e, t, r) {
  var n = (e[e.l++] & 96) >> 5;
  return e.l += r && r.biff > 8 ? 12 : r.biff < 8 ? 6 : 8, [n];
}
function QC(e, t, r) {
  var n = (e[e.l++] & 96) >> 5, i = e.read_shift(2), a = 8;
  if (r) switch (r.biff) {
    case 5:
      e.l += 12, a = 6;
      break;
    case 12:
      a = 12;
      break;
  }
  return e.l += a, [n, i];
}
function ZC(e, t, r) {
  var n = (e[e.l++] & 96) >> 5, i = HC(e, t - 1, r);
  return [n, i];
}
function eI(e, t, r) {
  var n = (e[e.l++] & 96) >> 5;
  return e.l += r.biff == 2 ? 6 : r.biff == 12 ? 14 : 7, [n];
}
function Vy(e) {
  var t = e[e.l + 1] & 1, r = 1;
  return e.l += 4, [t, r];
}
function tI(e, t, r) {
  e.l += 2;
  for (var n = e.read_shift(r && r.biff == 2 ? 1 : 2), i = [], a = 0; a <= n; ++a) i.push(e.read_shift(r && r.biff == 2 ? 1 : 2));
  return i;
}
function rI(e, t, r) {
  var n = e[e.l + 1] & 255 ? 1 : 0;
  return e.l += 2, [n, e.read_shift(r && r.biff == 2 ? 1 : 2)];
}
function nI(e, t, r) {
  var n = e[e.l + 1] & 255 ? 1 : 0;
  return e.l += 2, [n, e.read_shift(r && r.biff == 2 ? 1 : 2)];
}
function iI(e) {
  var t = e[e.l + 1] & 255 ? 1 : 0;
  return e.l += 2, [t, e.read_shift(2)];
}
function aI(e, t, r) {
  var n = e[e.l + 1] & 255 ? 1 : 0;
  return e.l += r && r.biff == 2 ? 3 : 4, [n];
}
function yx(e) {
  var t = e.read_shift(1), r = e.read_shift(1);
  return [t, r];
}
function sI(e) {
  return e.read_shift(2), yx(e);
}
function oI(e) {
  return e.read_shift(2), yx(e);
}
function cI(e, t, r) {
  var n = (e[e.l] & 96) >> 5;
  e.l += 1;
  var i = _x(e, 0, r);
  return [n, i];
}
function lI(e, t, r) {
  var n = (e[e.l] & 96) >> 5;
  e.l += 1;
  var i = WC(e, 0, r);
  return [n, i];
}
function uI(e, t, r) {
  var n = (e[e.l] & 96) >> 5;
  e.l += 1;
  var i = e.read_shift(2);
  r && r.biff == 5 && (e.l += 12);
  var a = _x(e, 0, r);
  return [n, i, a];
}
function fI(e, t, r) {
  var n = (e[e.l] & 96) >> 5;
  e.l += 1;
  var i = e.read_shift(r && r.biff <= 3 ? 1 : 2);
  return [fb[i], xx[i], n];
}
function dI(e, t, r) {
  var n = e[e.l++], i = e.read_shift(1), a = r && r.biff <= 3 ? [n == 88 ? -1 : 0, e.read_shift(1)] : hI(e);
  return [i, (a[0] === 0 ? xx : ub)[a[1]]];
}
function hI(e) {
  return [e[e.l + 1] >> 7, e.read_shift(2) & 32767];
}
function pI(e, t, r) {
  e.l += r && r.biff == 2 ? 3 : 4;
}
function mI(e, t, r) {
  if (e.l++, r && r.biff == 12) return [e.read_shift(4, "i"), 0];
  var n = e.read_shift(2), i = e.read_shift(r && r.biff == 2 ? 1 : 2);
  return [n, i];
}
function gI(e) {
  return e.l++, ls[e.read_shift(1)];
}
function vI(e) {
  return e.l++, e.read_shift(2);
}
function _I(e) {
  return e.l++, e.read_shift(1) !== 0;
}
function yI(e) {
  return e.l++, aa(e);
}
function EI(e, t, r) {
  return e.l++, tx(e, t - 1, r);
}
function wI(e, t) {
  var r = [e.read_shift(1)];
  if (t == 12) switch (r[0]) {
    case 2:
      r[0] = 4;
      break;
    /* SerBool */
    case 4:
      r[0] = 16;
      break;
    /* SerErr */
    case 0:
      r[0] = 1;
      break;
    /* SerNum */
    case 1:
      r[0] = 2;
      break;
  }
  switch (r[0]) {
    case 4:
      r[1] = uP(e, 1) ? "TRUE" : "FALSE", t != 12 && (e.l += 7);
      break;
    case 37:
    /* appears to be an alias */
    case 16:
      r[1] = ls[e[e.l]], e.l += t == 12 ? 4 : 8;
      break;
    case 0:
      e.l += 8;
      break;
    case 1:
      r[1] = aa(e);
      break;
    case 2:
      r[1] = pP(e, 0, { biff: t > 0 && t < 8 ? 2 : t });
      break;
    default:
      throw new Error("Bad SerAr: " + r[0]);
  }
  return r;
}
function xI(e, t, r) {
  for (var n = e.read_shift(r.biff == 12 ? 4 : 2), i = [], a = 0; a != n; ++a) i.push((r.biff == 12 ? Ai : vP)(e));
  return i;
}
function TI(e, t, r) {
  var n = 0, i = 0;
  r.biff == 12 ? (n = e.read_shift(4), i = e.read_shift(4)) : (i = 1 + e.read_shift(1), n = 1 + e.read_shift(2)), r.biff >= 2 && r.biff < 8 && (--n, --i == 0 && (i = 256));
  for (var a = 0, s = []; a != n && (s[a] = []); ++a)
    for (var o = 0; o != i; ++o) s[a][o] = wI(e, r.biff);
  return s;
}
function SI(e, t, r) {
  var n = e.read_shift(1) >>> 5 & 3, i = !r || r.biff >= 8 ? 4 : 2, a = e.read_shift(i);
  switch (r.biff) {
    case 2:
      e.l += 5;
      break;
    case 3:
    case 4:
      e.l += 8;
      break;
    case 5:
      e.l += 12;
      break;
  }
  return [n, 0, a];
}
function AI(e, t, r) {
  if (r.biff == 5) return RI(e);
  var n = e.read_shift(1) >>> 5 & 3, i = e.read_shift(2), a = e.read_shift(4);
  return [n, i, a];
}
function RI(e) {
  var t = e.read_shift(1) >>> 5 & 3, r = e.read_shift(2, "i");
  e.l += 8;
  var n = e.read_shift(2);
  return e.l += 12, [t, r, n];
}
function $I(e, t, r) {
  var n = e.read_shift(1) >>> 5 & 3;
  e.l += r && r.biff == 2 ? 3 : 4;
  var i = e.read_shift(r && r.biff == 2 ? 1 : 2);
  return [n, i];
}
function OI(e, t, r) {
  var n = e.read_shift(1) >>> 5 & 3, i = e.read_shift(r && r.biff == 2 ? 1 : 2);
  return [n, i];
}
function NI(e, t, r) {
  var n = e.read_shift(1) >>> 5 & 3;
  return e.l += 4, r.biff < 8 && e.l--, r.biff == 12 && (e.l += 2), [n];
}
function PI(e, t, r) {
  var n = (e[e.l++] & 96) >> 5, i = e.read_shift(2), a = 4;
  if (r) switch (r.biff) {
    case 5:
      a = 15;
      break;
    case 12:
      a = 6;
      break;
  }
  return e.l += a, [n, i];
}
var CI = on, II = on, bI = on;
function us(e, t, r) {
  return e.l += 2, [zC(e)];
}
function sh(e) {
  return e.l += 6, [];
}
var FI = us, DI = sh, kI = sh, LI = us;
function Ex(e) {
  return e.l += 2, [Zw(e), e.read_shift(2) & 1];
}
var MI = us, UI = Ex, qI = sh, BI = us, jI = us, VI = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function HI(e) {
  e.l += 2;
  var t = e.read_shift(2), r = e.read_shift(2), n = e.read_shift(4), i = e.read_shift(2), a = e.read_shift(2), s = VI[r >> 2 & 31];
  return { ixti: t, coltype: r & 3, rt: s, idx: n, c: i, C: a };
}
function GI(e) {
  return e.l += 2, [e.read_shift(4)];
}
function zI(e, t, r) {
  return e.l += 5, e.l += 2, e.l += r.biff == 2 ? 1 : 4, ["PTGSHEET"];
}
function WI(e, t, r) {
  return e.l += r.biff == 2 ? 4 : 5, ["PTGENDSHEET"];
}
function XI(e) {
  var t = e.read_shift(1) >>> 5 & 3, r = e.read_shift(2);
  return [t, r];
}
function KI(e) {
  var t = e.read_shift(1) >>> 5 & 3, r = e.read_shift(2);
  return [t, r];
}
function YI(e) {
  return e.l += 4, [0, 0];
}
var Hy = {
  /*::[*/
  1: { n: "PtgExp", f: mI },
  /*::[*/
  2: { n: "PtgTbl", f: bI },
  /*::[*/
  3: { n: "PtgAdd", f: bt },
  /*::[*/
  4: { n: "PtgSub", f: bt },
  /*::[*/
  5: { n: "PtgMul", f: bt },
  /*::[*/
  6: { n: "PtgDiv", f: bt },
  /*::[*/
  7: { n: "PtgPower", f: bt },
  /*::[*/
  8: { n: "PtgConcat", f: bt },
  /*::[*/
  9: { n: "PtgLt", f: bt },
  /*::[*/
  10: { n: "PtgLe", f: bt },
  /*::[*/
  11: { n: "PtgEq", f: bt },
  /*::[*/
  12: { n: "PtgGe", f: bt },
  /*::[*/
  13: { n: "PtgGt", f: bt },
  /*::[*/
  14: { n: "PtgNe", f: bt },
  /*::[*/
  15: { n: "PtgIsect", f: bt },
  /*::[*/
  16: { n: "PtgUnion", f: bt },
  /*::[*/
  17: { n: "PtgRange", f: bt },
  /*::[*/
  18: { n: "PtgUplus", f: bt },
  /*::[*/
  19: { n: "PtgUminus", f: bt },
  /*::[*/
  20: { n: "PtgPercent", f: bt },
  /*::[*/
  21: { n: "PtgParen", f: bt },
  /*::[*/
  22: { n: "PtgMissArg", f: bt },
  /*::[*/
  23: { n: "PtgStr", f: EI },
  /*::[*/
  26: { n: "PtgSheet", f: zI },
  /*::[*/
  27: { n: "PtgEndSheet", f: WI },
  /*::[*/
  28: { n: "PtgErr", f: gI },
  /*::[*/
  29: { n: "PtgBool", f: _I },
  /*::[*/
  30: { n: "PtgInt", f: vI },
  /*::[*/
  31: { n: "PtgNum", f: yI },
  /*::[*/
  32: { n: "PtgArray", f: eI },
  /*::[*/
  33: { n: "PtgFunc", f: fI },
  /*::[*/
  34: { n: "PtgFuncVar", f: dI },
  /*::[*/
  35: { n: "PtgName", f: SI },
  /*::[*/
  36: { n: "PtgRef", f: cI },
  /*::[*/
  37: { n: "PtgArea", f: KC },
  /*::[*/
  38: { n: "PtgMemArea", f: $I },
  /*::[*/
  39: { n: "PtgMemErr", f: CI },
  /*::[*/
  40: { n: "PtgMemNoMem", f: II },
  /*::[*/
  41: { n: "PtgMemFunc", f: OI },
  /*::[*/
  42: { n: "PtgRefErr", f: NI },
  /*::[*/
  43: { n: "PtgAreaErr", f: JC },
  /*::[*/
  44: { n: "PtgRefN", f: lI },
  /*::[*/
  45: { n: "PtgAreaN", f: ZC },
  /*::[*/
  46: { n: "PtgMemAreaN", f: XI },
  /*::[*/
  47: { n: "PtgMemNoMemN", f: KI },
  /*::[*/
  57: { n: "PtgNameX", f: AI },
  /*::[*/
  58: { n: "PtgRef3d", f: uI },
  /*::[*/
  59: { n: "PtgArea3d", f: YC },
  /*::[*/
  60: { n: "PtgRefErr3d", f: PI },
  /*::[*/
  61: { n: "PtgAreaErr3d", f: QC },
  /*::[*/
  255: {}
}, JI = {
  /*::[*/
  64: 32,
  /*::[*/
  96: 32,
  /*::[*/
  65: 33,
  /*::[*/
  97: 33,
  /*::[*/
  66: 34,
  /*::[*/
  98: 34,
  /*::[*/
  67: 35,
  /*::[*/
  99: 35,
  /*::[*/
  68: 36,
  /*::[*/
  100: 36,
  /*::[*/
  69: 37,
  /*::[*/
  101: 37,
  /*::[*/
  70: 38,
  /*::[*/
  102: 38,
  /*::[*/
  71: 39,
  /*::[*/
  103: 39,
  /*::[*/
  72: 40,
  /*::[*/
  104: 40,
  /*::[*/
  73: 41,
  /*::[*/
  105: 41,
  /*::[*/
  74: 42,
  /*::[*/
  106: 42,
  /*::[*/
  75: 43,
  /*::[*/
  107: 43,
  /*::[*/
  76: 44,
  /*::[*/
  108: 44,
  /*::[*/
  77: 45,
  /*::[*/
  109: 45,
  /*::[*/
  78: 46,
  /*::[*/
  110: 46,
  /*::[*/
  79: 47,
  /*::[*/
  111: 47,
  /*::[*/
  88: 34,
  /*::[*/
  120: 34,
  /*::[*/
  89: 57,
  /*::[*/
  121: 57,
  /*::[*/
  90: 58,
  /*::[*/
  122: 58,
  /*::[*/
  91: 59,
  /*::[*/
  123: 59,
  /*::[*/
  92: 60,
  /*::[*/
  124: 60,
  /*::[*/
  93: 61,
  /*::[*/
  125: 61
}, QI = {
  /*::[*/
  1: { n: "PtgElfLel", f: Ex },
  /*::[*/
  2: { n: "PtgElfRw", f: BI },
  /*::[*/
  3: { n: "PtgElfCol", f: FI },
  /*::[*/
  6: { n: "PtgElfRwV", f: jI },
  /*::[*/
  7: { n: "PtgElfColV", f: LI },
  /*::[*/
  10: { n: "PtgElfRadical", f: MI },
  /*::[*/
  11: { n: "PtgElfRadicalS", f: qI },
  /*::[*/
  13: { n: "PtgElfColS", f: DI },
  /*::[*/
  15: { n: "PtgElfColSV", f: kI },
  /*::[*/
  16: { n: "PtgElfRadicalLel", f: UI },
  /*::[*/
  25: { n: "PtgList", f: HI },
  /*::[*/
  29: { n: "PtgSxName", f: GI },
  /*::[*/
  255: {}
}, ZI = {
  /*::[*/
  0: { n: "PtgAttrNoop", f: YI },
  /*::[*/
  1: { n: "PtgAttrSemi", f: aI },
  /*::[*/
  2: { n: "PtgAttrIf", f: nI },
  /*::[*/
  4: { n: "PtgAttrChoose", f: tI },
  /*::[*/
  8: { n: "PtgAttrGoto", f: rI },
  /*::[*/
  16: { n: "PtgAttrSum", f: pI },
  /*::[*/
  32: { n: "PtgAttrBaxcel", f: Vy },
  /*::[*/
  33: { n: "PtgAttrBaxcel", f: Vy },
  /*::[*/
  64: { n: "PtgAttrSpace", f: sI },
  /*::[*/
  65: { n: "PtgAttrSpaceSemi", f: oI },
  /*::[*/
  128: { n: "PtgAttrIfError", f: iI },
  /*::[*/
  255: {}
};
function eb(e, t, r, n) {
  if (n.biff < 8) return on(e, t);
  for (var i = e.l + t, a = [], s = 0; s !== r.length; ++s)
    switch (r[s][0]) {
      case "PtgArray":
        r[s][1] = TI(e, 0, n), a.push(r[s][1]);
        break;
      case "PtgMemArea":
        r[s][2] = xI(e, r[s][1], n), a.push(r[s][2]);
        break;
      case "PtgExp":
        n && n.biff == 12 && (r[s][1][1] = e.read_shift(4), a.push(r[s][1]));
        break;
      case "PtgList":
      /* TODO: PtgList -> PtgExtraList */
      case "PtgElfRadicalS":
      /* TODO: PtgElfRadicalS -> PtgExtraElf */
      case "PtgElfColS":
      /* TODO: PtgElfColS -> PtgExtraElf */
      case "PtgElfColSV":
        throw "Unsupported " + r[s][0];
    }
  return t = i - e.l, t !== 0 && a.push(on(e, t)), a;
}
function tb(e, t, r) {
  for (var n = e.l + t, i, a, s = []; n != e.l; )
    t = n - e.l, a = e[e.l], i = Hy[a] || Hy[JI[a]], (a === 24 || a === 25) && (i = (a === 24 ? QI : ZI)[e[e.l + 1]]), !i || !i.f ? on(e, t) : s.push([i.n, i.f(e, t, r)]);
  return s;
}
function rb(e) {
  for (var t = [], r = 0; r < e.length; ++r) {
    for (var n = e[r], i = [], a = 0; a < n.length; ++a) {
      var s = n[a];
      if (s) switch (s[0]) {
        // TODO: handle embedded quotes
        case 2:
          i.push('"' + s[1].replace(/"/g, '""') + '"');
          break;
        default:
          i.push(s[1]);
      }
      else i.push("");
    }
    t.push(i.join(","));
  }
  return t.join(";");
}
var nb = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function ib(e, t) {
  if (!e && !(t && t.biff <= 5 && t.biff >= 2)) throw new Error("empty sheet name");
  return /[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(e) ? "'" + e + "'" : e;
}
function wx(e, t, r) {
  if (!e) return "SH33TJSERR0";
  if (r.biff > 8 && (!e.XTI || !e.XTI[t])) return e.SheetNames[t];
  if (!e.XTI) return "SH33TJSERR6";
  var n = e.XTI[t];
  if (r.biff < 8)
    return t > 1e4 && (t -= 65536), t < 0 && (t = -t), t == 0 ? "" : e.XTI[t - 1];
  if (!n) return "SH33TJSERR1";
  var i = "";
  if (r.biff > 8) switch (e[n[0]][0]) {
    case 357:
      return i = n[1] == -1 ? "#REF" : e.SheetNames[n[1]], n[1] == n[2] ? i : i + ":" + e.SheetNames[n[2]];
    case 358:
      return r.SID != null ? e.SheetNames[r.SID] : "SH33TJSSAME" + e[n[0]][0];
    case 355:
    /* 'BrtSupBookSrc' */
    /* falls through */
    default:
      return "SH33TJSSRC" + e[n[0]][0];
  }
  switch (e[n[0]][0][0]) {
    case 1025:
      return i = n[1] == -1 ? "#REF" : e.SheetNames[n[1]] || "SH33TJSERR3", n[1] == n[2] ? i : i + ":" + e.SheetNames[n[2]];
    case 14849:
      return e[n[0]].slice(1).map(function(a) {
        return a.Name;
      }).join(";;");
    //return "SH33TJSERR8";
    default:
      return e[n[0]][0][3] ? (i = n[1] == -1 ? "#REF" : e[n[0]][0][3][n[1]] || "SH33TJSERR4", n[1] == n[2] ? i : i + ":" + e[n[0]][0][3][n[2]]) : "SH33TJSERR2";
  }
}
function Gy(e, t, r) {
  var n = wx(e, t, r);
  return n == "#REF" ? n : ib(n, r);
}
function Ki(e, t, r, n, i) {
  var a = i && i.biff || 8, s = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 } }
  ), o = [], c, u, l, d = 0, f = 0, p, v = "";
  if (!e[0] || !e[0][0]) return "";
  for (var m = -1, h = "", _ = 0, g = e[0].length; _ < g; ++_) {
    var y = e[0][_];
    switch (y[0]) {
      case "PtgUminus":
        o.push("-" + o.pop());
        break;
      case "PtgUplus":
        o.push("+" + o.pop());
        break;
      case "PtgPercent":
        o.push(o.pop() + "%");
        break;
      case "PtgAdd":
      /* [MS-XLS] 2.5.198.26 */
      case "PtgConcat":
      /* [MS-XLS] 2.5.198.43 */
      case "PtgDiv":
      /* [MS-XLS] 2.5.198.45 */
      case "PtgEq":
      /* [MS-XLS] 2.5.198.56 */
      case "PtgGe":
      /* [MS-XLS] 2.5.198.64 */
      case "PtgGt":
      /* [MS-XLS] 2.5.198.65 */
      case "PtgLe":
      /* [MS-XLS] 2.5.198.68 */
      case "PtgLt":
      /* [MS-XLS] 2.5.198.69 */
      case "PtgMul":
      /* [MS-XLS] 2.5.198.75 */
      case "PtgNe":
      /* [MS-XLS] 2.5.198.78 */
      case "PtgPower":
      /* [MS-XLS] 2.5.198.82 */
      case "PtgSub":
        if (c = o.pop(), u = o.pop(), m >= 0) {
          switch (e[0][m][1][0]) {
            case 0:
              h = Pt(" ", e[0][m][1][1]);
              break;
            case 1:
              h = Pt("\r", e[0][m][1][1]);
              break;
            default:
              if (h = "", i.WTF) throw new Error("Unexpected PtgAttrSpaceType " + e[0][m][1][0]);
          }
          u = u + h, m = -1;
        }
        o.push(u + nb[y[0]] + c);
        break;
      case "PtgIsect":
        c = o.pop(), u = o.pop(), o.push(u + " " + c);
        break;
      case "PtgUnion":
        c = o.pop(), u = o.pop(), o.push(u + "," + c);
        break;
      case "PtgRange":
        c = o.pop(), u = o.pop(), o.push(u + ":" + c);
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        l = Ha(y[1][1], s, i), o.push(Ga(l, a));
        break;
      case "PtgRefN":
        l = r ? Ha(y[1][1], r, i) : y[1][1], o.push(Ga(l, a));
        break;
      case "PtgRef3d":
        d = /*::Number(*/
        y[1][1], l = Ha(y[1][2], s, i), v = Gy(n, d, i), o.push(v + "!" + Ga(l, a));
        break;
      case "PtgFunc":
      /* [MS-XLS] 2.5.198.62 */
      case "PtgFuncVar":
        var x = y[1][0], S = y[1][1];
        x || (x = 0), x &= 127;
        var w = x == 0 ? [] : o.slice(-x);
        o.length -= x, S === "User" && (S = w.shift()), o.push(S + "(" + w.join(",") + ")");
        break;
      case "PtgBool":
        o.push(y[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        o.push(
          /*::String(*/
          y[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        o.push(String(y[1]));
        break;
      case "PtgStr":
        o.push('"' + y[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        o.push(
          /*::String(*/
          y[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        p = Ny(y[1][1], r ? { s: r } : s, i), o.push(Yd(p, i));
        break;
      case "PtgArea":
        p = Ny(y[1][1], s, i), o.push(Yd(p, i));
        break;
      case "PtgArea3d":
        d = /*::Number(*/
        y[1][1], p = y[1][2], v = Gy(n, d, i), o.push(v + "!" + Yd(p, i));
        break;
      case "PtgAttrSum":
        o.push("SUM(" + o.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      /* [MS-XLS] 2.5.198.33 */
      case "PtgAttrSemi":
        break;
      case "PtgName":
        f = y[1][2];
        var E = (n.names || [])[f - 1] || (n[0] || [])[f], R = E ? E.Name : "SH33TJSNAME" + String(f);
        R && R.slice(0, 6) == "_xlfn." && !i.xlfn && (R = R.slice(6)), o.push(R);
        break;
      case "PtgNameX":
        var N = y[1][1];
        f = y[1][2];
        var B;
        if (i.biff <= 5)
          N < 0 && (N = -N), n[N] && (B = n[N][f]);
        else {
          var F = "";
          if (((n[N] || [])[0] || [])[0] == 14849 || (((n[N] || [])[0] || [])[0] == 1025 ? n[N][f] && n[N][f].itab > 0 && (F = n.SheetNames[n[N][f].itab - 1] + "!") : F = n.SheetNames[f - 1] + "!"), n[N] && n[N][f]) F += n[N][f].Name;
          else if (n[0] && n[0][f]) F += n[0][f].Name;
          else {
            var U = (wx(n, N, i) || "").split(";;");
            U[f - 1] ? F = U[f - 1] : F += "SH33TJSERRX";
          }
          o.push(F);
          break;
        }
        B || (B = { Name: "SH33TJSERRY" }), o.push(B.Name);
        break;
      case "PtgParen":
        var G = "(", M = ")";
        if (m >= 0) {
          switch (h = "", e[0][m][1][0]) {
            // $FlowIgnore
            case 2:
              G = Pt(" ", e[0][m][1][1]) + G;
              break;
            // $FlowIgnore
            case 3:
              G = Pt("\r", e[0][m][1][1]) + G;
              break;
            // $FlowIgnore
            case 4:
              M = Pt(" ", e[0][m][1][1]) + M;
              break;
            // $FlowIgnore
            case 5:
              M = Pt("\r", e[0][m][1][1]) + M;
              break;
            default:
              if (i.WTF) throw new Error("Unexpected PtgAttrSpaceType " + e[0][m][1][0]);
          }
          m = -1;
        }
        o.push(G + o.pop() + M);
        break;
      case "PtgRefErr":
        o.push("#REF!");
        break;
      case "PtgRefErr3d":
        o.push("#REF!");
        break;
      case "PtgExp":
        l = { c: y[1][1], r: y[1][0] };
        var V = { c: r.c, r: r.r };
        if (n.sharedf[_t(l)]) {
          var ie = n.sharedf[_t(l)];
          o.push(Ki(ie, s, V, n, i));
        } else {
          var W = !1;
          for (c = 0; c != n.arrayf.length; ++c)
            if (u = n.arrayf[c], !(l.c < u[0].s.c || l.c > u[0].e.c) && !(l.r < u[0].s.r || l.r > u[0].e.r)) {
              o.push(Ki(u[1], s, V, n, i)), W = !0;
              break;
            }
          W || o.push(
            /*::String(*/
            y[1]
            /*::)*/
          );
        }
        break;
      case "PtgArray":
        o.push("{" + rb(
          /*::(*/
          y[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      /* [MS-XLS] 2.5.198.38 */
      case "PtgAttrSpaceSemi":
        m = _;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        o.push("");
        break;
      case "PtgAreaErr":
        o.push("#REF!");
        break;
      case "PtgAreaErr3d":
        o.push("#REF!");
        break;
      case "PtgList":
        o.push("Table" + y[1].idx + "[#" + y[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      /* [MS-XLS] 2.5.198.46 */
      case "PtgElfColS":
      /* [MS-XLS] 2.5.198.47 */
      case "PtgElfColSV":
      /* [MS-XLS] 2.5.198.48 */
      case "PtgElfColV":
      /* [MS-XLS] 2.5.198.49 */
      case "PtgElfLel":
      /* [MS-XLS] 2.5.198.50 */
      case "PtgElfRadical":
      /* [MS-XLS] 2.5.198.51 */
      case "PtgElfRadicalLel":
      /* [MS-XLS] 2.5.198.52 */
      case "PtgElfRadicalS":
      /* [MS-XLS] 2.5.198.53 */
      case "PtgElfRw":
      /* [MS-XLS] 2.5.198.54 */
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(y));
      default:
        throw new Error("Unrecognized Formula Token: " + String(y));
    }
    var ae = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (i.biff != 3 && m >= 0 && ae.indexOf(e[0][_][0]) == -1) {
      y = e[0][m];
      var se = !0;
      switch (y[1][0]) {
        /* note: some bad XLSB files omit the PtgParen */
        case 4:
          se = !1;
        /* falls through */
        case 0:
          h = Pt(" ", y[1][1]);
          break;
        case 5:
          se = !1;
        /* falls through */
        case 1:
          h = Pt("\r", y[1][1]);
          break;
        default:
          if (h = "", i.WTF) throw new Error("Unexpected PtgAttrSpaceType " + y[1][0]);
      }
      o.push((se ? h : "") + o.pop() + (se ? "" : h)), m = -1;
    }
  }
  if (o.length > 1 && i.WTF) throw new Error("bad formula stack");
  return o[0];
}
function ab(e) {
  if (e == null) {
    var t = ve(8);
    return t.write_shift(1, 3), t.write_shift(1, 0), t.write_shift(2, 0), t.write_shift(2, 0), t.write_shift(2, 65535), t;
  } else if (typeof e == "number") return gi(e);
  return gi(0);
}
function sb(e, t, r, n, i) {
  var a = vi(t, r, i), s = ab(e.v), o = ve(6), c = 33;
  o.write_shift(2, c), o.write_shift(4, 0);
  for (var u = ve(e.bf.length), l = 0; l < e.bf.length; ++l) u[l] = e.bf[l];
  var d = Wt([a, s, o, u]);
  return d;
}
function Al(e, t, r) {
  var n = e.read_shift(4), i = tb(e, n, r), a = e.read_shift(4), s = a > 0 ? eb(e, a, i, r) : null;
  return [i, s];
}
var ob = Al, Rl = Al, cb = Al, lb = Al, ub = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
}, xx = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
}, fb = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function db(e) {
  var t = "of:=" + e.replace(ih, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
  return t.replace(/;/g, "|").replace(/,/g, ";");
}
function hb(e) {
  return e.replace(/\./, "!");
}
var za = typeof Map < "u";
function oh(e, t, r) {
  var n = 0, i = e.length;
  if (r) {
    if (za ? r.has(t) : Object.prototype.hasOwnProperty.call(r, t)) {
      for (var a = za ? r.get(t) : r[t]; n < a.length; ++n)
        if (e[a[n]].t === t)
          return e.Count++, a[n];
    }
  } else for (; n < i; ++n)
    if (e[n].t === t)
      return e.Count++, n;
  return e[i] = { t }, e.Count++, e.Unique++, r && (za ? (r.has(t) || r.set(t, []), r.get(t).push(i)) : (Object.prototype.hasOwnProperty.call(r, t) || (r[t] = []), r[t].push(i))), i;
}
function $l(e, t) {
  var r = { min: e + 1, max: e + 1 }, n = -1;
  return t.MDW && (xn = t.MDW), t.width != null ? r.customWidth = 1 : t.wpx != null ? n = Hc(t.wpx) : t.wch != null && (n = t.wch), n > -1 ? (r.width = l0(n), r.customWidth = 1) : t.width != null && (r.width = t.width), t.hidden && (r.hidden = !0), t.level != null && (r.outlineLevel = r.level = t.level), r;
}
function Tx(e, t) {
  if (e) {
    var r = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
    e.left == null && (e.left = r[0]), e.right == null && (e.right = r[1]), e.top == null && (e.top = r[2]), e.bottom == null && (e.bottom = r[3]), e.header == null && (e.header = r[4]), e.footer == null && (e.footer = r[5]);
  }
}
function Xn(e, t, r) {
  var n = r.revssf[t.z != null ? t.z : "General"], i = 60, a = e.length;
  if (n == null && r.ssf) {
    for (; i < 392; ++i) if (r.ssf[i] == null) {
      _w(t.z, i), r.ssf[i] = t.z, r.revssf[t.z] = n = i;
      break;
    }
  }
  for (i = 0; i != a; ++i) if (e[i].numFmtId === n) return i;
  return e[a] = {
    numFmtId: n,
    fontId: 0,
    fillId: 0,
    borderId: 0,
    xfId: 0,
    applyNumberFormat: 1
  }, a;
}
function pb(e, t, r) {
  if (e && e["!ref"]) {
    var n = At(e["!ref"]);
    if (n.e.c < n.s.c || n.e.r < n.s.r) throw new Error("Bad range (" + r + "): " + e["!ref"]);
  }
}
function mb(e) {
  if (e.length === 0) return "";
  for (var t = '<mergeCells count="' + e.length + '">', r = 0; r != e.length; ++r) t += '<mergeCell ref="' + Ft(e[r]) + '"/>';
  return t + "</mergeCells>";
}
function gb(e, t, r, n, i) {
  var a = !1, s = {}, o = null;
  if (n.bookType !== "xlsx" && t.vbaraw) {
    var c = t.SheetNames[r];
    try {
      t.Workbook && (c = t.Workbook.Sheets[r].CodeName || c);
    } catch {
    }
    a = !0, s.codeName = Ya(gt(c));
  }
  if (e && e["!outline"]) {
    var u = { summaryBelow: 1, summaryRight: 1 };
    e["!outline"].above && (u.summaryBelow = 0), e["!outline"].left && (u.summaryRight = 0), o = (o || "") + be("outlinePr", null, u);
  }
  !a && !o || (i[i.length] = be("sheetPr", o, s));
}
var vb = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"], _b = [
  "formatColumns",
  "formatRows",
  "formatCells",
  "insertColumns",
  "insertRows",
  "insertHyperlinks",
  "deleteColumns",
  "deleteRows",
  "sort",
  "autoFilter",
  "pivotTables"
];
function yb(e) {
  var t = { sheet: 1 };
  return vb.forEach(function(r) {
    e[r] != null && e[r] && (t[r] = "1");
  }), _b.forEach(function(r) {
    e[r] != null && !e[r] && (t[r] = "0");
  }), e.password && (t.password = sx(e.password).toString(16).toUpperCase()), be("sheetProtection", null, t);
}
function Eb(e) {
  return Tx(e), be("pageMargins", null, e);
}
function wb(e, t) {
  for (var r = ["<cols>"], n, i = 0; i != t.length; ++i)
    (n = t[i]) && (r[r.length] = be("col", null, $l(i, n)));
  return r[r.length] = "</cols>", r.join("");
}
function xb(e, t, r, n) {
  var i = typeof e.ref == "string" ? e.ref : Ft(e.ref);
  r.Workbook || (r.Workbook = { Sheets: [] }), r.Workbook.Names || (r.Workbook.Names = []);
  var a = r.Workbook.Names, s = Pr(i);
  s.s.r == s.e.r && (s.e.r = Pr(t["!ref"]).e.r, i = Ft(s));
  for (var o = 0; o < a.length; ++o) {
    var c = a[o];
    if (c.Name == "_xlnm._FilterDatabase" && c.Sheet == n) {
      c.Ref = "'" + r.SheetNames[n] + "'!" + i;
      break;
    }
  }
  return o == a.length && a.push({ Name: "_xlnm._FilterDatabase", Sheet: n, Ref: "'" + r.SheetNames[n] + "'!" + i }), be("autoFilter", null, { ref: i });
}
function Tb(e, t, r, n) {
  var i = { workbookViewId: "0" };
  return (((n || {}).Workbook || {}).Views || [])[0] && (i.rightToLeft = n.Workbook.Views[0].RTL ? "1" : "0"), be("sheetViews", be("sheetView", null, i), {});
}
function Sb(e, t, r, n) {
  if (e.c && r["!comments"].push([t, e.c]), e.v === void 0 && typeof e.f != "string" || e.t === "z" && !e.f) return "";
  var i = "", a = e.t, s = e.v;
  if (e.t !== "z") switch (e.t) {
    case "b":
      i = e.v ? "1" : "0";
      break;
    case "n":
      i = "" + e.v;
      break;
    case "e":
      i = ls[e.v];
      break;
    case "d":
      n && n.cellDates ? i = dr(e.v, -1).toISOString() : (e = yr(e), e.t = "n", i = "" + (e.v = _r(dr(e.v)))), typeof e.z > "u" && (e.z = It[14]);
      break;
    default:
      i = e.v;
      break;
  }
  var o = Xt("v", gt(i)), c = { r: t }, u = Xn(n.cellXfs, e, n);
  switch (u !== 0 && (c.s = u), e.t) {
    case "n":
      break;
    case "d":
      c.t = "d";
      break;
    case "b":
      c.t = "b";
      break;
    case "e":
      c.t = "e";
      break;
    case "z":
      break;
    default:
      if (e.v == null) {
        delete e.t;
        break;
      }
      if (e.v.length > 32767) throw new Error("Text length must not exceed 32767 characters");
      if (n && n.bookSST) {
        o = Xt("v", "" + oh(n.Strings, e.v, n.revStrings)), c.t = "s";
        break;
      }
      c.t = "str";
      break;
  }
  if (e.t != a && (e.t = a, e.v = s), typeof e.f == "string" && e.f) {
    var l = e.F && e.F.slice(0, t.length) == t ? { t: "array", ref: e.F } : null;
    o = be("f", gt(e.f), l) + (e.v != null ? o : "");
  }
  return e.l && r["!links"].push([t, e.l]), e.D && (c.cm = 1), be("c", o, c);
}
function Ab(e, t, r, n) {
  var i = [], a = [], s = At(e["!ref"]), o = "", c, u = "", l = [], d = 0, f = 0, p = e["!rows"], v = Array.isArray(e), m = { r: u }, h, _ = -1;
  for (f = s.s.c; f <= s.e.c; ++f) l[f] = ar(f);
  for (d = s.s.r; d <= s.e.r; ++d) {
    for (a = [], u = Kt(d), f = s.s.c; f <= s.e.c; ++f) {
      c = l[f] + u;
      var g = v ? (e[d] || [])[f] : e[c];
      g !== void 0 && (o = Sb(g, c, e, t)) != null && a.push(o);
    }
    (a.length > 0 || p && p[d]) && (m = { r: u }, p && p[d] && (h = p[d], h.hidden && (m.hidden = 1), _ = -1, h.hpx ? _ = Gc(h.hpx) : h.hpt && (_ = h.hpt), _ > -1 && (m.ht = _, m.customHeight = 1), h.level && (m.outlineLevel = h.level)), i[i.length] = be("row", a.join(""), m));
  }
  if (p) for (; d < p.length; ++d)
    p && p[d] && (m = { r: d + 1 }, h = p[d], h.hidden && (m.hidden = 1), _ = -1, h.hpx ? _ = Gc(h.hpx) : h.hpt && (_ = h.hpt), _ > -1 && (m.ht = _, m.customHeight = 1), h.level && (m.outlineLevel = h.level), i[i.length] = be("row", "", m));
  return i.join("");
}
function Sx(e, t, r, n) {
  var i = [Dt, be("worksheet", null, {
    xmlns: ra[0],
    "xmlns:r": Ut.r
  })], a = r.SheetNames[e], s = 0, o = "", c = r.Sheets[a];
  c == null && (c = {});
  var u = c["!ref"] || "A1", l = At(u);
  if (l.e.c > 16383 || l.e.r > 1048575) {
    if (t.WTF) throw new Error("Range " + u + " exceeds format limit A1:XFD1048576");
    l.e.c = Math.min(l.e.c, 16383), l.e.r = Math.min(l.e.c, 1048575), u = Ft(l);
  }
  n || (n = {}), c["!comments"] = [];
  var d = [];
  gb(c, r, e, t, i), i[i.length] = be("dimension", null, { ref: u }), i[i.length] = Tb(c, t, e, r), t.sheetFormat && (i[i.length] = be("sheetFormatPr", null, {
    defaultRowHeight: t.sheetFormat.defaultRowHeight || "16",
    baseColWidth: t.sheetFormat.baseColWidth || "10",
    outlineLevelRow: t.sheetFormat.outlineLevelRow || "7"
  })), c["!cols"] != null && c["!cols"].length > 0 && (i[i.length] = wb(c, c["!cols"])), i[s = i.length] = "<sheetData/>", c["!links"] = [], c["!ref"] != null && (o = Ab(c, t), o.length > 0 && (i[i.length] = o)), i.length > s + 1 && (i[i.length] = "</sheetData>", i[s] = i[s].replace("/>", ">")), c["!protect"] && (i[i.length] = yb(c["!protect"])), c["!autofilter"] != null && (i[i.length] = xb(c["!autofilter"], c, r, e)), c["!merges"] != null && c["!merges"].length > 0 && (i[i.length] = mb(c["!merges"]));
  var f = -1, p, v = -1;
  return (
    /*::(*/
    c["!links"].length > 0 && (i[i.length] = "<hyperlinks>", c["!links"].forEach(function(m) {
      m[1].Target && (p = { ref: m[0] }, m[1].Target.charAt(0) != "#" && (v = mt(n, -1, gt(m[1].Target).replace(/#.*$/, ""), ct.HLINK), p["r:id"] = "rId" + v), (f = m[1].Target.indexOf("#")) > -1 && (p.location = gt(m[1].Target.slice(f + 1))), m[1].Tooltip && (p.tooltip = gt(m[1].Tooltip)), i[i.length] = be("hyperlink", null, p));
    }), i[i.length] = "</hyperlinks>"), delete c["!links"], c["!margins"] != null && (i[i.length] = Eb(c["!margins"])), (!t || t.ignoreEC || t.ignoreEC == null) && (i[i.length] = Xt("ignoredErrors", be("ignoredError", null, { numberStoredAsText: 1, sqref: u }))), d.length > 0 && (v = mt(n, -1, "../drawings/drawing" + (e + 1) + ".xml", ct.DRAW), i[i.length] = be("drawing", null, { "r:id": "rId" + v }), c["!drawing"] = d), c["!comments"].length > 0 && (v = mt(n, -1, "../drawings/vmlDrawing" + (e + 1) + ".vml", ct.VML), i[i.length] = be("legacyDrawing", null, { "r:id": "rId" + v }), c["!legacy"] = v), i.length > 1 && (i[i.length] = "</worksheet>", i[1] = i[1].replace("/>", ">")), i.join("")
  );
}
function Rb(e, t) {
  var r = {}, n = e.l + t;
  r.r = e.read_shift(4), e.l += 4;
  var i = e.read_shift(2);
  e.l += 1;
  var a = e.read_shift(1);
  return e.l = n, a & 7 && (r.level = a & 7), a & 16 && (r.hidden = !0), a & 32 && (r.hpt = i / 20), r;
}
function $b(e, t, r) {
  var n = ve(145), i = (r["!rows"] || [])[e] || {};
  n.write_shift(4, e), n.write_shift(4, 0);
  var a = 320;
  i.hpx ? a = Gc(i.hpx) * 20 : i.hpt && (a = i.hpt * 20), n.write_shift(2, a), n.write_shift(1, 0);
  var s = 0;
  i.level && (s |= i.level), i.hidden && (s |= 16), (i.hpx || i.hpt) && (s |= 32), n.write_shift(1, s), n.write_shift(1, 0);
  var o = 0, c = n.l;
  n.l += 4;
  for (var u = { r: e, c: 0 }, l = 0; l < 16; ++l)
    if (!(t.s.c > l + 1 << 10 || t.e.c < l << 10)) {
      for (var d = -1, f = -1, p = l << 10; p < l + 1 << 10; ++p) {
        u.c = p;
        var v = Array.isArray(r) ? (r[u.r] || [])[u.c] : r[_t(u)];
        v && (d < 0 && (d = p), f = p);
      }
      d < 0 || (++o, n.write_shift(4, d), n.write_shift(4, f));
    }
  var m = n.l;
  return n.l = c, n.write_shift(4, o), n.l = m, n.length > n.l ? n.slice(0, n.l) : n;
}
function Ob(e, t, r, n) {
  var i = $b(n, r, t);
  (i.length > 17 || (t["!rows"] || [])[n]) && Se(e, 0, i);
}
var Nb = Ai, Pb = ia;
function Cb() {
}
function Ib(e, t) {
  var r = {}, n = e[e.l];
  return ++e.l, r.above = !(n & 64), r.left = !(n & 128), e.l += 18, r.name = jN(e), r;
}
function bb(e, t, r) {
  r == null && (r = ve(84 + 4 * e.length));
  var n = 192;
  t && (t.above && (n &= -65), t.left && (n &= -129)), r.write_shift(1, n);
  for (var i = 1; i < 3; ++i) r.write_shift(1, 0);
  return Bc({ auto: 1 }, r), r.write_shift(-4, -1), r.write_shift(-4, -1), Uw(e, r), r.slice(0, r.l);
}
function Fb(e) {
  var t = Mr(e);
  return [t];
}
function Db(e, t, r) {
  return r == null && (r = ve(8)), xi(t, r);
}
function kb(e) {
  var t = Ti(e);
  return [t];
}
function Lb(e, t, r) {
  return r == null && (r = ve(4)), Si(t, r);
}
function Mb(e) {
  var t = Mr(e), r = e.read_shift(1);
  return [t, r, "b"];
}
function Ub(e, t, r) {
  return r == null && (r = ve(9)), xi(t, r), r.write_shift(1, e.v ? 1 : 0), r;
}
function qb(e) {
  var t = Ti(e), r = e.read_shift(1);
  return [t, r, "b"];
}
function Bb(e, t, r) {
  return r == null && (r = ve(5)), Si(t, r), r.write_shift(1, e.v ? 1 : 0), r;
}
function jb(e) {
  var t = Mr(e), r = e.read_shift(1);
  return [t, r, "e"];
}
function Vb(e, t, r) {
  return r == null && (r = ve(9)), xi(t, r), r.write_shift(1, e.v), r;
}
function Hb(e) {
  var t = Ti(e), r = e.read_shift(1);
  return [t, r, "e"];
}
function Gb(e, t, r) {
  return r == null && (r = ve(8)), Si(t, r), r.write_shift(1, e.v), r.write_shift(2, 0), r.write_shift(1, 0), r;
}
function zb(e) {
  var t = Mr(e), r = e.read_shift(4);
  return [t, r, "s"];
}
function Wb(e, t, r) {
  return r == null && (r = ve(12)), xi(t, r), r.write_shift(4, t.v), r;
}
function Xb(e) {
  var t = Ti(e), r = e.read_shift(4);
  return [t, r, "s"];
}
function Kb(e, t, r) {
  return r == null && (r = ve(8)), Si(t, r), r.write_shift(4, t.v), r;
}
function Yb(e) {
  var t = Mr(e), r = aa(e);
  return [t, r, "n"];
}
function Jb(e, t, r) {
  return r == null && (r = ve(16)), xi(t, r), gi(e.v, r), r;
}
function Qb(e) {
  var t = Ti(e), r = aa(e);
  return [t, r, "n"];
}
function Zb(e, t, r) {
  return r == null && (r = ve(12)), Si(t, r), gi(e.v, r), r;
}
function eF(e) {
  var t = Mr(e), r = qw(e);
  return [t, r, "n"];
}
function tF(e, t, r) {
  return r == null && (r = ve(12)), xi(t, r), Bw(e.v, r), r;
}
function rF(e) {
  var t = Ti(e), r = qw(e);
  return [t, r, "n"];
}
function nF(e, t, r) {
  return r == null && (r = ve(8)), Si(t, r), Bw(e.v, r), r;
}
function iF(e) {
  var t = Mr(e), r = Z0(e);
  return [t, r, "is"];
}
function aF(e) {
  var t = Mr(e), r = sr(e);
  return [t, r, "str"];
}
function sF(e, t, r) {
  return r == null && (r = ve(12 + 4 * e.v.length)), xi(t, r), Bt(e.v, r), r.length > r.l ? r.slice(0, r.l) : r;
}
function oF(e) {
  var t = Ti(e), r = sr(e);
  return [t, r, "str"];
}
function cF(e, t, r) {
  return r == null && (r = ve(8 + 4 * e.v.length)), Si(t, r), Bt(e.v, r), r.length > r.l ? r.slice(0, r.l) : r;
}
function lF(e, t, r) {
  var n = e.l + t, i = Mr(e);
  i.r = r["!row"];
  var a = e.read_shift(1), s = [i, a, "b"];
  if (r.cellFormula) {
    e.l += 2;
    var o = Rl(e, n - e.l, r);
    s[3] = Ki(o, null, i, r.supbooks, r);
  } else e.l = n;
  return s;
}
function uF(e, t, r) {
  var n = e.l + t, i = Mr(e);
  i.r = r["!row"];
  var a = e.read_shift(1), s = [i, a, "e"];
  if (r.cellFormula) {
    e.l += 2;
    var o = Rl(e, n - e.l, r);
    s[3] = Ki(o, null, i, r.supbooks, r);
  } else e.l = n;
  return s;
}
function fF(e, t, r) {
  var n = e.l + t, i = Mr(e);
  i.r = r["!row"];
  var a = aa(e), s = [i, a, "n"];
  if (r.cellFormula) {
    e.l += 2;
    var o = Rl(e, n - e.l, r);
    s[3] = Ki(o, null, i, r.supbooks, r);
  } else e.l = n;
  return s;
}
function dF(e, t, r) {
  var n = e.l + t, i = Mr(e);
  i.r = r["!row"];
  var a = sr(e), s = [i, a, "str"];
  if (r.cellFormula) {
    e.l += 2;
    var o = Rl(e, n - e.l, r);
    s[3] = Ki(o, null, i, r.supbooks, r);
  } else e.l = n;
  return s;
}
var hF = Ai, pF = ia;
function mF(e, t) {
  return t == null && (t = ve(4)), t.write_shift(4, e), t;
}
function gF(e, t) {
  var r = e.l + t, n = Ai(e), i = eh(e), a = sr(e), s = sr(e), o = sr(e);
  e.l = r;
  var c = { rfx: n, relId: i, loc: a, display: o };
  return s && (c.Tooltip = s), c;
}
function vF(e, t) {
  var r = ve(50 + 4 * (e[1].Target.length + (e[1].Tooltip || "").length));
  ia({ s: qt(e[0]), e: qt(e[0]) }, r), th("rId" + t, r);
  var n = e[1].Target.indexOf("#"), i = n == -1 ? "" : e[1].Target.slice(n + 1);
  return Bt(i || "", r), Bt(e[1].Tooltip || "", r), Bt("", r), r.slice(0, r.l);
}
function _F() {
}
function yF(e, t, r) {
  var n = e.l + t, i = jw(e), a = e.read_shift(1), s = [i];
  if (s[2] = a, r.cellFormula) {
    var o = ob(e, n - e.l, r);
    s[1] = o;
  } else e.l = n;
  return s;
}
function EF(e, t, r) {
  var n = e.l + t, i = Ai(e), a = [i];
  if (r.cellFormula) {
    var s = lb(e, n - e.l, r);
    a[1] = s, e.l = n;
  } else e.l = n;
  return a;
}
function wF(e, t, r) {
  r == null && (r = ve(18));
  var n = $l(e, t);
  r.write_shift(-4, e), r.write_shift(-4, e), r.write_shift(4, (n.width || 10) * 256), r.write_shift(
    4,
    0
    /*ixfe*/
  );
  var i = 0;
  return t.hidden && (i |= 1), typeof n.width == "number" && (i |= 2), t.level && (i |= t.level << 8), r.write_shift(2, i), r;
}
var Ax = ["left", "right", "top", "bottom", "header", "footer"];
function xF(e) {
  var t = {};
  return Ax.forEach(function(r) {
    t[r] = aa(e);
  }), t;
}
function TF(e, t) {
  return t == null && (t = ve(48)), Tx(e), Ax.forEach(function(r) {
    gi(e[r], t);
  }), t;
}
function SF(e) {
  var t = e.read_shift(2);
  return e.l += 28, { RTL: t & 32 };
}
function AF(e, t, r) {
  r == null && (r = ve(30));
  var n = 924;
  return (((t || {}).Views || [])[0] || {}).RTL && (n |= 32), r.write_shift(2, n), r.write_shift(4, 0), r.write_shift(4, 0), r.write_shift(4, 0), r.write_shift(1, 0), r.write_shift(1, 0), r.write_shift(2, 0), r.write_shift(2, 100), r.write_shift(2, 0), r.write_shift(2, 0), r.write_shift(2, 0), r.write_shift(4, 0), r;
}
function RF(e) {
  var t = ve(24);
  return t.write_shift(4, 4), t.write_shift(4, 1), ia(e, t), t;
}
function $F(e, t) {
  return t == null && (t = ve(66)), t.write_shift(2, e.password ? sx(e.password) : 0), t.write_shift(4, 1), [
    ["objects", !1],
    // fObjects
    ["scenarios", !1],
    // fScenarios
    ["formatCells", !0],
    // fFormatCells
    ["formatColumns", !0],
    // fFormatColumns
    ["formatRows", !0],
    // fFormatRows
    ["insertColumns", !0],
    // fInsertColumns
    ["insertRows", !0],
    // fInsertRows
    ["insertHyperlinks", !0],
    // fInsertHyperlinks
    ["deleteColumns", !0],
    // fDeleteColumns
    ["deleteRows", !0],
    // fDeleteRows
    ["selectLockedCells", !1],
    // fSelLockedCells
    ["sort", !0],
    // fSort
    ["autoFilter", !0],
    // fAutoFilter
    ["pivotTables", !0],
    // fPivotTables
    ["selectUnlockedCells", !1]
    // fSelUnlockedCells
  ].forEach(function(r) {
    r[1] ? t.write_shift(4, e[r[0]] != null && !e[r[0]] ? 1 : 0) : t.write_shift(4, e[r[0]] != null && e[r[0]] ? 0 : 1);
  }), t;
}
function OF() {
}
function NF() {
}
function PF(e, t, r, n, i, a, s) {
  if (t.v === void 0) return !1;
  var o = "";
  switch (t.t) {
    case "b":
      o = t.v ? "1" : "0";
      break;
    case "d":
      t = yr(t), t.z = t.z || It[14], t.v = _r(dr(t.v)), t.t = "n";
      break;
    /* falls through */
    case "n":
    case "e":
      o = "" + t.v;
      break;
    default:
      o = t.v;
      break;
  }
  var c = { r, c: n };
  switch (c.s = Xn(i.cellXfs, t, i), t.l && a["!links"].push([_t(c), t.l]), t.c && a["!comments"].push([_t(c), t.c]), t.t) {
    case "s":
    case "str":
      return i.bookSST ? (o = oh(i.Strings, t.v, i.revStrings), c.t = "s", c.v = o, s ? Se(e, 18, Kb(t, c)) : Se(e, 7, Wb(t, c))) : (c.t = "str", s ? Se(e, 17, cF(t, c)) : Se(e, 6, sF(t, c))), !0;
    case "n":
      return t.v == (t.v | 0) && t.v > -1e3 && t.v < 1e3 ? s ? Se(e, 13, nF(t, c)) : Se(e, 2, tF(t, c)) : s ? Se(e, 16, Zb(t, c)) : Se(e, 5, Jb(t, c)), !0;
    case "b":
      return c.t = "b", s ? Se(e, 15, Bb(t, c)) : Se(e, 4, Ub(t, c)), !0;
    case "e":
      return c.t = "e", s ? Se(e, 14, Gb(t, c)) : Se(e, 3, Vb(t, c)), !0;
  }
  return s ? Se(e, 12, Lb(t, c)) : Se(e, 1, Db(t, c)), !0;
}
function CF(e, t, r, n) {
  var i = At(t["!ref"] || "A1"), a, s = "", o = [];
  Se(
    e,
    145
    /* BrtBeginSheetData */
  );
  var c = Array.isArray(t), u = i.e.r;
  t["!rows"] && (u = Math.max(i.e.r, t["!rows"].length - 1));
  for (var l = i.s.r; l <= u; ++l) {
    s = Kt(l), Ob(e, t, i, l);
    var d = !1;
    if (l <= i.e.r) for (var f = i.s.c; f <= i.e.c; ++f) {
      l === i.s.r && (o[f] = ar(f)), a = o[f] + s;
      var p = c ? (t[l] || [])[f] : t[a];
      if (!p) {
        d = !1;
        continue;
      }
      d = PF(e, p, l, f, n, t, d);
    }
  }
  Se(
    e,
    146
    /* BrtEndSheetData */
  );
}
function IF(e, t) {
  !t || !t["!merges"] || (Se(e, 177, mF(t["!merges"].length)), t["!merges"].forEach(function(r) {
    Se(e, 176, pF(r));
  }), Se(
    e,
    178
    /* BrtEndMergeCells */
  ));
}
function bF(e, t) {
  !t || !t["!cols"] || (Se(
    e,
    390
    /* BrtBeginColInfos */
  ), t["!cols"].forEach(function(r, n) {
    r && Se(e, 60, wF(n, r));
  }), Se(
    e,
    391
    /* BrtEndColInfos */
  ));
}
function FF(e, t) {
  !t || !t["!ref"] || (Se(
    e,
    648
    /* BrtBeginCellIgnoreECs */
  ), Se(e, 649, RF(At(t["!ref"]))), Se(
    e,
    650
    /* BrtEndCellIgnoreECs */
  ));
}
function DF(e, t, r) {
  t["!links"].forEach(function(n) {
    if (n[1].Target) {
      var i = mt(r, -1, n[1].Target.replace(/#.*$/, ""), ct.HLINK);
      Se(e, 494, vF(n, i));
    }
  }), delete t["!links"];
}
function kF(e, t, r, n) {
  if (t["!comments"].length > 0) {
    var i = mt(n, -1, "../drawings/vmlDrawing" + (r + 1) + ".vml", ct.VML);
    Se(e, 551, th("rId" + i)), t["!legacy"] = i;
  }
}
function LF(e, t, r, n) {
  if (t["!autofilter"]) {
    var i = t["!autofilter"], a = typeof i.ref == "string" ? i.ref : Ft(i.ref);
    r.Workbook || (r.Workbook = { Sheets: [] }), r.Workbook.Names || (r.Workbook.Names = []);
    var s = r.Workbook.Names, o = Pr(a);
    o.s.r == o.e.r && (o.e.r = Pr(t["!ref"]).e.r, a = Ft(o));
    for (var c = 0; c < s.length; ++c) {
      var u = s[c];
      if (u.Name == "_xlnm._FilterDatabase" && u.Sheet == n) {
        u.Ref = "'" + r.SheetNames[n] + "'!" + a;
        break;
      }
    }
    c == s.length && s.push({ Name: "_xlnm._FilterDatabase", Sheet: n, Ref: "'" + r.SheetNames[n] + "'!" + a }), Se(e, 161, ia(At(a))), Se(
      e,
      162
      /* BrtEndAFilter */
    );
  }
}
function MF(e, t, r) {
  Se(
    e,
    133
    /* BrtBeginWsViews */
  ), Se(e, 137, AF(t, r)), Se(
    e,
    138
    /* BrtEndWsView */
  ), Se(
    e,
    134
    /* BrtEndWsViews */
  );
}
function UF(e, t) {
  t["!protect"] && Se(e, 535, $F(t["!protect"]));
}
function qF(e, t, r, n) {
  var i = vr(), a = r.SheetNames[e], s = r.Sheets[a] || {}, o = a;
  try {
    r && r.Workbook && (o = r.Workbook.Sheets[e].CodeName || o);
  } catch {
  }
  var c = At(s["!ref"] || "A1");
  if (c.e.c > 16383 || c.e.r > 1048575) {
    if (t.WTF) throw new Error("Range " + (s["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
    c.e.c = Math.min(c.e.c, 16383), c.e.r = Math.min(c.e.c, 1048575);
  }
  return s["!links"] = [], s["!comments"] = [], Se(
    i,
    129
    /* BrtBeginSheet */
  ), (r.vbaraw || s["!outline"]) && Se(i, 147, bb(o, s["!outline"])), Se(i, 148, Pb(c)), MF(i, s, r.Workbook), bF(i, s), CF(i, s, e, t), UF(i, s), LF(i, s, r, e), IF(i, s), DF(i, s, n), s["!margins"] && Se(i, 476, TF(s["!margins"])), (!t || t.ignoreEC || t.ignoreEC == null) && FF(i, s), kF(i, s, e, n), Se(
    i,
    130
    /* BrtEndSheet */
  ), i.end();
}
function BF(e, t) {
  e.l += 10;
  var r = sr(e);
  return { name: r };
}
var jF = [
  ["allowRefreshQuery", !1, "bool"],
  ["autoCompressPictures", !0, "bool"],
  ["backupFile", !1, "bool"],
  ["checkCompatibility", !1, "bool"],
  ["CodeName", ""],
  ["date1904", !1, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", !1, "bool"],
  ["hidePivotFieldList", !1, "bool"],
  ["promptedSolutions", !1, "bool"],
  ["publishItems", !1, "bool"],
  ["refreshAllConnections", !1, "bool"],
  ["saveExternalLinkValues", !0, "bool"],
  ["showBorderUnselectedTables", !0, "bool"],
  ["showInkAnnotation", !0, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", !1, "bool"],
  ["updateLinks", "userSet"]
];
function VF(e) {
  return !e.Workbook || !e.Workbook.WBProps ? "false" : EN(e.Workbook.WBProps.date1904) ? "true" : "false";
}
var HF = /* @__PURE__ */ "][*?/\\".split("");
function Rx(e, t) {
  if (e.length > 31)
    throw new Error("Sheet names cannot exceed 31 chars");
  var r = !0;
  return HF.forEach(function(n) {
    if (e.indexOf(n) != -1)
      throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
  }), r;
}
function GF(e, t, r) {
  e.forEach(function(n, i) {
    Rx(n);
    for (var a = 0; a < i; ++a) if (n == e[a]) throw new Error("Duplicate Sheet Name: " + n);
    if (r) {
      var s = t && t[i] && t[i].CodeName || n;
      if (s.charCodeAt(0) == 95 && s.length > 22) throw new Error("Bad Code Name: Worksheet" + s);
    }
  });
}
function zF(e) {
  if (!e || !e.SheetNames || !e.Sheets) throw new Error("Invalid Workbook");
  if (!e.SheetNames.length) throw new Error("Workbook is empty");
  var t = e.Workbook && e.Workbook.Sheets || [];
  GF(e.SheetNames, t, !!e.vbaraw);
  for (var r = 0; r < e.SheetNames.length; ++r) pb(e.Sheets[e.SheetNames[r]], e.SheetNames[r], r);
}
function $x(e) {
  var t = [Dt];
  t[t.length] = be("workbook", null, {
    xmlns: ra[0],
    //'xmlns:mx': XMLNS.mx,
    //'xmlns:s': XMLNS_main[0],
    "xmlns:r": Ut.r
  });
  var r = e.Workbook && (e.Workbook.Names || []).length > 0, n = { codeName: "ThisWorkbook" };
  e.Workbook && e.Workbook.WBProps && (jF.forEach(function(o) {
    e.Workbook.WBProps[o[0]] != null && e.Workbook.WBProps[o[0]] != o[1] && (n[o[0]] = e.Workbook.WBProps[o[0]]);
  }), e.Workbook.WBProps.CodeName && (n.codeName = e.Workbook.WBProps.CodeName, delete n.CodeName)), t[t.length] = be("workbookPr", null, n);
  var i = e.Workbook && e.Workbook.Sheets || [], a = 0;
  if (i && i[0] && i[0].Hidden) {
    for (t[t.length] = "<bookViews>", a = 0; a != e.SheetNames.length && !(!i[a] || !i[a].Hidden); ++a)
      ;
    a == e.SheetNames.length && (a = 0), t[t.length] = '<workbookView firstSheet="' + a + '" activeTab="' + a + '"/>', t[t.length] = "</bookViews>";
  }
  for (t[t.length] = "<sheets>", a = 0; a != e.SheetNames.length; ++a) {
    var s = { name: gt(e.SheetNames[a].slice(0, 31)) };
    if (s.sheetId = "" + (a + 1), s["r:id"] = "rId" + (a + 1), i[a]) switch (i[a].Hidden) {
      case 1:
        s.state = "hidden";
        break;
      case 2:
        s.state = "veryHidden";
        break;
    }
    t[t.length] = be("sheet", null, s);
  }
  return t[t.length] = "</sheets>", r && (t[t.length] = "<definedNames>", e.Workbook && e.Workbook.Names && e.Workbook.Names.forEach(function(o) {
    var c = { name: o.Name };
    o.Comment && (c.comment = o.Comment), o.Sheet != null && (c.localSheetId = "" + o.Sheet), o.Hidden && (c.hidden = "1"), o.Ref && (t[t.length] = be("definedName", gt(o.Ref), c));
  }), t[t.length] = "</definedNames>"), t.length > 2 && (t[t.length] = "</workbook>", t[1] = t[1].replace("/>", ">")), t.join("");
}
function WF(e, t) {
  var r = {};
  return r.Hidden = e.read_shift(4), r.iTabID = e.read_shift(4), r.strRelID = c0(e), r.name = sr(e), r;
}
function XF(e, t) {
  return t || (t = ve(127)), t.write_shift(4, e.Hidden), t.write_shift(4, e.iTabID), th(e.strRelID, t), Bt(e.name.slice(0, 31), t), t.length > t.l ? t.slice(0, t.l) : t;
}
function KF(e, t) {
  var r = {}, n = e.read_shift(4);
  r.defaultThemeVersion = e.read_shift(4);
  var i = t > 8 ? sr(e) : "";
  return i.length > 0 && (r.CodeName = i), r.autoCompressPictures = !!(n & 65536), r.backupFile = !!(n & 64), r.checkCompatibility = !!(n & 4096), r.date1904 = !!(n & 1), r.filterPrivacy = !!(n & 8), r.hidePivotFieldList = !!(n & 1024), r.promptedSolutions = !!(n & 16), r.publishItems = !!(n & 2048), r.refreshAllConnections = !!(n & 262144), r.saveExternalLinkValues = !!(n & 128), r.showBorderUnselectedTables = !!(n & 4), r.showInkAnnotation = !!(n & 32), r.showObjects = ["all", "placeholders", "none"][n >> 13 & 3], r.showPivotChartFilter = !!(n & 32768), r.updateLinks = ["userSet", "never", "always"][n >> 8 & 3], r;
}
function YF(e, t) {
  t || (t = ve(72));
  var r = 0;
  return e && e.filterPrivacy && (r |= 8), t.write_shift(4, r), t.write_shift(4, 0), Uw(e && e.CodeName || "ThisWorkbook", t), t.slice(0, t.l);
}
function JF(e, t, r) {
  var n = e.l + t;
  e.l += 4, e.l += 1;
  var i = e.read_shift(4), a = VN(e), s = cb(e, 0, r), o = eh(e);
  e.l = n;
  var c = { Name: a, Ptg: s };
  return i < 268435455 && (c.Sheet = i), o && (c.Comment = o), c;
}
function QF(e, t) {
  Se(
    e,
    143
    /* BrtBeginBundleShs */
  );
  for (var r = 0; r != t.SheetNames.length; ++r) {
    var n = t.Workbook && t.Workbook.Sheets && t.Workbook.Sheets[r] && t.Workbook.Sheets[r].Hidden || 0, i = { Hidden: n, iTabID: r + 1, strRelID: "rId" + (r + 1), name: t.SheetNames[r] };
    Se(e, 156, XF(i));
  }
  Se(
    e,
    144
    /* BrtEndBundleShs */
  );
}
function ZF(e, t) {
  t || (t = ve(127));
  for (var r = 0; r != 4; ++r) t.write_shift(4, 0);
  return Bt("SheetJS", t), Bt(bc.version, t), Bt(bc.version, t), Bt("7262", t), t.length > t.l ? t.slice(0, t.l) : t;
}
function eD(e, t) {
  t || (t = ve(29)), t.write_shift(-4, 0), t.write_shift(-4, 460), t.write_shift(4, 28800), t.write_shift(4, 17600), t.write_shift(4, 500), t.write_shift(4, e), t.write_shift(4, e);
  var r = 120;
  return t.write_shift(1, r), t.length > t.l ? t.slice(0, t.l) : t;
}
function tD(e, t) {
  if (!(!t.Workbook || !t.Workbook.Sheets)) {
    for (var r = t.Workbook.Sheets, n = 0, i = -1, a = -1; n < r.length; ++n)
      !r[n] || !r[n].Hidden && i == -1 ? i = n : r[n].Hidden == 1 && a == -1 && (a = n);
    a > i || (Se(
      e,
      135
      /* BrtBeginBookViews */
    ), Se(e, 158, eD(i)), Se(
      e,
      136
      /* BrtEndBookViews */
    ));
  }
}
function rD(e, t) {
  var r = vr();
  return Se(
    r,
    131
    /* BrtBeginBook */
  ), Se(r, 128, ZF()), Se(r, 153, YF(e.Workbook && e.Workbook.WBProps || null)), tD(r, e), QF(r, e), Se(
    r,
    132
    /* BrtEndBook */
  ), r.end();
}
function nD(e, t, r) {
  return (t.slice(-4) === ".bin" ? rD : $x)(e);
}
function iD(e, t, r, n, i) {
  return (t.slice(-4) === ".bin" ? qF : Sx)(e, r, n, i);
}
function aD(e, t, r) {
  return (t.slice(-4) === ".bin" ? TC : lx)(e, r);
}
function sD(e, t, r) {
  return (t.slice(-4) === ".bin" ? YP : ax)(e, r);
}
function oD(e, t, r) {
  return (t.slice(-4) === ".bin" ? UC : px)(e);
}
function cD(e) {
  return (e.slice(-4) === ".bin" ? CC : dx)();
}
function lD(e, t) {
  var r = [];
  return e.Props && r.push(aP(e.Props, t)), e.Custprops && r.push(sP(e.Props, e.Custprops)), r.join("");
}
function uD() {
  return "";
}
function fD(e, t) {
  var r = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
  return t.cellXfs.forEach(function(n, i) {
    var a = [];
    a.push(be("NumberFormat", null, { "ss:Format": gt(It[n.numFmtId]) }));
    var s = (
      /*::(*/
      { "ss:ID": "s" + (21 + i) }
    );
    r.push(be("Style", a.join(""), s));
  }), be("Styles", r.join(""));
}
function Ox(e) {
  return be("NamedRange", null, { "ss:Name": e.Name, "ss:RefersTo": "=" + ah(e.Ref, { r: 0, c: 0 }) });
}
function dD(e) {
  if (!((e || {}).Workbook || {}).Names) return "";
  for (var t = e.Workbook.Names, r = [], n = 0; n < t.length; ++n) {
    var i = t[n];
    i.Sheet == null && (i.Name.match(/^_xlfn\./) || r.push(Ox(i)));
  }
  return be("Names", r.join(""));
}
function hD(e, t, r, n) {
  if (!e || !((n || {}).Workbook || {}).Names) return "";
  for (var i = n.Workbook.Names, a = [], s = 0; s < i.length; ++s) {
    var o = i[s];
    o.Sheet == r && (o.Name.match(/^_xlfn\./) || a.push(Ox(o)));
  }
  return a.join("");
}
function pD(e, t, r, n) {
  if (!e) return "";
  var i = [];
  if (e["!margins"] && (i.push("<PageSetup>"), e["!margins"].header && i.push(be("Header", null, { "x:Margin": e["!margins"].header })), e["!margins"].footer && i.push(be("Footer", null, { "x:Margin": e["!margins"].footer })), i.push(be("PageMargins", null, {
    "x:Bottom": e["!margins"].bottom || "0.75",
    "x:Left": e["!margins"].left || "0.7",
    "x:Right": e["!margins"].right || "0.7",
    "x:Top": e["!margins"].top || "0.75"
  })), i.push("</PageSetup>")), n && n.Workbook && n.Workbook.Sheets && n.Workbook.Sheets[r])
    if (n.Workbook.Sheets[r].Hidden) i.push(be("Visible", n.Workbook.Sheets[r].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
    else {
      for (var a = 0; a < r && !(n.Workbook.Sheets[a] && !n.Workbook.Sheets[a].Hidden); ++a) ;
      a == r && i.push("<Selected/>");
    }
  return ((((n || {}).Workbook || {}).Views || [])[0] || {}).RTL && i.push("<DisplayRightToLeft/>"), e["!protect"] && (i.push(Xt("ProtectContents", "True")), e["!protect"].objects && i.push(Xt("ProtectObjects", "True")), e["!protect"].scenarios && i.push(Xt("ProtectScenarios", "True")), e["!protect"].selectLockedCells != null && !e["!protect"].selectLockedCells ? i.push(Xt("EnableSelection", "NoSelection")) : e["!protect"].selectUnlockedCells != null && !e["!protect"].selectUnlockedCells && i.push(Xt("EnableSelection", "UnlockedCells")), [
    ["formatCells", "AllowFormatCells"],
    ["formatColumns", "AllowSizeCols"],
    ["formatRows", "AllowSizeRows"],
    ["insertColumns", "AllowInsertCols"],
    ["insertRows", "AllowInsertRows"],
    ["insertHyperlinks", "AllowInsertHyperlinks"],
    ["deleteColumns", "AllowDeleteCols"],
    ["deleteRows", "AllowDeleteRows"],
    ["sort", "AllowSort"],
    ["autoFilter", "AllowFilter"],
    ["pivotTables", "AllowUsePivotTables"]
  ].forEach(function(s) {
    e["!protect"][s[0]] && i.push("<" + s[1] + "/>");
  })), i.length == 0 ? "" : be("WorksheetOptions", i.join(""), { xmlns: Or.x });
}
function mD(e) {
  return e.map(function(t) {
    var r = yN(t.t || ""), n = be("ss:Data", r, { xmlns: "http://www.w3.org/TR/REC-html40" });
    return be("Comment", n, { "ss:Author": t.a });
  }).join("");
}
function gD(e, t, r, n, i, a, s) {
  if (!e || e.v == null && e.f == null) return "";
  var o = {};
  if (e.f && (o["ss:Formula"] = "=" + gt(ah(e.f, s))), e.F && e.F.slice(0, t.length) == t) {
    var c = qt(e.F.slice(t.length + 1));
    o["ss:ArrayRange"] = "RC:R" + (c.r == s.r ? "" : "[" + (c.r - s.r) + "]") + "C" + (c.c == s.c ? "" : "[" + (c.c - s.c) + "]");
  }
  if (e.l && e.l.Target && (o["ss:HRef"] = gt(e.l.Target), e.l.Tooltip && (o["x:HRefScreenTip"] = gt(e.l.Tooltip))), r["!merges"])
    for (var u = r["!merges"], l = 0; l != u.length; ++l)
      u[l].s.c != s.c || u[l].s.r != s.r || (u[l].e.c > u[l].s.c && (o["ss:MergeAcross"] = u[l].e.c - u[l].s.c), u[l].e.r > u[l].s.r && (o["ss:MergeDown"] = u[l].e.r - u[l].s.r));
  var d = "", f = "";
  switch (e.t) {
    case "z":
      if (!n.sheetStubs) return "";
      break;
    case "n":
      d = "Number", f = String(e.v);
      break;
    case "b":
      d = "Boolean", f = e.v ? "1" : "0";
      break;
    case "e":
      d = "Error", f = ls[e.v];
      break;
    case "d":
      d = "DateTime", f = new Date(e.v).toISOString(), e.z == null && (e.z = e.z || It[14]);
      break;
    case "s":
      d = "String", f = _N(e.v || "");
      break;
  }
  var p = Xn(n.cellXfs, e, n);
  o["ss:StyleID"] = "s" + (21 + p), o["ss:Index"] = s.c + 1;
  var v = e.v != null ? f : "", m = e.t == "z" ? "" : '<Data ss:Type="' + d + '">' + v + "</Data>";
  return (e.c || []).length > 0 && (m += mD(e.c)), be("Cell", m, o);
}
function vD(e, t) {
  var r = '<Row ss:Index="' + (e + 1) + '"';
  return t && (t.hpt && !t.hpx && (t.hpx = cx(t.hpt)), t.hpx && (r += ' ss:AutoFitHeight="0" ss:Height="' + t.hpx + '"'), t.hidden && (r += ' ss:Hidden="1"')), r + ">";
}
function _D(e, t, r, n) {
  if (!e["!ref"]) return "";
  var i = At(e["!ref"]), a = e["!merges"] || [], s = 0, o = [];
  e["!cols"] && e["!cols"].forEach(function(h, _) {
    nh(h);
    var g = !!h.width, y = $l(_, h), x = { "ss:Index": _ + 1 };
    g && (x["ss:Width"] = Vc(y.width)), h.hidden && (x["ss:Hidden"] = "1"), o.push(be("Column", null, x));
  });
  for (var c = Array.isArray(e), u = i.s.r; u <= i.e.r; ++u) {
    for (var l = [vD(u, (e["!rows"] || [])[u])], d = i.s.c; d <= i.e.c; ++d) {
      var f = !1;
      for (s = 0; s != a.length; ++s)
        if (!(a[s].s.c > d) && !(a[s].s.r > u) && !(a[s].e.c < d) && !(a[s].e.r < u)) {
          (a[s].s.c != d || a[s].s.r != u) && (f = !0);
          break;
        }
      if (!f) {
        var p = { r: u, c: d }, v = _t(p), m = c ? (e[u] || [])[d] : e[v];
        l.push(gD(m, v, e, t, r, n, p));
      }
    }
    l.push("</Row>"), l.length > 2 && o.push(l.join(""));
  }
  return o.join("");
}
function yD(e, t, r) {
  var n = [], i = r.SheetNames[e], a = r.Sheets[i], s = a ? hD(a, t, e, r) : "";
  return s.length > 0 && n.push("<Names>" + s + "</Names>"), s = a ? _D(a, t, e, r) : "", s.length > 0 && n.push("<Table>" + s + "</Table>"), n.push(pD(a, t, e, r)), n.join("");
}
function ED(e, t) {
  t || (t = {}), e.SSF || (e.SSF = yr(It)), e.SSF && (xl(), wl(e.SSF), t.revssf = Tl(e.SSF), t.revssf[e.SSF[65535]] = 0, t.ssf = e.SSF, t.cellXfs = [], Xn(t.cellXfs, {}, { revssf: { General: 0 } }));
  var r = [];
  r.push(lD(e, t)), r.push(uD()), r.push(""), r.push("");
  for (var n = 0; n < e.SheetNames.length; ++n)
    r.push(be("Worksheet", yD(n, t, e), { "ss:Name": gt(e.SheetNames[n]) }));
  return r[2] = fD(e, t), r[3] = dD(e), Dt + be("Workbook", r.join(""), {
    xmlns: Or.ss,
    "xmlns:o": Or.o,
    "xmlns:x": Or.x,
    "xmlns:ss": Or.ss,
    "xmlns:dt": Or.dt,
    "xmlns:html": Or.html
  });
}
var Zd = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function wD(e, t) {
  var r = [], n = [], i = [], a = 0, s, o = _y(Cy, "n"), c = _y(Iy, "n");
  if (e.Props)
    for (s = Yt(e.Props), a = 0; a < s.length; ++a) (Object.prototype.hasOwnProperty.call(o, s[a]) ? r : Object.prototype.hasOwnProperty.call(c, s[a]) ? n : i).push([s[a], e.Props[s[a]]]);
  if (e.Custprops)
    for (s = Yt(e.Custprops), a = 0; a < s.length; ++a) Object.prototype.hasOwnProperty.call(e.Props || {}, s[a]) || (Object.prototype.hasOwnProperty.call(o, s[a]) ? r : Object.prototype.hasOwnProperty.call(c, s[a]) ? n : i).push([s[a], e.Custprops[s[a]]]);
  var u = [];
  for (a = 0; a < i.length; ++a)
    Qw.indexOf(i[a][0]) > -1 || Kw.indexOf(i[a][0]) > -1 || i[a][1] != null && u.push(i[a]);
  n.length && xt.utils.cfb_add(t, "/SummaryInformation", Ly(n, Zd.SI, c, Iy)), (r.length || u.length) && xt.utils.cfb_add(t, "/DocumentSummaryInformation", Ly(r, Zd.DSI, o, Cy, u.length ? u : null, Zd.UDI));
}
function xD(e, t) {
  var r = t || {}, n = xt.utils.cfb_new({ root: "R" }), i = "/Workbook";
  switch (r.bookType || "xls") {
    case "xls":
      r.bookType = "biff8";
    /* falls through */
    case "xla":
      r.bookType || (r.bookType = "xla");
    /* falls through */
    case "biff8":
      i = "/Workbook", r.biff = 8;
      break;
    case "biff5":
      i = "/Book", r.biff = 5;
      break;
    default:
      throw new Error("invalid type " + r.bookType + " for XLS CFB");
  }
  return xt.utils.cfb_add(n, i, Nx(e, r)), r.biff == 8 && (e.Props || e.Custprops) && wD(e, n), r.biff == 8 && e.vbaraw && qC(n, xt.read(e.vbaraw, { type: typeof e.vbaraw == "string" ? "binary" : "buffer" })), n;
}
var TD = {
  /*::[*/
  0: {
    /* n:"BrtRowHdr", */
    f: Rb
  },
  /*::[*/
  1: {
    /* n:"BrtCellBlank", */
    f: Fb
  },
  /*::[*/
  2: {
    /* n:"BrtCellRk", */
    f: eF
  },
  /*::[*/
  3: {
    /* n:"BrtCellError", */
    f: jb
  },
  /*::[*/
  4: {
    /* n:"BrtCellBool", */
    f: Mb
  },
  /*::[*/
  5: {
    /* n:"BrtCellReal", */
    f: Yb
  },
  /*::[*/
  6: {
    /* n:"BrtCellSt", */
    f: aF
  },
  /*::[*/
  7: {
    /* n:"BrtCellIsst", */
    f: zb
  },
  /*::[*/
  8: {
    /* n:"BrtFmlaString", */
    f: dF
  },
  /*::[*/
  9: {
    /* n:"BrtFmlaNum", */
    f: fF
  },
  /*::[*/
  10: {
    /* n:"BrtFmlaBool", */
    f: lF
  },
  /*::[*/
  11: {
    /* n:"BrtFmlaError", */
    f: uF
  },
  /*::[*/
  12: {
    /* n:"BrtShortBlank", */
    f: kb
  },
  /*::[*/
  13: {
    /* n:"BrtShortRk", */
    f: rF
  },
  /*::[*/
  14: {
    /* n:"BrtShortError", */
    f: Hb
  },
  /*::[*/
  15: {
    /* n:"BrtShortBool", */
    f: qb
  },
  /*::[*/
  16: {
    /* n:"BrtShortReal", */
    f: Qb
  },
  /*::[*/
  17: {
    /* n:"BrtShortSt", */
    f: oF
  },
  /*::[*/
  18: {
    /* n:"BrtShortIsst", */
    f: Xb
  },
  /*::[*/
  19: {
    /* n:"BrtSSTItem", */
    f: Z0
  },
  /*::[*/
  20: {
    /* n:"BrtPCDIMissing" */
  },
  /*::[*/
  21: {
    /* n:"BrtPCDINumber" */
  },
  /*::[*/
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  /*::[*/
  23: {
    /* n:"BrtPCDIError" */
  },
  /*::[*/
  24: {
    /* n:"BrtPCDIString" */
  },
  /*::[*/
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  /*::[*/
  26: {
    /* n:"BrtPCDIIndex" */
  },
  /*::[*/
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  /*::[*/
  28: {
    /* n:"BrtPCDIANumber" */
  },
  /*::[*/
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  /*::[*/
  30: {
    /* n:"BrtPCDIAError" */
  },
  /*::[*/
  31: {
    /* n:"BrtPCDIAString" */
  },
  /*::[*/
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  /*::[*/
  33: {
    /* n:"BrtPCRRecord" */
  },
  /*::[*/
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  /*::[*/
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  /*::[*/
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  /*::[*/
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  /*::[*/
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  /*::[*/
  39: {
    /* n:"BrtName", */
    f: JF
  },
  /*::[*/
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  /*::[*/
  42: {
    /* n:"BrtIndexBlock" */
  },
  /*::[*/
  43: {
    /* n:"BrtFont", */
    f: aC
  },
  /*::[*/
  44: {
    /* n:"BrtFmt", */
    f: nC
  },
  /*::[*/
  45: {
    /* n:"BrtFill", */
    f: cC
  },
  /*::[*/
  46: {
    /* n:"BrtBorder", */
    f: uC
  },
  /*::[*/
  47: {
    /* n:"BrtXF", */
    f: lC
  },
  /*::[*/
  48: {
    /* n:"BrtStyle" */
  },
  /*::[*/
  49: {
    /* n:"BrtCellMeta", */
    f: kN
  },
  /*::[*/
  50: {
    /* n:"BrtValueMeta" */
  },
  /*::[*/
  51: {
    /* n:"BrtMdb" */
    f: RC
  },
  /*::[*/
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  /*::[*/
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  /*::[*/
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  /*::[*/
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  /*::[*/
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  /*::[*/
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  /*::[*/
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  /*::[*/
  59: {
    /* n:"BrtStr" */
  },
  /*::[*/
  60: {
    /* n:"BrtColInfo", */
    f: LP
  },
  /*::[*/
  62: {
    /* n:"BrtCellRString", */
    f: iF
  },
  /*::[*/
  63: {
    /* n:"BrtCalcChainItem$", */
    f: IC
  },
  /*::[*/
  64: {
    /* n:"BrtDVal", */
    f: OF
  },
  /*::[*/
  65: {
    /* n:"BrtSxvcellNum" */
  },
  /*::[*/
  66: {
    /* n:"BrtSxvcellStr" */
  },
  /*::[*/
  67: {
    /* n:"BrtSxvcellBool" */
  },
  /*::[*/
  68: {
    /* n:"BrtSxvcellErr" */
  },
  /*::[*/
  69: {
    /* n:"BrtSxvcellDate" */
  },
  /*::[*/
  70: {
    /* n:"BrtSxvcellNil" */
  },
  /*::[*/
  128: {
    /* n:"BrtFileVersion" */
  },
  /*::[*/
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  /*::[*/
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  /*::[*/
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: on,
    p: 0
  },
  /*::[*/
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  /*::[*/
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  /*::[*/
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  /*::[*/
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  /*::[*/
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  /*::[*/
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: SF
  },
  /*::[*/
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  /*::[*/
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  /*::[*/
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  /*::[*/
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  /*::[*/
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  /*::[*/
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  /*::[*/
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  /*::[*/
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  /*::[*/
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  /*::[*/
  147: {
    /* n:"BrtWsProp", */
    f: Ib
  },
  /*::[*/
  148: {
    /* n:"BrtWsDim", */
    f: Nb,
    p: 16
  },
  /*::[*/
  151: {
    /* n:"BrtPane", */
    f: _F
  },
  /*::[*/
  152: {
    /* n:"BrtSel" */
  },
  /*::[*/
  153: {
    /* n:"BrtWbProp", */
    f: KF
  },
  /*::[*/
  154: {
    /* n:"BrtWbFactoid" */
  },
  /*::[*/
  155: {
    /* n:"BrtFileRecover" */
  },
  /*::[*/
  156: {
    /* n:"BrtBundleSh", */
    f: WF
  },
  /*::[*/
  157: {
    /* n:"BrtCalcProp" */
  },
  /*::[*/
  158: {
    /* n:"BrtBookView" */
  },
  /*::[*/
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: WP
  },
  /*::[*/
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  /*::[*/
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: Ai
  },
  /*::[*/
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  /*::[*/
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  /*::[*/
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  /*::[*/
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  /*::[*/
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  /*::[*/
  167: {
    /* n:"BrtFilter" */
  },
  /*::[*/
  168: {
    /* n:"BrtColorFilter" */
  },
  /*::[*/
  169: {
    /* n:"BrtIconFilter" */
  },
  /*::[*/
  170: {
    /* n:"BrtTop10Filter" */
  },
  /*::[*/
  171: {
    /* n:"BrtDynamicFilter" */
  },
  /*::[*/
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  /*::[*/
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  /*::[*/
  174: {
    /* n:"BrtCustomFilter" */
  },
  /*::[*/
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  /*::[*/
  176: {
    /* n:"BrtMergeCell", */
    f: hF
  },
  /*::[*/
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  /*::[*/
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  /*::[*/
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  /*::[*/
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  /*::[*/
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  /*::[*/
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  /*::[*/
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  /*::[*/
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  /*::[*/
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  /*::[*/
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  /*::[*/
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  /*::[*/
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  /*::[*/
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  /*::[*/
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  /*::[*/
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  /*::[*/
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  /*::[*/
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  /*::[*/
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  /*::[*/
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  /*::[*/
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  /*::[*/
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  /*::[*/
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  /*::[*/
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  /*::[*/
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  /*::[*/
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  /*::[*/
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  /*::[*/
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  /*::[*/
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  /*::[*/
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  /*::[*/
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  /*::[*/
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  /*::[*/
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  /*::[*/
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  /*::[*/
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  /*::[*/
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  /*::[*/
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  /*::[*/
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  /*::[*/
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  /*::[*/
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  /*::[*/
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  /*::[*/
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  /*::[*/
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  /*::[*/
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  /*::[*/
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  /*::[*/
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  /*::[*/
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  /*::[*/
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  /*::[*/
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  /*::[*/
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  /*::[*/
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  /*::[*/
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  /*::[*/
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  /*::[*/
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  /*::[*/
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  /*::[*/
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  /*::[*/
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  /*::[*/
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  /*::[*/
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  /*::[*/
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  /*::[*/
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  /*::[*/
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  /*::[*/
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  /*::[*/
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  /*::[*/
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  /*::[*/
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  /*::[*/
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  /*::[*/
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  /*::[*/
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  /*::[*/
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  /*::[*/
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  /*::[*/
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  /*::[*/
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  /*::[*/
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  /*::[*/
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  /*::[*/
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  /*::[*/
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  /*::[*/
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  /*::[*/
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  /*::[*/
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  /*::[*/
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  /*::[*/
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  /*::[*/
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  /*::[*/
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  /*::[*/
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  /*::[*/
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  /*::[*/
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  /*::[*/
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  /*::[*/
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  /*::[*/
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  /*::[*/
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  /*::[*/
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  /*::[*/
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  /*::[*/
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  /*::[*/
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  /*::[*/
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  /*::[*/
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  /*::[*/
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  /*::[*/
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  /*::[*/
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  /*::[*/
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  /*::[*/
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  /*::[*/
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  /*::[*/
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  /*::[*/
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  /*::[*/
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  /*::[*/
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  /*::[*/
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  /*::[*/
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  /*::[*/
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  /*::[*/
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  /*::[*/
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  /*::[*/
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  /*::[*/
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  /*::[*/
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  /*::[*/
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  /*::[*/
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  /*::[*/
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  /*::[*/
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  /*::[*/
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  /*::[*/
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  /*::[*/
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  /*::[*/
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  /*::[*/
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  /*::[*/
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  /*::[*/
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  /*::[*/
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  /*::[*/
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  /*::[*/
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  /*::[*/
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  /*::[*/
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  /*::[*/
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  /*::[*/
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  /*::[*/
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  /*::[*/
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  /*::[*/
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  /*::[*/
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  /*::[*/
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  /*::[*/
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  /*::[*/
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  /*::[*/
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  /*::[*/
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  /*::[*/
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  /*::[*/
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  /*::[*/
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  /*::[*/
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  /*::[*/
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  /*::[*/
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  /*::[*/
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  /*::[*/
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  /*::[*/
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  /*::[*/
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  /*::[*/
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  /*::[*/
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  /*::[*/
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  /*::[*/
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  /*::[*/
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  /*::[*/
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  /*::[*/
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  /*::[*/
  335: {
    /* n:"BrtMdtinfo", */
    f: SC
  },
  /*::[*/
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  /*::[*/
  337: {
    /* n:"BrtBeginEsmdb", */
    f: NC,
    T: 1
  },
  /*::[*/
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  /*::[*/
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  /*::[*/
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  /*::[*/
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  /*::[*/
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  /*::[*/
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  /*::[*/
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  /*::[*/
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  /*::[*/
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  /*::[*/
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  /*::[*/
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  /*::[*/
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  /*::[*/
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  /*::[*/
  351: {
    /* n:"BrtListCCFmla" */
  },
  /*::[*/
  352: {
    /* n:"BrtListTrFmla" */
  },
  /*::[*/
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  /*::[*/
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  /*::[*/
  355: {
    /* n:"BrtSupBookSrc", */
    f: c0
  },
  /*::[*/
  357: {
    /* n:"BrtSupSelf" */
  },
  /*::[*/
  358: {
    /* n:"BrtSupSame" */
  },
  /*::[*/
  359: {
    /* n:"BrtSupTabs" */
  },
  /*::[*/
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  /*::[*/
  361: {
    /* n:"BrtPlaceholderName" */
  },
  /*::[*/
  362: {
    /* n:"BrtExternSheet", */
    f: CP
  },
  /*::[*/
  363: {
    /* n:"BrtExternTableStart" */
  },
  /*::[*/
  364: {
    /* n:"BrtExternTableEnd" */
  },
  /*::[*/
  366: {
    /* n:"BrtExternRowHdr" */
  },
  /*::[*/
  367: {
    /* n:"BrtExternCellBlank" */
  },
  /*::[*/
  368: {
    /* n:"BrtExternCellReal" */
  },
  /*::[*/
  369: {
    /* n:"BrtExternCellBool" */
  },
  /*::[*/
  370: {
    /* n:"BrtExternCellError" */
  },
  /*::[*/
  371: {
    /* n:"BrtExternCellString" */
  },
  /*::[*/
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  /*::[*/
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  /*::[*/
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  /*::[*/
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  /*::[*/
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  /*::[*/
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  /*::[*/
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  /*::[*/
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  /*::[*/
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  /*::[*/
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  /*::[*/
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  /*::[*/
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  /*::[*/
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  /*::[*/
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  /*::[*/
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  /*::[*/
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  /*::[*/
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  /*::[*/
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  /*::[*/
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  /*::[*/
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  /*::[*/
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  /*::[*/
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  /*::[*/
  396: {
    /* n:"BrtBrk" */
  },
  /*::[*/
  397: {
    /* n:"BrtUserBookView" */
  },
  /*::[*/
  398: {
    /* n:"BrtInfo" */
  },
  /*::[*/
  399: {
    /* n:"BrtCUsr" */
  },
  /*::[*/
  400: {
    /* n:"BrtUsr" */
  },
  /*::[*/
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  /*::[*/
  403: {
    /* n:"BrtEOF" */
  },
  /*::[*/
  404: {
    /* n:"BrtUCR" */
  },
  /*::[*/
  405: {
    /* n:"BrtRRInsDel" */
  },
  /*::[*/
  406: {
    /* n:"BrtRREndInsDel" */
  },
  /*::[*/
  407: {
    /* n:"BrtRRMove" */
  },
  /*::[*/
  408: {
    /* n:"BrtRREndMove" */
  },
  /*::[*/
  409: {
    /* n:"BrtRRChgCell" */
  },
  /*::[*/
  410: {
    /* n:"BrtRREndChgCell" */
  },
  /*::[*/
  411: {
    /* n:"BrtRRHeader" */
  },
  /*::[*/
  412: {
    /* n:"BrtRRUserView" */
  },
  /*::[*/
  413: {
    /* n:"BrtRRRenSheet" */
  },
  /*::[*/
  414: {
    /* n:"BrtRRInsertSh" */
  },
  /*::[*/
  415: {
    /* n:"BrtRRDefName" */
  },
  /*::[*/
  416: {
    /* n:"BrtRRNote" */
  },
  /*::[*/
  417: {
    /* n:"BrtRRConflict" */
  },
  /*::[*/
  418: {
    /* n:"BrtRRTQSIF" */
  },
  /*::[*/
  419: {
    /* n:"BrtRRFormat" */
  },
  /*::[*/
  420: {
    /* n:"BrtRREndFormat" */
  },
  /*::[*/
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  /*::[*/
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  /*::[*/
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  /*::[*/
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  /*::[*/
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  /*::[*/
  426: {
    /* n:"BrtArrFmla", */
    f: yF
  },
  /*::[*/
  427: {
    /* n:"BrtShrFmla", */
    f: EF
  },
  /*::[*/
  428: {
    /* n:"BrtTable" */
  },
  /*::[*/
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  /*::[*/
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  /*::[*/
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  /*::[*/
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  /*::[*/
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  /*::[*/
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  /*::[*/
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  /*::[*/
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  /*::[*/
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  /*::[*/
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  /*::[*/
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  /*::[*/
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  /*::[*/
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  /*::[*/
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  /*::[*/
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  /*::[*/
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  /*::[*/
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  /*::[*/
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  /*::[*/
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  /*::[*/
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  /*::[*/
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  /*::[*/
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  /*::[*/
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  /*::[*/
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  /*::[*/
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  /*::[*/
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  /*::[*/
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  /*::[*/
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  /*::[*/
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  /*::[*/
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  /*::[*/
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  /*::[*/
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  /*::[*/
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  /*::[*/
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  /*::[*/
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  /*::[*/
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  /*::[*/
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  /*::[*/
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  /*::[*/
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  /*::[*/
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  /*::[*/
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  /*::[*/
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  /*::[*/
  471: {
    /* n:"BrtCFVO" */
  },
  /*::[*/
  472: {
    /* n:"BrtExternValueMeta" */
  },
  /*::[*/
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  /*::[*/
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  /*::[*/
  475: {
    /* n:"BrtIndexedColor" */
  },
  /*::[*/
  476: {
    /* n:"BrtMargins", */
    f: xF
  },
  /*::[*/
  477: {
    /* n:"BrtPrintOptions" */
  },
  /*::[*/
  478: {
    /* n:"BrtPageSetup" */
  },
  /*::[*/
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  /*::[*/
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  /*::[*/
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  /*::[*/
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  /*::[*/
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  /*::[*/
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  /*::[*/
  485: {
    /* n:"BrtWsFmtInfo", */
    f: Cb
  },
  /*::[*/
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  /*::[*/
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  /*::[*/
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  /*::[*/
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  /*::[*/
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  /*::[*/
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  /*::[*/
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  /*::[*/
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  /*::[*/
  494: {
    /* n:"BrtHLink", */
    f: gF
  },
  /*::[*/
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  /*::[*/
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  /*::[*/
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  /*::[*/
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  /*::[*/
  499: {
    /* n:"BrtDRef" */
  },
  /*::[*/
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  /*::[*/
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  /*::[*/
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  /*::[*/
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  /*::[*/
  504: {
    /* n:"BrtSlc" */
  },
  /*::[*/
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  /*::[*/
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  /*::[*/
  507: {
    /* n:"BrtDXF" */
  },
  /*::[*/
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  /*::[*/
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  /*::[*/
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  /*::[*/
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  /*::[*/
  512: {
    /* n:"BrtTableStyleElement" */
  },
  /*::[*/
  513: {
    /* n:"BrtTableStyleClient" */
  },
  /*::[*/
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  /*::[*/
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  /*::[*/
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  /*::[*/
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  /*::[*/
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  /*::[*/
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  /*::[*/
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  /*::[*/
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  /*::[*/
  522: {
    /* n:"BrtVolSubtopic" */
  },
  /*::[*/
  523: {
    /* n:"BrtVolRef" */
  },
  /*::[*/
  524: {
    /* n:"BrtVolNum" */
  },
  /*::[*/
  525: {
    /* n:"BrtVolErr" */
  },
  /*::[*/
  526: {
    /* n:"BrtVolStr" */
  },
  /*::[*/
  527: {
    /* n:"BrtVolBool" */
  },
  /*::[*/
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  /*::[*/
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  /*::[*/
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  /*::[*/
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  /*::[*/
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  /*::[*/
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  /*::[*/
  534: {
    /* n:"BrtBookProtection" */
  },
  /*::[*/
  535: {
    /* n:"BrtSheetProtection" */
  },
  /*::[*/
  536: {
    /* n:"BrtRangeProtection" */
  },
  /*::[*/
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  /*::[*/
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  /*::[*/
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  /*::[*/
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  /*::[*/
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  /*::[*/
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  /*::[*/
  548: {
    /* n:"BrtFileSharing" */
  },
  /*::[*/
  549: {
    /* n:"BrtOleSize" */
  },
  /*::[*/
  550: {
    /* n:"BrtDrawing", */
    f: c0
  },
  /*::[*/
  551: {
    /* n:"BrtLegacyDrawing" */
  },
  /*::[*/
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  /*::[*/
  553: {
    /* n:"BrtWebOpt" */
  },
  /*::[*/
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  /*::[*/
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  /*::[*/
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  /*::[*/
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  /*::[*/
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  /*::[*/
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  /*::[*/
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  /*::[*/
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  /*::[*/
  562: {
    /* n:"BrtBkHim" */
  },
  /*::[*/
  564: {
    /* n:"BrtColor" */
  },
  /*::[*/
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  /*::[*/
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  /*::[*/
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  /*::[*/
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  /*::[*/
  572: {
    /* n:"BrtMRUColor" */
  },
  /*::[*/
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  /*::[*/
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  /*::[*/
  577: {
    /* n:"BrtSupNameStart" */
  },
  /*::[*/
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  /*::[*/
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  /*::[*/
  580: {
    /* n:"BrtSupNameNum" */
  },
  /*::[*/
  581: {
    /* n:"BrtSupNameErr" */
  },
  /*::[*/
  582: {
    /* n:"BrtSupNameSt" */
  },
  /*::[*/
  583: {
    /* n:"BrtSupNameNil" */
  },
  /*::[*/
  584: {
    /* n:"BrtSupNameBool" */
  },
  /*::[*/
  585: {
    /* n:"BrtSupNameFmla" */
  },
  /*::[*/
  586: {
    /* n:"BrtSupNameBits" */
  },
  /*::[*/
  587: {
    /* n:"BrtSupNameEnd" */
  },
  /*::[*/
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  /*::[*/
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  /*::[*/
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  /*::[*/
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  /*::[*/
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  /*::[*/
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  /*::[*/
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  /*::[*/
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  /*::[*/
  596: {
    /* n:"BrtSmartTagType" */
  },
  /*::[*/
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  /*::[*/
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  /*::[*/
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  /*::[*/
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  /*::[*/
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  /*::[*/
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  /*::[*/
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  /*::[*/
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  /*::[*/
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  /*::[*/
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  /*::[*/
  607: {
    /* n:"BrtCellWatch" */
  },
  /*::[*/
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  /*::[*/
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  /*::[*/
  610: {
    /* n:"BrtCrashRecErr" */
  },
  /*::[*/
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  /*::[*/
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  /*::[*/
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  /*::[*/
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  /*::[*/
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  /*::[*/
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  /*::[*/
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  /*::[*/
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  /*::[*/
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  /*::[*/
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  /*::[*/
  625: {
    /* n:"BrtBigName" */
  },
  /*::[*/
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  /*::[*/
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  /*::[*/
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  /*::[*/
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  /*::[*/
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  /*::[*/
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  /*::[*/
  632: {
    /* n:"BrtCommentAuthor", */
    f: LC
  },
  /*::[*/
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  /*::[*/
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  /*::[*/
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: DC
  },
  /*::[*/
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  /*::[*/
  637: {
    /* n:"BrtCommentText", */
    f: qN
  },
  /*::[*/
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  /*::[*/
  639: {
    /* n:"BrtOleObject" */
  },
  /*::[*/
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  /*::[*/
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  /*::[*/
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  /*::[*/
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  /*::[*/
  644: {
    /* n:"BrtActiveX" */
  },
  /*::[*/
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  /*::[*/
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  /*::[*/
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  /*::[*/
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  /*::[*/
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  /*::[*/
  651: {
    /* n:"BrtCsProp", */
    f: BF
  },
  /*::[*/
  652: {
    /* n:"BrtCsPageSetup" */
  },
  /*::[*/
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  /*::[*/
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  /*::[*/
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  /*::[*/
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  /*::[*/
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  /*::[*/
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  /*::[*/
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  /*::[*/
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  /*::[*/
  661: {
    /* n:"BrtListPart" */
  },
  /*::[*/
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  /*::[*/
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  /*::[*/
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  /*::[*/
  665: {
    /* n:"BrtFnGroup" */
  },
  /*::[*/
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  /*::[*/
  667: {
    /* n:"BrtSupAddin" */
  },
  /*::[*/
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  /*::[*/
  669: {
    /* n:"BrtCsProtection" */
  },
  /*::[*/
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  /*::[*/
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  /*::[*/
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  /*::[*/
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  /*::[*/
  675: {
    /* n:"BrtRRSortItem" */
  },
  /*::[*/
  676: {
    /* n:"BrtFileSharingIso" */
  },
  /*::[*/
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  /*::[*/
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  /*::[*/
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  /*::[*/
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  /*::[*/
  681: {
    /* n:"BrtDValList" */
  },
  /*::[*/
  1024: {
    /* n:"BrtRwDescent" */
  },
  /*::[*/
  1025: {
    /* n:"BrtKnownFonts" */
  },
  /*::[*/
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  /*::[*/
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  /*::[*/
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  /*::[*/
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  /*::[*/
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  /*::[*/
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  /*::[*/
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  /*::[*/
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  /*::[*/
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  /*::[*/
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  /*::[*/
  1036: {
    /* n:"BrtNameExt" */
  },
  /*::[*/
  1037: {
    /* n:"BrtPCDH14" */
  },
  /*::[*/
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  /*::[*/
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  /*::[*/
  1040: {
    /* n:"BrtSXTH14" */
  },
  /*::[*/
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  /*::[*/
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  /*::[*/
  1043: {
    /* n:"BrtSparkline" */
  },
  /*::[*/
  1044: {
    /* n:"BrtSXDI14" */
  },
  /*::[*/
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  /*::[*/
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  /*::[*/
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  /*::[*/
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  /*::[*/
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  /*::[*/
  1050: {
    /* n:"BrtCFVO14" */
  },
  /*::[*/
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  /*::[*/
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  /*::[*/
  1053: {
    /* n:"BrtDVal14", */
    f: NF
  },
  /*::[*/
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  /*::[*/
  1055: {
    /* n:"BrtColor14" */
  },
  /*::[*/
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  /*::[*/
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  /*::[*/
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  /*::[*/
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  /*::[*/
  1061: {
    /* n:"BrtSXVD14" */
  },
  /*::[*/
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  /*::[*/
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  /*::[*/
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  /*::[*/
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  /*::[*/
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  /*::[*/
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  /*::[*/
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  /*::[*/
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  /*::[*/
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  /*::[*/
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  /*::[*/
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  /*::[*/
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  /*::[*/
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  /*::[*/
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  /*::[*/
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  /*::[*/
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  /*::[*/
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  /*::[*/
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  /*::[*/
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  /*::[*/
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  /*::[*/
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  /*::[*/
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  /*::[*/
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  /*::[*/
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  /*::[*/
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  /*::[*/
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  /*::[*/
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  /*::[*/
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  /*::[*/
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  /*::[*/
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  /*::[*/
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  /*::[*/
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  /*::[*/
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  /*::[*/
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  /*::[*/
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  /*::[*/
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  /*::[*/
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  /*::[*/
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  /*::[*/
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  /*::[*/
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  /*::[*/
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  /*::[*/
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  /*::[*/
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  /*::[*/
  1111: {
    /* n:"BrtList14" */
  },
  /*::[*/
  1112: {
    /* n:"BrtCFIcon" */
  },
  /*::[*/
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  /*::[*/
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  /*::[*/
  1117: {
    /* n:"BrtWbProp14" */
  },
  /*::[*/
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  /*::[*/
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  /*::[*/
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  /*::[*/
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  /*::[*/
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  /*::[*/
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  /*::[*/
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  /*::[*/
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  /*::[*/
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  /*::[*/
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  /*::[*/
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  /*::[*/
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  /*::[*/
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  /*::[*/
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  /*::[*/
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  /*::[*/
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  /*::[*/
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  /*::[*/
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  /*::[*/
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  /*::[*/
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  /*::[*/
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  /*::[*/
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  /*::[*/
  1141: {
    /* n:"BrtPCDField14" */
  },
  /*::[*/
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  /*::[*/
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  /*::[*/
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  /*::[*/
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  /*::[*/
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  /*::[*/
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  /*::[*/
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  /*::[*/
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  /*::[*/
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  /*::[*/
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  /*::[*/
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  /*::[*/
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  /*::[*/
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  /*::[*/
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  /*::[*/
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  /*::[*/
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  /*::[*/
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  /*::[*/
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  /*::[*/
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  /*::[*/
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  /*::[*/
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  /*::[*/
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  /*::[*/
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  /*::[*/
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  /*::[*/
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  /*::[*/
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  /*::[*/
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  /*::[*/
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  /*::[*/
  1171: {
    /* n:"BrtDxf14" */
  },
  /*::[*/
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  /*::[*/
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  /*::[*/
  1177: {
    /* n:"BrtFilter14" */
  },
  /*::[*/
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  /*::[*/
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  /*::[*/
  1181: {
    /* n:"BrtIconFilter14" */
  },
  /*::[*/
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  /*::[*/
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  /*::[*/
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  /*::[*/
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  /*::[*/
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  /*::[*/
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  /*::[*/
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  /*::[*/
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  /*::[*/
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  /*::[*/
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  /*::[*/
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  /*::[*/
  2067: {
    /* n:"BrtQsi15" */
  },
  /*::[*/
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  /*::[*/
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  /*::[*/
  2070: {
    /* n:"BrtWebExtension" */
  },
  /*::[*/
  2071: {
    /* n:"BrtAbsPath15" */
  },
  /*::[*/
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  /*::[*/
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  /*::[*/
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  /*::[*/
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  /*::[*/
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  /*::[*/
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  /*::[*/
  2079: {
    /* n:"BrtSxFilter15" */
  },
  /*::[*/
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  /*::[*/
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  /*::[*/
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  /*::[*/
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  /*::[*/
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  /*::[*/
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  /*::[*/
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  /*::[*/
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  /*::[*/
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  /*::[*/
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  /*::[*/
  2092: {
    /* n:"BrtPCDH15" */
  },
  /*::[*/
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  /*::[*/
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  /*::[*/
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  /*::[*/
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  /*::[*/
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  /*::[*/
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  /*::[*/
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  /*::[*/
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  /*::[*/
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  /*::[*/
  2102: {
    /* n:"BrtDxf15" */
  },
  /*::[*/
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  /*::[*/
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  /*::[*/
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  /*::[*/
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  /*::[*/
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  /*::[*/
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  /*::[*/
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  /*::[*/
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  /*::[*/
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  /*::[*/
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  /*::[*/
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  /*::[*/
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  /*::[*/
  2115: {
    /* n:"BrtTextPr15" */
  },
  /*::[*/
  2116: {
    /* n:"BrtRangePr15" */
  },
  /*::[*/
  2117: {
    /* n:"BrtDbCommand15" */
  },
  /*::[*/
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  /*::[*/
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  /*::[*/
  2120: {
    /* n:"BrtDbTable15" */
  },
  /*::[*/
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  /*::[*/
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  /*::[*/
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  /*::[*/
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  /*::[*/
  2125: {
    /* n:"BrtModelTable" */
  },
  /*::[*/
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  /*::[*/
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  /*::[*/
  2128: {
    /* n:"BrtModelRelationship" */
  },
  /*::[*/
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  /*::[*/
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  /*::[*/
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  /*::[*/
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  /*::[*/
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  /*::[*/
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  /*::[*/
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  /*::[*/
  2136: {
    /* n:"BrtSXDI15" */
  },
  /*::[*/
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  /*::[*/
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  /*::[*/
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  /*::[*/
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  /*::[*/
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  /*::[*/
  3072: {
    /* n:"BrtUid" */
  },
  /*::[*/
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  /*::[*/
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  /*::[*/
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  /*::[*/
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  /*::[*/
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  /*::[*/
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  /*::[*/
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  /*::[*/
  5083: {
    /* n:"BrtRichFilter" */
  },
  /*::[*/
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  /*::[*/
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  /*::[*/
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  /*::[*/
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  /*::[*/
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  /*::[*/
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  /*::[*/
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  /*::[*/
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  /*::[*/
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  /*::[*/
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  /*::[*/
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  /*::[*/
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  /*::[*/
  5097: {
    /* n:"BrtCalcFeature" */
  },
  /*::[*/
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  /*::[*/
  65535: { n: "" }
};
function Fe(e, t, r, n) {
  var i = t;
  if (!isNaN(i)) {
    var a = n || (r || []).length || 0, s = e.next(4);
    s.write_shift(2, i), s.write_shift(2, a), /*:: len != null &&*/
    a > 0 && Y0(r) && e.push(r);
  }
}
function SD(e, t, r, n) {
  var i = (r || []).length || 0;
  if (i <= 8224) return Fe(e, t, r, i);
  var a = t;
  if (!isNaN(a)) {
    for (var s = r.parts || [], o = 0, c = 0, u = 0; u + (s[o] || 8224) <= 8224; )
      u += s[o] || 8224, o++;
    var l = e.next(4);
    for (l.write_shift(2, a), l.write_shift(2, u), e.push(r.slice(c, c + u)), c += u; c < i; ) {
      for (l = e.next(4), l.write_shift(2, 60), u = 0; u + (s[o] || 8224) <= 8224; )
        u += s[o] || 8224, o++;
      l.write_shift(2, u), e.push(r.slice(c, c + u)), c += u;
    }
  }
}
function fs(e, t, r) {
  return e || (e = ve(7)), e.write_shift(2, t), e.write_shift(2, r), e.write_shift(2, 0), e.write_shift(1, 0), e;
}
function AD(e, t, r, n) {
  var i = ve(9);
  return fs(i, e, t), ex(r, n || "b", i), i;
}
function RD(e, t, r) {
  var n = ve(8 + 2 * r.length);
  return fs(n, e, t), n.write_shift(1, r.length), n.write_shift(r.length, r, "sbcs"), n.l < n.length ? n.slice(0, n.l) : n;
}
function $D(e, t, r, n) {
  if (t.v != null) switch (t.t) {
    case "d":
    case "n":
      var i = t.t == "d" ? _r(dr(t.v)) : t.v;
      i == (i | 0) && i >= 0 && i < 65536 ? Fe(e, 2, BP(r, n, i)) : Fe(e, 3, qP(r, n, i));
      return;
    case "b":
    case "e":
      Fe(e, 5, AD(r, n, t.v, t.t));
      return;
    /* TODO: codepage, sst */
    case "s":
    case "str":
      Fe(e, 4, RD(r, n, (t.v || "").slice(0, 255)));
      return;
  }
  Fe(e, 1, fs(null, r, n));
}
function OD(e, t, r, n) {
  var i = Array.isArray(t), a = At(t["!ref"] || "A1"), s, o = "", c = [];
  if (a.e.c > 255 || a.e.r > 16383) {
    if (n.WTF) throw new Error("Range " + (t["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    a.e.c = Math.min(a.e.c, 255), a.e.r = Math.min(a.e.c, 16383), s = Ft(a);
  }
  for (var u = a.s.r; u <= a.e.r; ++u) {
    o = Kt(u);
    for (var l = a.s.c; l <= a.e.c; ++l) {
      u === a.s.r && (c[l] = ar(l)), s = c[l] + o;
      var d = i ? (t[u] || [])[l] : t[s];
      d && $D(e, d, u, l);
    }
  }
}
function ND(e, t) {
  for (var r = t || {}, n = vr(), i = 0, a = 0; a < e.SheetNames.length; ++a) e.SheetNames[a] == r.sheet && (i = a);
  if (i == 0 && r.sheet && e.SheetNames[0] != r.sheet) throw new Error("Sheet not found: " + r.sheet);
  return Fe(n, r.biff == 4 ? 1033 : r.biff == 3 ? 521 : 9, rh(e, 16, r)), OD(n, e.Sheets[e.SheetNames[i]], i, r), Fe(n, 10), n.end();
}
function PD(e, t, r) {
  Fe(e, 49, TP({
    sz: 12,
    name: "Arial"
  }, r));
}
function CD(e, t, r) {
  t && [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(n) {
    for (var i = n[0]; i <= n[1]; ++i) t[i] != null && Fe(e, 1054, RP(i, t[i], r));
  });
}
function ID(e, t) {
  var r = ve(19);
  r.write_shift(4, 2151), r.write_shift(4, 0), r.write_shift(4, 0), r.write_shift(2, 3), r.write_shift(1, 1), r.write_shift(4, 0), Fe(e, 2151, r), r = ve(39), r.write_shift(4, 2152), r.write_shift(4, 0), r.write_shift(4, 0), r.write_shift(2, 3), r.write_shift(1, 0), r.write_shift(4, 0), r.write_shift(2, 1), r.write_shift(4, 4), r.write_shift(2, 0), nx(At(t["!ref"] || "A1"), r), r.write_shift(4, 4), Fe(e, 2152, r);
}
function bD(e, t) {
  for (var r = 0; r < 16; ++r) Fe(e, 224, Uy({ numFmtId: 0, style: !0 }, 0, t));
  t.cellXfs.forEach(function(n) {
    Fe(e, 224, Uy(n, 0, t));
  });
}
function FD(e, t) {
  for (var r = 0; r < t["!links"].length; ++r) {
    var n = t["!links"][r];
    Fe(e, 440, FP(n)), n[1].Tooltip && Fe(e, 2048, DP(n));
  }
  delete t["!links"];
}
function DD(e, t) {
  if (t) {
    var r = 0;
    t.forEach(function(n, i) {
      ++r <= 256 && n && Fe(e, 125, MP($l(i, n), i));
    });
  }
}
function kD(e, t, r, n, i) {
  var a = 16 + Xn(i.cellXfs, t, i);
  if (t.v == null && !t.bf) {
    Fe(e, 513, vi(r, n, a));
    return;
  }
  if (t.bf) Fe(e, 6, sb(t, r, n, i, a));
  else switch (t.t) {
    case "d":
    case "n":
      var s = t.t == "d" ? _r(dr(t.v)) : t.v;
      Fe(e, 515, PP(r, n, s, a));
      break;
    case "b":
    case "e":
      Fe(e, 517, NP(r, n, t.v, a, i, t.t));
      break;
    /* TODO: codepage, sst */
    case "s":
    case "str":
      if (i.bookSST) {
        var o = oh(i.Strings, t.v, i.revStrings);
        Fe(e, 253, SP(r, n, o, a));
      } else Fe(e, 516, AP(r, n, (t.v || "").slice(0, 255), a, i));
      break;
    default:
      Fe(e, 513, vi(r, n, a));
  }
}
function LD(e, t, r) {
  var n = vr(), i = r.SheetNames[e], a = r.Sheets[i] || {}, s = (r || {}).Workbook || {}, o = (s.Sheets || [])[e] || {}, c = Array.isArray(a), u = t.biff == 8, l, d = "", f = [], p = At(a["!ref"] || "A1"), v = u ? 65536 : 16384;
  if (p.e.c > 255 || p.e.r >= v) {
    if (t.WTF) throw new Error("Range " + (a["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    p.e.c = Math.min(p.e.c, 255), p.e.r = Math.min(p.e.c, v - 1);
  }
  Fe(n, 2057, rh(r, 16, t)), Fe(n, 13, Dr(1)), Fe(n, 12, Dr(100)), Fe(n, 15, ur(!0)), Fe(n, 17, ur(!1)), Fe(n, 16, gi(1e-3)), Fe(n, 95, ur(!0)), Fe(n, 42, ur(!1)), Fe(n, 43, ur(!1)), Fe(n, 130, Dr(1)), Fe(n, 128, OP()), Fe(n, 131, ur(!1)), Fe(n, 132, ur(!1)), u && DD(n, a["!cols"]), Fe(n, 512, $P(p, t)), u && (a["!links"] = []);
  for (var m = p.s.r; m <= p.e.r; ++m) {
    d = Kt(m);
    for (var h = p.s.c; h <= p.e.c; ++h) {
      m === p.s.r && (f[h] = ar(h)), l = f[h] + d;
      var _ = c ? (a[m] || [])[h] : a[l];
      _ && (kD(n, _, m, h, t), u && _.l && a["!links"].push([l, _.l]));
    }
  }
  var g = o.CodeName || o.name || i;
  return u && Fe(n, 574, xP((s.Views || [])[0])), u && (a["!merges"] || []).length && Fe(n, 229, bP(a["!merges"])), u && FD(n, a), Fe(n, 442, rx(g)), u && ID(n, a), Fe(
    n,
    10
    /* EOF */
  ), n.end();
}
function MD(e, t, r) {
  var n = vr(), i = (e || {}).Workbook || {}, a = i.Sheets || [], s = (
    /*::((*/
    i.WBProps || {
      /*::CodeName:"ThisWorkbook"*/
    }
  ), o = r.biff == 8, c = r.biff == 5;
  if (Fe(n, 2057, rh(e, 5, r)), r.bookType == "xla" && Fe(
    n,
    135
    /* Addin */
  ), Fe(n, 225, o ? Dr(1200) : null), Fe(n, 193, lP(2)), c && Fe(
    n,
    191
    /* ToolbarHdr */
  ), c && Fe(
    n,
    192
    /* ToolbarEnd */
  ), Fe(
    n,
    226
    /* InterfaceEnd */
  ), Fe(n, 92, _P("SheetJS", r)), Fe(n, 66, Dr(o ? 1200 : 1252)), o && Fe(n, 353, Dr(0)), o && Fe(
    n,
    448
    /* Excel9File */
  ), Fe(n, 317, UP(e.SheetNames.length)), o && e.vbaraw && Fe(
    n,
    211
    /* ObProj */
  ), o && e.vbaraw) {
    var u = s.CodeName || "ThisWorkbook";
    Fe(n, 442, rx(u));
  }
  Fe(n, 156, Dr(17)), Fe(n, 25, ur(!1)), Fe(n, 18, ur(!1)), Fe(n, 19, Dr(0)), o && Fe(n, 431, ur(!1)), o && Fe(n, 444, Dr(0)), Fe(n, 61, wP()), Fe(n, 64, ur(!1)), Fe(n, 141, Dr(0)), Fe(n, 34, ur(VF(e) == "true")), Fe(n, 14, ur(!0)), o && Fe(n, 439, ur(!1)), Fe(n, 218, Dr(0)), PD(n, e, r), CD(n, e.SSF, r), bD(n, r), o && Fe(n, 352, ur(!1));
  var l = n.end(), d = vr();
  o && Fe(d, 140, kP()), o && r.Strings && SD(d, 252, EP(r.Strings)), Fe(
    d,
    10
    /* EOF */
  );
  var f = d.end(), p = vr(), v = 0, m = 0;
  for (m = 0; m < e.SheetNames.length; ++m) v += (o ? 12 : 11) + (o ? 2 : 1) * e.SheetNames[m].length;
  var h = l.length + v + f.length;
  for (m = 0; m < e.SheetNames.length; ++m) {
    var _ = a[m] || {};
    Fe(p, 133, yP({ pos: h, hs: _.Hidden || 0, dt: 0, name: e.SheetNames[m] }, r)), h += t[m].length;
  }
  var g = p.end();
  if (v != g.length) throw new Error("BS8 " + v + " != " + g.length);
  var y = [];
  return l.length && y.push(l), g.length && y.push(g), f.length && y.push(f), Wt(y);
}
function UD(e, t) {
  var r = t || {}, n = [];
  e && !e.SSF && (e.SSF = yr(It)), e && e.SSF && (xl(), wl(e.SSF), r.revssf = Tl(e.SSF), r.revssf[e.SSF[65535]] = 0, r.ssf = e.SSF), r.Strings = /*::((*/
  [], r.Strings.Count = 0, r.Strings.Unique = 0, ch(r), r.cellXfs = [], Xn(r.cellXfs, {}, { revssf: { General: 0 } }), e.Props || (e.Props = {});
  for (var i = 0; i < e.SheetNames.length; ++i) n[n.length] = LD(i, r, e);
  return n.unshift(MD(e, n, r)), Wt(n);
}
function Nx(e, t) {
  for (var r = 0; r <= e.SheetNames.length; ++r) {
    var n = e.Sheets[e.SheetNames[r]];
    if (!(!n || !n["!ref"])) {
      var i = Pr(n["!ref"]);
      i.e.c > 255 && typeof console < "u" && console.error && console.error("Worksheet '" + e.SheetNames[r] + "' extends beyond column IV (255).  Data may be lost.");
    }
  }
  var a = t || {};
  switch (a.biff || 2) {
    case 8:
    case 5:
      return UD(e, t);
    case 4:
    case 3:
    case 2:
      return ND(e, t);
  }
  throw new Error("invalid type " + a.bookType + " for BIFF");
}
function qD(e, t, r, n) {
  for (var i = e["!merges"] || [], a = [], s = t.s.c; s <= t.e.c; ++s) {
    for (var o = 0, c = 0, u = 0; u < i.length; ++u)
      if (!(i[u].s.r > r || i[u].s.c > s) && !(i[u].e.r < r || i[u].e.c < s)) {
        if (i[u].s.r < r || i[u].s.c < s) {
          o = -1;
          break;
        }
        o = i[u].e.r - i[u].s.r + 1, c = i[u].e.c - i[u].s.c + 1;
        break;
      }
    if (!(o < 0)) {
      var l = _t({ r, c: s }), d = n.dense ? (e[r] || [])[s] : e[l], f = d && d.v != null && (d.h || vN(d.w || (An(d), d.w) || "")) || "", p = {};
      o > 1 && (p.rowspan = o), c > 1 && (p.colspan = c), n.editable ? f = '<span contenteditable="true">' + f + "</span>" : d && (p["data-t"] = d && d.t || "z", d.v != null && (p["data-v"] = d.v), d.z != null && (p["data-z"] = d.z), d.l && (d.l.Target || "#").charAt(0) != "#" && (f = '<a href="' + d.l.Target + '">' + f + "</a>")), p.id = (n.id || "sjs") + "-" + l, a.push(be("td", f, p));
    }
  }
  var v = "<tr>";
  return v + a.join("") + "</tr>";
}
var BD = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>', jD = "</body></html>";
function VD(e, t, r) {
  var n = [];
  return n.join("") + "<table" + (r && r.id ? ' id="' + r.id + '"' : "") + ">";
}
function Px(e, t) {
  var r = t || {}, n = r.header != null ? r.header : BD, i = r.footer != null ? r.footer : jD, a = [n], s = Pr(e["!ref"]);
  r.dense = Array.isArray(e), a.push(VD(e, s, r));
  for (var o = s.s.r; o <= s.e.r; ++o) a.push(qD(e, s, o, r));
  return a.push("</table>" + i), a.join("");
}
function Cx(e, t, r) {
  var n = r || {}, i = 0, a = 0;
  if (n.origin != null)
    if (typeof n.origin == "number") i = n.origin;
    else {
      var s = typeof n.origin == "string" ? qt(n.origin) : n.origin;
      i = s.r, a = s.c;
    }
  var o = t.getElementsByTagName("tr"), c = Math.min(n.sheetRows || 1e7, o.length), u = { s: { r: 0, c: 0 }, e: { r: i, c: a } };
  if (e["!ref"]) {
    var l = Pr(e["!ref"]);
    u.s.r = Math.min(u.s.r, l.s.r), u.s.c = Math.min(u.s.c, l.s.c), u.e.r = Math.max(u.e.r, l.e.r), u.e.c = Math.max(u.e.c, l.e.c), i == -1 && (u.e.r = i = l.e.r + 1);
  }
  var d = [], f = 0, p = e["!rows"] || (e["!rows"] = []), v = 0, m = 0, h = 0, _ = 0, g = 0, y = 0;
  for (e["!cols"] || (e["!cols"] = []); v < o.length && m < c; ++v) {
    var x = o[v];
    if (zy(x)) {
      if (n.display) continue;
      p[m] = { hidden: !0 };
    }
    var S = x.children;
    for (h = _ = 0; h < S.length; ++h) {
      var w = S[h];
      if (!(n.display && zy(w))) {
        var E = w.hasAttribute("data-v") ? w.getAttribute("data-v") : w.hasAttribute("v") ? w.getAttribute("v") : wN(w.innerHTML), R = w.getAttribute("data-z") || w.getAttribute("z");
        for (f = 0; f < d.length; ++f) {
          var N = d[f];
          N.s.c == _ + a && N.s.r < m + i && m + i <= N.e.r && (_ = N.e.c + 1 - a, f = -1);
        }
        y = +w.getAttribute("colspan") || 1, ((g = +w.getAttribute("rowspan") || 1) > 1 || y > 1) && d.push({ s: { r: m + i, c: _ + a }, e: { r: m + i + (g || 1) - 1, c: _ + a + (y || 1) - 1 } });
        var B = { t: "s", v: E }, F = w.getAttribute("data-t") || w.getAttribute("t") || "";
        E != null && (E.length == 0 ? B.t = F || "z" : n.raw || E.trim().length == 0 || F == "s" || (E === "TRUE" ? B = { t: "b", v: !0 } : E === "FALSE" ? B = { t: "b", v: !1 } : isNaN(wn(E)) ? isNaN(Ka(E).getDate()) || (B = { t: "d", v: dr(E) }, n.cellDates || (B = { t: "n", v: _r(B.v) }), B.z = n.dateNF || It[14]) : B = { t: "n", v: wn(E) })), B.z === void 0 && R != null && (B.z = R);
        var U = "", G = w.getElementsByTagName("A");
        if (G && G.length) for (var M = 0; M < G.length && !(G[M].hasAttribute("href") && (U = G[M].getAttribute("href"), U.charAt(0) != "#")); ++M) ;
        U && U.charAt(0) != "#" && (B.l = { Target: U }), n.dense ? (e[m + i] || (e[m + i] = []), e[m + i][_ + a] = B) : e[_t({ c: _ + a, r: m + i })] = B, u.e.c < _ + a && (u.e.c = _ + a), _ += y;
      }
    }
    ++m;
  }
  return d.length && (e["!merges"] = (e["!merges"] || []).concat(d)), u.e.r = Math.max(u.e.r, m - 1 + i), e["!ref"] = Ft(u), m >= c && (e["!fullref"] = Ft((u.e.r = o.length - v + m - 1 + i, u))), e;
}
function Ix(e, t) {
  var r = t || {}, n = r.dense ? [] : {};
  return Cx(n, e, t);
}
function HD(e, t) {
  return wi(Ix(e, t), t);
}
function zy(e) {
  var t = "", r = GD(e);
  return r && (t = r(e).getPropertyValue("display")), t || (t = e.style && e.style.display), t === "none";
}
function GD(e) {
  return e.ownerDocument.defaultView && typeof e.ownerDocument.defaultView.getComputedStyle == "function" ? e.ownerDocument.defaultView.getComputedStyle : typeof getComputedStyle == "function" ? getComputedStyle : null;
}
var zD = /* @__PURE__ */ (function() {
  var e = [
    "<office:master-styles>",
    '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
    "<style:header/>",
    '<style:header-left style:display="false"/>',
    "<style:footer/>",
    '<style:footer-left style:display="false"/>',
    "</style:master-page>",
    "</office:master-styles>"
  ].join(""), t = "<office:document-styles " + Ja({
    "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
    "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
    "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
    "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
    "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
    "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
    "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
    "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
    "office:version": "1.2"
  }) + ">" + e + "</office:document-styles>";
  return function() {
    return Dt + t;
  };
})(), Wy = /* @__PURE__ */ (function() {
  var e = function(a) {
    return gt(a).replace(/  +/g, function(s) {
      return '<text:s text:c="' + s.length + '"/>';
    }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
  }, t = `          <table:table-cell />
`, r = `          <table:covered-table-cell/>
`, n = function(a, s, o) {
    var c = [];
    c.push('      <table:table table:name="' + gt(s.SheetNames[o]) + `" table:style-name="ta1">
`);
    var u = 0, l = 0, d = Pr(a["!ref"] || "A1"), f = a["!merges"] || [], p = 0, v = Array.isArray(a);
    if (a["!cols"])
      for (l = 0; l <= d.e.c; ++l) c.push("        <table:table-column" + (a["!cols"][l] ? ' table:style-name="co' + a["!cols"][l].ods + '"' : "") + `></table:table-column>
`);
    var m = "", h = a["!rows"] || [];
    for (u = 0; u < d.s.r; ++u)
      m = h[u] ? ' table:style-name="ro' + h[u].ods + '"' : "", c.push("        <table:table-row" + m + `></table:table-row>
`);
    for (; u <= d.e.r; ++u) {
      for (m = h[u] ? ' table:style-name="ro' + h[u].ods + '"' : "", c.push("        <table:table-row" + m + `>
`), l = 0; l < d.s.c; ++l) c.push(t);
      for (; l <= d.e.c; ++l) {
        var _ = !1, g = {}, y = "";
        for (p = 0; p != f.length; ++p)
          if (!(f[p].s.c > l) && !(f[p].s.r > u) && !(f[p].e.c < l) && !(f[p].e.r < u)) {
            (f[p].s.c != l || f[p].s.r != u) && (_ = !0), g["table:number-columns-spanned"] = f[p].e.c - f[p].s.c + 1, g["table:number-rows-spanned"] = f[p].e.r - f[p].s.r + 1;
            break;
          }
        if (_) {
          c.push(r);
          continue;
        }
        var x = _t({ r: u, c: l }), S = v ? (a[u] || [])[l] : a[x];
        if (S && S.f && (g["table:formula"] = gt(db(S.f)), S.F && S.F.slice(0, x.length) == x)) {
          var w = Pr(S.F);
          g["table:number-matrix-columns-spanned"] = w.e.c - w.s.c + 1, g["table:number-matrix-rows-spanned"] = w.e.r - w.s.r + 1;
        }
        if (!S) {
          c.push(t);
          continue;
        }
        switch (S.t) {
          case "b":
            y = S.v ? "TRUE" : "FALSE", g["office:value-type"] = "boolean", g["office:boolean-value"] = S.v ? "true" : "false";
            break;
          case "n":
            y = S.w || String(S.v || 0), g["office:value-type"] = "float", g["office:value"] = S.v || 0;
            break;
          case "s":
          case "str":
            y = S.v == null ? "" : S.v, g["office:value-type"] = "string";
            break;
          case "d":
            y = S.w || dr(S.v).toISOString(), g["office:value-type"] = "date", g["office:date-value"] = dr(S.v).toISOString(), g["table:style-name"] = "ce1";
            break;
          //case 'e':
          default:
            c.push(t);
            continue;
        }
        var E = e(y);
        if (S.l && S.l.Target) {
          var R = S.l.Target;
          R = R.charAt(0) == "#" ? "#" + hb(R.slice(1)) : R, R.charAt(0) != "#" && !R.match(/^\w+:/) && (R = "../" + R), E = be("text:a", E, { "xlink:href": R.replace(/&/g, "&amp;") });
        }
        c.push("          " + be("table:table-cell", be("text:p", E, {}), g) + `
`);
      }
      c.push(`        </table:table-row>
`);
    }
    return c.push(`      </table:table>
`), c.join("");
  }, i = function(a, s) {
    a.push(` <office:automatic-styles>
`), a.push(`  <number:date-style style:name="N37" number:automatic-order="true">
`), a.push(`   <number:month number:style="long"/>
`), a.push(`   <number:text>/</number:text>
`), a.push(`   <number:day number:style="long"/>
`), a.push(`   <number:text>/</number:text>
`), a.push(`   <number:year/>
`), a.push(`  </number:date-style>
`);
    var o = 0;
    s.SheetNames.map(function(u) {
      return s.Sheets[u];
    }).forEach(function(u) {
      if (u && u["!cols"]) {
        for (var l = 0; l < u["!cols"].length; ++l) if (u["!cols"][l]) {
          var d = u["!cols"][l];
          if (d.width == null && d.wpx == null && d.wch == null) continue;
          nh(d), d.ods = o;
          var f = u["!cols"][l].wpx + "px";
          a.push('  <style:style style:name="co' + o + `" style:family="table-column">
`), a.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + f + `"/>
`), a.push(`  </style:style>
`), ++o;
        }
      }
    });
    var c = 0;
    s.SheetNames.map(function(u) {
      return s.Sheets[u];
    }).forEach(function(u) {
      if (u && u["!rows"]) {
        for (var l = 0; l < u["!rows"].length; ++l) if (u["!rows"][l]) {
          u["!rows"][l].ods = c;
          var d = u["!rows"][l].hpx + "px";
          a.push('  <style:style style:name="ro' + c + `" style:family="table-row">
`), a.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + d + `"/>
`), a.push(`  </style:style>
`), ++c;
        }
      }
    }), a.push(`  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">
`), a.push(`   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>
`), a.push(`  </style:style>
`), a.push(`  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>
`), a.push(` </office:automatic-styles>
`);
  };
  return function(s, o) {
    var c = [Dt], u = Ja({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
      "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
      "xmlns:math": "http://www.w3.org/1998/Math/MathML",
      "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
      "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
      "xmlns:ooo": "http://openoffice.org/2004/office",
      "xmlns:ooow": "http://openoffice.org/2004/writer",
      "xmlns:oooc": "http://openoffice.org/2004/calc",
      "xmlns:dom": "http://www.w3.org/2001/xml-events",
      "xmlns:xforms": "http://www.w3.org/2002/xforms",
      "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
      "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
      "xmlns:rpt": "http://openoffice.org/2005/report",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
      "xmlns:tableooo": "http://openoffice.org/2009/table",
      "xmlns:drawooo": "http://openoffice.org/2010/draw",
      "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
      "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
      "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
      "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
      "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
      "office:version": "1.2"
    }), l = Ja({
      "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
      "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
    });
    o.bookType == "fods" ? (c.push("<office:document" + u + l + `>
`), c.push(Ww().replace(/office:document-meta/g, "office:meta"))) : c.push("<office:document-content" + u + `>
`), i(c, s), c.push(`  <office:body>
`), c.push(`    <office:spreadsheet>
`);
    for (var d = 0; d != s.SheetNames.length; ++d) c.push(n(s.Sheets[s.SheetNames[d]], s, d));
    return c.push(`    </office:spreadsheet>
`), c.push(`  </office:body>
`), o.bookType == "fods" ? c.push("</office:document>") : c.push("</office:document-content>"), c.join("");
  };
})();
function bx(e, t) {
  if (t.bookType == "fods") return Wy(e, t);
  var r = z0(), n = "", i = [], a = [];
  return n = "mimetype", et(r, n, "application/vnd.oasis.opendocument.spreadsheet"), n = "content.xml", et(r, n, Wy(e, t)), i.push([n, "text/xml"]), a.push([n, "ContentFile"]), n = "styles.xml", et(r, n, zD(e, t)), i.push([n, "text/xml"]), a.push([n, "StylesFile"]), n = "meta.xml", et(r, n, Dt + Ww(
    /*::wb, opts*/
  )), i.push([n, "text/xml"]), a.push([n, "MetadataFile"]), n = "manifest.rdf", et(r, n, iP(
    a
    /*, opts*/
  )), i.push([n, "application/rdf+xml"]), n = "META-INF/manifest.xml", et(r, n, rP(
    i
    /*, opts*/
  )), r;
}
function zc(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function WD(e) {
  return typeof TextEncoder < "u" ? new TextEncoder().encode(e) : Gr(Ya(e));
}
function XD(e, t) {
  e:
    for (var r = 0; r <= e.length - t.length; ++r) {
      for (var n = 0; n < t.length; ++n)
        if (e[r + n] != t[n])
          continue e;
      return !0;
    }
  return !1;
}
function Gn(e) {
  var t = e.reduce(function(i, a) {
    return i + a.length;
  }, 0), r = new Uint8Array(t), n = 0;
  return e.forEach(function(i) {
    r.set(i, n), n += i.length;
  }), r;
}
function KD(e, t, r) {
  var n = Math.floor(r == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(r))) + 6176 - 20, i = r / Math.pow(10, n - 6176);
  e[t + 15] |= n >> 7, e[t + 14] |= (n & 127) << 1;
  for (var a = 0; i >= 1; ++a, i /= 256)
    e[t + a] = i & 255;
  e[t + 15] |= r >= 0 ? 0 : 128;
}
function Qa(e, t) {
  var r = t ? t[0] : 0, n = e[r] & 127;
  e:
    if (e[r++] >= 128 && (n |= (e[r] & 127) << 7, e[r++] < 128 || (n |= (e[r] & 127) << 14, e[r++] < 128) || (n |= (e[r] & 127) << 21, e[r++] < 128) || (n += (e[r] & 127) * Math.pow(2, 28), ++r, e[r++] < 128) || (n += (e[r] & 127) * Math.pow(2, 35), ++r, e[r++] < 128) || (n += (e[r] & 127) * Math.pow(2, 42), ++r, e[r++] < 128)))
      break e;
  return t && (t[0] = r), n;
}
function pt(e) {
  var t = new Uint8Array(7);
  t[0] = e & 127;
  var r = 1;
  e:
    if (e > 127) {
      if (t[r - 1] |= 128, t[r] = e >> 7 & 127, ++r, e <= 16383 || (t[r - 1] |= 128, t[r] = e >> 14 & 127, ++r, e <= 2097151) || (t[r - 1] |= 128, t[r] = e >> 21 & 127, ++r, e <= 268435455) || (t[r - 1] |= 128, t[r] = e / 256 >>> 21 & 127, ++r, e <= 34359738367) || (t[r - 1] |= 128, t[r] = e / 65536 >>> 21 & 127, ++r, e <= 4398046511103))
        break e;
      t[r - 1] |= 128, t[r] = e / 16777216 >>> 21 & 127, ++r;
    }
  return t.slice(0, r);
}
function Xi(e) {
  var t = 0, r = e[t] & 127;
  e:
    if (e[t++] >= 128) {
      if (r |= (e[t] & 127) << 7, e[t++] < 128 || (r |= (e[t] & 127) << 14, e[t++] < 128) || (r |= (e[t] & 127) << 21, e[t++] < 128))
        break e;
      r |= (e[t] & 127) << 28;
    }
  return r;
}
function kt(e) {
  for (var t = [], r = [0]; r[0] < e.length; ) {
    var n = r[0], i = Qa(e, r), a = i & 7;
    i = Math.floor(i / 8);
    var s = 0, o;
    if (i == 0)
      break;
    switch (a) {
      case 0:
        {
          for (var c = r[0]; e[r[0]++] >= 128; )
            ;
          o = e.slice(c, r[0]);
        }
        break;
      case 5:
        s = 4, o = e.slice(r[0], r[0] + s), r[0] += s;
        break;
      case 1:
        s = 8, o = e.slice(r[0], r[0] + s), r[0] += s;
        break;
      case 2:
        s = Qa(e, r), o = e.slice(r[0], r[0] + s), r[0] += s;
        break;
      case 3:
      case 4:
      default:
        throw new Error("PB Type ".concat(a, " for Field ").concat(i, " at offset ").concat(n));
    }
    var u = { data: o, type: a };
    t[i] == null ? t[i] = [u] : t[i].push(u);
  }
  return t;
}
function Gt(e) {
  var t = [];
  return e.forEach(function(r, n) {
    r.forEach(function(i) {
      i.data && (t.push(pt(n * 8 + i.type)), i.type == 2 && t.push(pt(i.data.length)), t.push(i.data));
    });
  }), Gn(t);
}
function Vr(e) {
  for (var t, r = [], n = [0]; n[0] < e.length; ) {
    var i = Qa(e, n), a = kt(e.slice(n[0], n[0] + i));
    n[0] += i;
    var s = {
      id: Xi(a[1][0].data),
      messages: []
    };
    a[2].forEach(function(o) {
      var c = kt(o.data), u = Xi(c[3][0].data);
      s.messages.push({
        meta: c,
        data: e.slice(n[0], n[0] + u)
      }), n[0] += u;
    }), (t = a[3]) != null && t[0] && (s.merge = Xi(a[3][0].data) >>> 0 > 0), r.push(s);
  }
  return r;
}
function Ui(e) {
  var t = [];
  return e.forEach(function(r) {
    var n = [];
    n[1] = [{ data: pt(r.id), type: 0 }], n[2] = [], r.merge != null && (n[3] = [{ data: pt(+!!r.merge), type: 0 }]);
    var i = [];
    r.messages.forEach(function(s) {
      i.push(s.data), s.meta[3] = [{ type: 0, data: pt(s.data.length) }], n[2].push({ data: Gt(s.meta), type: 2 });
    });
    var a = Gt(n);
    t.push(pt(a.length)), t.push(a), i.forEach(function(s) {
      return t.push(s);
    });
  }), Gn(t);
}
function YD(e, t) {
  if (e != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(e));
  for (var r = [0], n = Qa(t, r), i = []; r[0] < t.length; ) {
    var a = t[r[0]] & 3;
    if (a == 0) {
      var s = t[r[0]++] >> 2;
      if (s < 60)
        ++s;
      else {
        var o = s - 59;
        s = t[r[0]], o > 1 && (s |= t[r[0] + 1] << 8), o > 2 && (s |= t[r[0] + 2] << 16), o > 3 && (s |= t[r[0] + 3] << 24), s >>>= 0, s++, r[0] += o;
      }
      i.push(t.slice(r[0], r[0] + s)), r[0] += s;
      continue;
    } else {
      var c = 0, u = 0;
      if (a == 1 ? (u = (t[r[0]] >> 2 & 7) + 4, c = (t[r[0]++] & 224) << 3, c |= t[r[0]++]) : (u = (t[r[0]++] >> 2) + 1, a == 2 ? (c = t[r[0]] | t[r[0] + 1] << 8, r[0] += 2) : (c = (t[r[0]] | t[r[0] + 1] << 8 | t[r[0] + 2] << 16 | t[r[0] + 3] << 24) >>> 0, r[0] += 4)), i = [Gn(i)], c == 0)
        throw new Error("Invalid offset 0");
      if (c > i[0].length)
        throw new Error("Invalid offset beyond length");
      if (u >= c)
        for (i.push(i[0].slice(-c)), u -= c; u >= i[i.length - 1].length; )
          i.push(i[i.length - 1]), u -= i[i.length - 1].length;
      i.push(i[0].slice(-c, -c + u));
    }
  }
  var l = Gn(i);
  if (l.length != n)
    throw new Error("Unexpected length: ".concat(l.length, " != ").concat(n));
  return l;
}
function Hr(e) {
  for (var t = [], r = 0; r < e.length; ) {
    var n = e[r++], i = e[r] | e[r + 1] << 8 | e[r + 2] << 16;
    r += 3, t.push(YD(n, e.slice(r, r + i))), r += i;
  }
  if (r !== e.length)
    throw new Error("data is not a valid framed stream!");
  return Gn(t);
}
function qi(e) {
  for (var t = [], r = 0; r < e.length; ) {
    var n = Math.min(e.length - r, 268435455), i = new Uint8Array(4);
    t.push(i);
    var a = pt(n), s = a.length;
    t.push(a), n <= 60 ? (s++, t.push(new Uint8Array([n - 1 << 2]))) : n <= 256 ? (s += 2, t.push(new Uint8Array([240, n - 1 & 255]))) : n <= 65536 ? (s += 3, t.push(new Uint8Array([244, n - 1 & 255, n - 1 >> 8 & 255]))) : n <= 16777216 ? (s += 4, t.push(new Uint8Array([248, n - 1 & 255, n - 1 >> 8 & 255, n - 1 >> 16 & 255]))) : n <= 4294967296 && (s += 5, t.push(new Uint8Array([252, n - 1 & 255, n - 1 >> 8 & 255, n - 1 >> 16 & 255, n - 1 >>> 24 & 255]))), t.push(e.slice(r, r + n)), s += n, i[0] = 0, i[1] = s & 255, i[2] = s >> 8 & 255, i[3] = s >> 16 & 255, r += n;
  }
  return Gn(t);
}
function e0(e, t) {
  var r = new Uint8Array(32), n = zc(r), i = 12, a = 0;
  switch (r[0] = 5, e.t) {
    case "n":
      r[1] = 2, KD(r, i, e.v), a |= 1, i += 16;
      break;
    case "b":
      r[1] = 6, n.setFloat64(i, e.v ? 1 : 0, !0), a |= 2, i += 8;
      break;
    case "s":
      if (t.indexOf(e.v) == -1)
        throw new Error("Value ".concat(e.v, " missing from SST!"));
      r[1] = 3, n.setUint32(i, t.indexOf(e.v), !0), a |= 8, i += 4;
      break;
    default:
      throw "unsupported cell type " + e.t;
  }
  return n.setUint32(8, a, !0), r.slice(0, i);
}
function t0(e, t) {
  var r = new Uint8Array(32), n = zc(r), i = 12, a = 0;
  switch (r[0] = 3, e.t) {
    case "n":
      r[2] = 2, n.setFloat64(i, e.v, !0), a |= 32, i += 8;
      break;
    case "b":
      r[2] = 6, n.setFloat64(i, e.v ? 1 : 0, !0), a |= 32, i += 8;
      break;
    case "s":
      if (t.indexOf(e.v) == -1)
        throw new Error("Value ".concat(e.v, " missing from SST!"));
      r[2] = 3, n.setUint32(i, t.indexOf(e.v), !0), a |= 16, i += 4;
      break;
    default:
      throw "unsupported cell type " + e.t;
  }
  return n.setUint32(4, a, !0), r.slice(0, i);
}
function Mn(e) {
  var t = kt(e);
  return Qa(t[1][0].data);
}
function JD(e, t, r) {
  var n, i, a, s;
  if (!((n = e[6]) != null && n[0]) || !((i = e[7]) != null && i[0]))
    throw "Mutation only works on post-BNC storages!";
  var o = ((s = (a = e[8]) == null ? void 0 : a[0]) == null ? void 0 : s.data) && Xi(e[8][0].data) > 0 || !1;
  if (o)
    throw "Math only works with normal offsets";
  for (var c = 0, u = zc(e[7][0].data), l = 0, d = [], f = zc(e[4][0].data), p = 0, v = [], m = 0; m < t.length; ++m) {
    if (t[m] == null) {
      u.setUint16(m * 2, 65535, !0), f.setUint16(m * 2, 65535);
      continue;
    }
    u.setUint16(m * 2, l, !0), f.setUint16(m * 2, p, !0);
    var h, _;
    switch (typeof t[m]) {
      case "string":
        h = e0({ t: "s", v: t[m] }, r), _ = t0({ t: "s", v: t[m] }, r);
        break;
      case "number":
        h = e0({ t: "n", v: t[m] }, r), _ = t0({ t: "n", v: t[m] }, r);
        break;
      case "boolean":
        h = e0({ t: "b", v: t[m] }, r), _ = t0({ t: "b", v: t[m] }, r);
        break;
      default:
        throw new Error("Unsupported value " + t[m]);
    }
    d.push(h), l += h.length, v.push(_), p += _.length, ++c;
  }
  for (e[2][0].data = pt(c); m < e[7][0].data.length / 2; ++m)
    u.setUint16(m * 2, 65535, !0), f.setUint16(m * 2, 65535, !0);
  return e[6][0].data = Gn(d), e[3][0].data = Gn(v), c;
}
function QD(e, t) {
  if (!t || !t.numbers)
    throw new Error("Must pass a `numbers` option -- check the README");
  var r = e.Sheets[e.SheetNames[0]];
  e.SheetNames.length > 1 && console.error("The Numbers writer currently writes only the first table");
  var n = Pr(r["!ref"]);
  n.s.r = n.s.c = 0;
  var i = !1;
  n.e.c > 9 && (i = !0, n.e.c = 9), n.e.r > 49 && (i = !0, n.e.r = 49), i && console.error("The Numbers writer is currently limited to ".concat(Ft(n)));
  var a = Wc(r, { range: n, header: 1 }), s = ["~Sh33tJ5~"];
  a.forEach(function(C) {
    return C.forEach(function(T) {
      typeof T == "string" && s.push(T);
    });
  });
  var o = {}, c = [], u = xt.read(t.numbers, { type: "base64" });
  u.FileIndex.map(function(C, T) {
    return [C, u.FullPaths[T]];
  }).forEach(function(C) {
    var T = C[0], A = C[1];
    if (T.type == 2 && T.name.match(/\.iwa/)) {
      var L = T.content, b = Hr(L), P = Vr(b);
      P.forEach(function(te) {
        c.push(te.id), o[te.id] = { deps: [], location: A, type: Xi(te.messages[0].meta[1][0].data) };
      });
    }
  }), c.sort(function(C, T) {
    return C - T;
  });
  var l = c.filter(function(C) {
    return C > 1;
  }).map(function(C) {
    return [C, pt(C)];
  });
  u.FileIndex.map(function(C, T) {
    return [C, u.FullPaths[T]];
  }).forEach(function(C) {
    var T = C[0];
    if (C[1], !!T.name.match(/\.iwa/)) {
      var A = Vr(Hr(T.content));
      A.forEach(function(L) {
        L.messages.forEach(function(b) {
          l.forEach(function(P) {
            L.messages.some(function(te) {
              return Xi(te.meta[1][0].data) != 11006 && XD(te.data, P[1]);
            }) && o[P[0]].deps.push(L.id);
          });
        });
      });
    }
  });
  for (var d = xt.find(u, o[1].location), f = Vr(Hr(d.content)), p, v = 0; v < f.length; ++v) {
    var m = f[v];
    m.id == 1 && (p = m);
  }
  var h = Mn(kt(p.messages[0].data)[1][0].data);
  for (d = xt.find(u, o[h].location), f = Vr(Hr(d.content)), v = 0; v < f.length; ++v)
    m = f[v], m.id == h && (p = m);
  for (h = Mn(kt(p.messages[0].data)[2][0].data), d = xt.find(u, o[h].location), f = Vr(Hr(d.content)), v = 0; v < f.length; ++v)
    m = f[v], m.id == h && (p = m);
  for (h = Mn(kt(p.messages[0].data)[2][0].data), d = xt.find(u, o[h].location), f = Vr(Hr(d.content)), v = 0; v < f.length; ++v)
    m = f[v], m.id == h && (p = m);
  var _ = kt(p.messages[0].data);
  {
    _[6][0].data = pt(n.e.r + 1), _[7][0].data = pt(n.e.c + 1);
    var g = Mn(_[46][0].data), y = xt.find(u, o[g].location), x = Vr(Hr(y.content));
    {
      for (var S = 0; S < x.length && x[S].id != g; ++S)
        ;
      if (x[S].id != g)
        throw "Bad ColumnRowUIDMapArchive";
      var w = kt(x[S].messages[0].data);
      w[1] = [], w[2] = [], w[3] = [];
      for (var E = 0; E <= n.e.c; ++E) {
        var R = [];
        R[1] = R[2] = [{ type: 0, data: pt(E + 420690) }], w[1].push({ type: 2, data: Gt(R) }), w[2].push({ type: 0, data: pt(E) }), w[3].push({ type: 0, data: pt(E) });
      }
      w[4] = [], w[5] = [], w[6] = [];
      for (var N = 0; N <= n.e.r; ++N)
        R = [], R[1] = R[2] = [{ type: 0, data: pt(N + 726270) }], w[4].push({ type: 2, data: Gt(R) }), w[5].push({ type: 0, data: pt(N) }), w[6].push({ type: 0, data: pt(N) });
      x[S].messages[0].data = Gt(w);
    }
    y.content = qi(Ui(x)), y.size = y.content.length, delete _[46];
    var B = kt(_[4][0].data);
    {
      B[7][0].data = pt(n.e.r + 1);
      var F = kt(B[1][0].data), U = Mn(F[2][0].data);
      y = xt.find(u, o[U].location), x = Vr(Hr(y.content));
      {
        if (x[0].id != U)
          throw "Bad HeaderStorageBucket";
        var G = kt(x[0].messages[0].data);
        for (N = 0; N < a.length; ++N) {
          var M = kt(G[2][0].data);
          M[1][0].data = pt(N), M[4][0].data = pt(a[N].length), G[2][N] = { type: G[2][0].type, data: Gt(M) };
        }
        x[0].messages[0].data = Gt(G);
      }
      y.content = qi(Ui(x)), y.size = y.content.length;
      var V = Mn(B[2][0].data);
      y = xt.find(u, o[V].location), x = Vr(Hr(y.content));
      {
        if (x[0].id != V)
          throw "Bad HeaderStorageBucket";
        for (G = kt(x[0].messages[0].data), E = 0; E <= n.e.c; ++E)
          M = kt(G[2][0].data), M[1][0].data = pt(E), M[4][0].data = pt(n.e.r + 1), G[2][E] = { type: G[2][0].type, data: Gt(M) };
        x[0].messages[0].data = Gt(G);
      }
      y.content = qi(Ui(x)), y.size = y.content.length;
      var ie = Mn(B[4][0].data);
      (function() {
        for (var C = xt.find(u, o[ie].location), T = Vr(Hr(C.content)), A, L = 0; L < T.length; ++L) {
          var b = T[L];
          b.id == ie && (A = b);
        }
        var P = kt(A.messages[0].data);
        {
          P[3] = [];
          var te = [];
          s.forEach(function(q, J) {
            te[1] = [{ type: 0, data: pt(J) }], te[2] = [{ type: 0, data: pt(1) }], te[3] = [{ type: 2, data: WD(q) }], P[3].push({ type: 2, data: Gt(te) });
          });
        }
        A.messages[0].data = Gt(P);
        var H = Ui(T), D = qi(H);
        C.content = D, C.size = C.content.length;
      })();
      var W = kt(B[3][0].data);
      {
        var ae = W[1][0];
        delete W[2];
        var se = kt(ae.data);
        {
          var X = Mn(se[2][0].data);
          (function() {
            for (var C = xt.find(u, o[X].location), T = Vr(Hr(C.content)), A, L = 0; L < T.length; ++L) {
              var b = T[L];
              b.id == X && (A = b);
            }
            var P = kt(A.messages[0].data);
            {
              delete P[6], delete W[7];
              var te = new Uint8Array(P[5][0].data);
              P[5] = [];
              for (var H = 0, D = 0; D <= n.e.r; ++D) {
                var q = kt(te);
                H += JD(q, a[D], s), q[1][0].data = pt(D), P[5].push({ data: Gt(q), type: 2 });
              }
              P[1] = [{ type: 0, data: pt(n.e.c + 1) }], P[2] = [{ type: 0, data: pt(n.e.r + 1) }], P[3] = [{ type: 0, data: pt(H) }], P[4] = [{ type: 0, data: pt(n.e.r + 1) }];
            }
            A.messages[0].data = Gt(P);
            var J = Ui(T), ne = qi(J);
            C.content = ne, C.size = C.content.length;
          })();
        }
        ae.data = Gt(se);
      }
      B[3][0].data = Gt(W);
    }
    _[4][0].data = Gt(B);
  }
  p.messages[0].data = Gt(_);
  var k = Ui(f), I = qi(k);
  return d.content = I, d.size = d.content.length, u;
}
function ZD(e) {
  return function(r) {
    for (var n = 0; n != e.length; ++n) {
      var i = e[n];
      r[i[0]] === void 0 && (r[i[0]] = i[1]), i[2] === "n" && (r[i[0]] = Number(r[i[0]]));
    }
  };
}
function ch(e) {
  ZD([
    ["cellDates", !1],
    /* write date cells with type `d` */
    ["bookSST", !1],
    /* Generate Shared String Table */
    ["bookType", "xlsx"],
    /* Type of workbook (xlsx/m/b) */
    ["compression", !1],
    /* Use file compression */
    ["WTF", !1]
    /* WTF mode (throws errors) */
  ])(e);
}
function e4(e, t) {
  return t.bookType == "ods" ? bx(e, t) : t.bookType == "numbers" ? QD(e, t) : t.bookType == "xlsb" ? t4(e, t) : r4(e, t);
}
function t4(e, t) {
  Hi = 1024, e && !e.SSF && (e.SSF = yr(It)), e && e.SSF && (xl(), wl(e.SSF), t.revssf = Tl(e.SSF), t.revssf[e.SSF[65535]] = 0, t.ssf = e.SSF), t.rels = {}, t.wbrels = {}, t.Strings = /*::((*/
  [], t.Strings.Count = 0, t.Strings.Unique = 0, za ? t.revStrings = /* @__PURE__ */ new Map() : (t.revStrings = {}, t.revStrings.foo = [], delete t.revStrings.foo);
  var r = t.bookType == "xlsb" ? "bin" : "xml", n = mx.indexOf(t.bookType) > -1, i = Hw();
  ch(t = t || {});
  var a = z0(), s = "", o = 0;
  if (t.cellXfs = [], Xn(t.cellXfs, {}, { revssf: { General: 0 } }), e.Props || (e.Props = {}), s = "docProps/core.xml", et(a, s, Xw(e.Props, t)), i.coreprops.push(s), mt(t.rels, 2, s, ct.CORE_PROPS), s = "docProps/app.xml", !(e.Props && e.Props.SheetNames)) if (!e.Workbook || !e.Workbook.Sheets) e.Props.SheetNames = e.SheetNames;
  else {
    for (var c = [], u = 0; u < e.SheetNames.length; ++u)
      (e.Workbook.Sheets[u] || {}).Hidden != 2 && c.push(e.SheetNames[u]);
    e.Props.SheetNames = c;
  }
  for (e.Props.Worksheets = e.Props.SheetNames.length, et(a, s, Yw(e.Props)), i.extprops.push(s), mt(t.rels, 3, s, ct.EXT_PROPS), e.Custprops !== e.Props && Yt(e.Custprops || {}).length > 0 && (s = "docProps/custom.xml", et(a, s, Jw(e.Custprops)), i.custprops.push(s), mt(t.rels, 4, s, ct.CUST_PROPS)), o = 1; o <= e.SheetNames.length; ++o) {
    var l = { "!id": {} }, d = e.Sheets[e.SheetNames[o - 1]], f = (d || {})["!type"] || "sheet";
    switch (f) {
      case "chart":
      /* falls through */
      default:
        s = "xl/worksheets/sheet" + o + "." + r, et(a, s, iD(o - 1, s, t, e, l)), i.sheets.push(s), mt(t.wbrels, -1, "worksheets/sheet" + o + "." + r, ct.WS[0]);
    }
    if (d) {
      var p = d["!comments"], v = !1, m = "";
      p && p.length > 0 && (m = "xl/comments" + o + "." + r, et(a, m, oD(p, m)), i.comments.push(m), mt(l, -1, "../comments" + o + "." + r, ct.CMNT), v = !0), d["!legacy"] && v && et(a, "xl/drawings/vmlDrawing" + o + ".vml", hx(o, d["!comments"])), delete d["!comments"], delete d["!legacy"];
    }
    l["!id"].rId1 && et(a, zw(s), zi(l));
  }
  return t.Strings != null && t.Strings.length > 0 && (s = "xl/sharedStrings." + r, et(a, s, sD(t.Strings, s, t)), i.strs.push(s), mt(t.wbrels, -1, "sharedStrings." + r, ct.SST)), s = "xl/workbook." + r, et(a, s, nD(e, s)), i.workbooks.push(s), mt(t.rels, 1, s, ct.WB), s = "xl/theme/theme1.xml", et(a, s, fx(e.Themes, t)), i.themes.push(s), mt(t.wbrels, -1, "theme/theme1.xml", ct.THEME), s = "xl/styles." + r, et(a, s, aD(e, s, t)), i.styles.push(s), mt(t.wbrels, -1, "styles." + r, ct.STY), e.vbaraw && n && (s = "xl/vbaProject.bin", et(a, s, e.vbaraw), i.vba.push(s), mt(t.wbrels, -1, "vbaProject.bin", ct.VBA)), s = "xl/metadata." + r, et(a, s, cD(s)), i.metadata.push(s), mt(t.wbrels, -1, "metadata." + r, ct.XLMETA), et(a, "[Content_Types].xml", Gw(i, t)), et(a, "_rels/.rels", zi(t.rels)), et(a, "xl/_rels/workbook." + r + ".rels", zi(t.wbrels)), delete t.revssf, delete t.ssf, a;
}
function r4(e, t) {
  Hi = 1024, e && !e.SSF && (e.SSF = yr(It)), e && e.SSF && (xl(), wl(e.SSF), t.revssf = Tl(e.SSF), t.revssf[e.SSF[65535]] = 0, t.ssf = e.SSF), t.rels = {}, t.wbrels = {}, t.Strings = /*::((*/
  [], t.Strings.Count = 0, t.Strings.Unique = 0, za ? t.revStrings = /* @__PURE__ */ new Map() : (t.revStrings = {}, t.revStrings.foo = [], delete t.revStrings.foo);
  var r = "xml", n = mx.indexOf(t.bookType) > -1, i = Hw();
  ch(t = t || {});
  var a = z0(), s = "", o = 0;
  if (t.cellXfs = [], Xn(t.cellXfs, {}, { revssf: { General: 0 } }), e.Props || (e.Props = {}), s = "docProps/core.xml", et(a, s, Xw(e.Props, t)), i.coreprops.push(s), mt(t.rels, 2, s, ct.CORE_PROPS), s = "docProps/app.xml", !(e.Props && e.Props.SheetNames)) if (!e.Workbook || !e.Workbook.Sheets) e.Props.SheetNames = e.SheetNames;
  else {
    for (var c = [], u = 0; u < e.SheetNames.length; ++u)
      (e.Workbook.Sheets[u] || {}).Hidden != 2 && c.push(e.SheetNames[u]);
    e.Props.SheetNames = c;
  }
  e.Props.Worksheets = e.Props.SheetNames.length, et(a, s, Yw(e.Props)), i.extprops.push(s), mt(t.rels, 3, s, ct.EXT_PROPS), e.Custprops !== e.Props && Yt(e.Custprops || {}).length > 0 && (s = "docProps/custom.xml", et(a, s, Jw(e.Custprops)), i.custprops.push(s), mt(t.rels, 4, s, ct.CUST_PROPS));
  var l = ["SheetJ5"];
  for (t.tcid = 0, o = 1; o <= e.SheetNames.length; ++o) {
    var d = { "!id": {} }, f = e.Sheets[e.SheetNames[o - 1]], p = (f || {})["!type"] || "sheet";
    switch (p) {
      case "chart":
      /* falls through */
      default:
        s = "xl/worksheets/sheet" + o + "." + r, et(a, s, Sx(o - 1, t, e, d)), i.sheets.push(s), mt(t.wbrels, -1, "worksheets/sheet" + o + "." + r, ct.WS[0]);
    }
    if (f) {
      var v = f["!comments"], m = !1, h = "";
      if (v && v.length > 0) {
        var _ = !1;
        v.forEach(function(g) {
          g[1].forEach(function(y) {
            y.T == !0 && (_ = !0);
          });
        }), _ && (h = "xl/threadedComments/threadedComment" + o + "." + r, et(a, h, bC(v, l, t)), i.threadedcomments.push(h), mt(d, -1, "../threadedComments/threadedComment" + o + "." + r, ct.TCMNT)), h = "xl/comments" + o + "." + r, et(a, h, px(v)), i.comments.push(h), mt(d, -1, "../comments" + o + "." + r, ct.CMNT), m = !0;
      }
      f["!legacy"] && m && et(a, "xl/drawings/vmlDrawing" + o + ".vml", hx(o, f["!comments"])), delete f["!comments"], delete f["!legacy"];
    }
    d["!id"].rId1 && et(a, zw(s), zi(d));
  }
  return t.Strings != null && t.Strings.length > 0 && (s = "xl/sharedStrings." + r, et(a, s, ax(t.Strings, t)), i.strs.push(s), mt(t.wbrels, -1, "sharedStrings." + r, ct.SST)), s = "xl/workbook." + r, et(a, s, $x(e)), i.workbooks.push(s), mt(t.rels, 1, s, ct.WB), s = "xl/theme/theme1.xml", et(a, s, fx(e.Themes, t)), i.themes.push(s), mt(t.wbrels, -1, "theme/theme1.xml", ct.THEME), s = "xl/styles." + r, et(a, s, lx(e, t)), i.styles.push(s), mt(t.wbrels, -1, "styles." + r, ct.STY), e.vbaraw && n && (s = "xl/vbaProject.bin", et(a, s, e.vbaraw), i.vba.push(s), mt(t.wbrels, -1, "vbaProject.bin", ct.VBA)), s = "xl/metadata." + r, et(a, s, dx()), i.metadata.push(s), mt(t.wbrels, -1, "metadata." + r, ct.XLMETA), l.length > 1 && (s = "xl/persons/person.xml", et(a, s, FC(l)), i.people.push(s), mt(t.wbrels, -1, "persons/person.xml", ct.PEOPLE)), et(a, "[Content_Types].xml", Gw(i, t)), et(a, "_rels/.rels", zi(t.rels)), et(a, "xl/_rels/workbook." + r + ".rels", zi(t.wbrels)), delete t.revssf, delete t.ssf, a;
}
function n4(e, t) {
  var r = "";
  switch ((t || {}).type || "base64") {
    case "buffer":
      return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7]];
    case "base64":
      r = Sn(e.slice(0, 12));
      break;
    case "binary":
      r = e;
      break;
    case "array":
      return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7]];
    default:
      throw new Error("Unrecognized type " + (t && t.type || "undefined"));
  }
  return [r.charCodeAt(0), r.charCodeAt(1), r.charCodeAt(2), r.charCodeAt(3), r.charCodeAt(4), r.charCodeAt(5), r.charCodeAt(6), r.charCodeAt(7)];
}
function Fx(e, t) {
  switch (t.type) {
    case "base64":
    case "binary":
      break;
    case "buffer":
    case "array":
      t.type = "";
      break;
    case "file":
      return os(t.file, xt.write(e, { type: ft ? "buffer" : "" }));
    case "string":
      throw new Error("'string' output type invalid for '" + t.bookType + "' files");
    default:
      throw new Error("Unrecognized type " + t.type);
  }
  return xt.write(e, t);
}
function i4(e, t) {
  var r = yr(t || {}), n = e4(e, r);
  return a4(n, r);
}
function a4(e, t) {
  var r = {}, n = ft ? "nodebuffer" : typeof Uint8Array < "u" ? "array" : "string";
  if (t.compression && (r.compression = "DEFLATE"), t.password) r.type = n;
  else switch (t.type) {
    case "base64":
      r.type = "base64";
      break;
    case "binary":
      r.type = "string";
      break;
    case "string":
      throw new Error("'string' output type invalid for '" + t.bookType + "' files");
    case "buffer":
    case "file":
      r.type = n;
      break;
    default:
      throw new Error("Unrecognized type " + t.type);
  }
  var i = e.FullPaths ? xt.write(e, { fileType: "zip", type: (
    /*::(*/
    { nodebuffer: "buffer", string: "binary" }[r.type] || r.type
  ), compression: !!t.compression }) : e.generate(r);
  if (typeof Deno < "u" && typeof i == "string") {
    if (t.type == "binary" || t.type == "base64") return i;
    i = new Uint8Array(El(i));
  }
  return t.password && typeof encrypt_agile < "u" ? Fx(encrypt_agile(i, t.password), t) : t.type === "file" ? os(t.file, i) : t.type == "string" ? ja(
    /*::(*/
    i
    /*:: :any)*/
  ) : i;
}
function s4(e, t) {
  var r = t || {}, n = xD(e, r);
  return Fx(n, r);
}
function an(e, t, r) {
  r || (r = "");
  var n = r + e;
  switch (t.type) {
    case "base64":
      return Xa(Ya(n));
    case "binary":
      return Ya(n);
    case "string":
      return e;
    case "file":
      return os(t.file, n, "utf8");
    case "buffer":
      return ft ? Rn(n, "utf8") : typeof TextEncoder < "u" ? new TextEncoder().encode(n) : an(n, { type: "binary" }).split("").map(function(i) {
        return i.charCodeAt(0);
      });
  }
  throw new Error("Unrecognized type " + t.type);
}
function o4(e, t) {
  switch (t.type) {
    case "base64":
      return Xa(e);
    case "binary":
      return e;
    case "string":
      return e;
    /* override in sheet_to_txt */
    case "file":
      return os(t.file, e, "binary");
    case "buffer":
      return ft ? Rn(e, "binary") : e.split("").map(function(r) {
        return r.charCodeAt(0);
      });
  }
  throw new Error("Unrecognized type " + t.type);
}
function Sc(e, t) {
  switch (t.type) {
    case "string":
    case "base64":
    case "binary":
      for (var r = "", n = 0; n < e.length; ++n) r += String.fromCharCode(e[n]);
      return t.type == "base64" ? Xa(r) : t.type == "string" ? ja(r) : r;
    case "file":
      return os(t.file, e);
    case "buffer":
      return e;
    default:
      throw new Error("Unrecognized type " + t.type);
  }
}
function Dx(e, t) {
  DO(), zF(e);
  var r = yr(t || {});
  if (r.cellStyles && (r.cellNF = !0, r.sheetStubs = !0), r.type == "array") {
    r.type = "binary";
    var n = Dx(e, r);
    return r.type = "array", El(n);
  }
  var i = 0;
  if (r.sheet && (typeof r.sheet == "number" ? i = r.sheet : i = e.SheetNames.indexOf(r.sheet), !e.SheetNames[i]))
    throw new Error("Sheet not found: " + r.sheet + " : " + typeof r.sheet);
  switch (r.bookType || "xlsb") {
    case "xml":
    case "xlml":
      return an(ED(e, r), r);
    case "slk":
    case "sylk":
      return an(VP.from_sheet(e.Sheets[e.SheetNames[i]], r), r);
    case "htm":
    case "html":
      return an(Px(e.Sheets[e.SheetNames[i]], r), r);
    case "txt":
      return o4(kx(e.Sheets[e.SheetNames[i]], r), r);
    case "csv":
      return an(lh(e.Sheets[e.SheetNames[i]], r), r, "\uFEFF");
    case "dif":
      return an(HP.from_sheet(e.Sheets[e.SheetNames[i]], r), r);
    case "dbf":
      return Sc(jP.from_sheet(e.Sheets[e.SheetNames[i]], r), r);
    case "prn":
      return an(GP.from_sheet(e.Sheets[e.SheetNames[i]], r), r);
    case "rtf":
      return an(QP.from_sheet(e.Sheets[e.SheetNames[i]], r), r);
    case "eth":
      return an(ix.from_sheet(e.Sheets[e.SheetNames[i]], r), r);
    case "fods":
      return an(bx(e, r), r);
    case "wk1":
      return Sc(qy.sheet_to_wk1(e.Sheets[e.SheetNames[i]], r), r);
    case "wk3":
      return Sc(qy.book_to_wk3(e, r), r);
    case "biff2":
      r.biff || (r.biff = 2);
    /* falls through */
    case "biff3":
      r.biff || (r.biff = 3);
    /* falls through */
    case "biff4":
      return r.biff || (r.biff = 4), Sc(Nx(e, r), r);
    case "biff5":
      r.biff || (r.biff = 5);
    /* falls through */
    case "biff8":
    case "xla":
    case "xls":
      return r.biff || (r.biff = 8), s4(e, r);
    case "xlsx":
    case "xlsm":
    case "xlam":
    case "xlsb":
    case "numbers":
    case "ods":
      return i4(e, r);
    default:
      throw new Error("Unrecognized bookType |" + r.bookType + "|");
  }
}
function c4(e, t, r, n, i, a, s, o) {
  var c = Kt(r), u = o.defval, l = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw"), d = !0, f = i === 1 ? [] : {};
  if (i !== 1)
    if (Object.defineProperty) try {
      Object.defineProperty(f, "__rowNum__", { value: r, enumerable: !1 });
    } catch {
      f.__rowNum__ = r;
    }
    else f.__rowNum__ = r;
  if (!s || e[r]) for (var p = t.s.c; p <= t.e.c; ++p) {
    var v = s ? e[r][p] : e[n[p] + c];
    if (v === void 0 || v.t === void 0) {
      if (u === void 0) continue;
      a[p] != null && (f[a[p]] = u);
      continue;
    }
    var m = v.v;
    switch (v.t) {
      case "z":
        if (m == null) break;
        continue;
      case "e":
        m = m == 0 ? null : void 0;
        break;
      case "s":
      case "d":
      case "b":
      case "n":
        break;
      default:
        throw new Error("unrecognized type " + v.t);
    }
    if (a[p] != null) {
      if (m == null)
        if (v.t == "e" && m === null) f[a[p]] = null;
        else if (u !== void 0) f[a[p]] = u;
        else if (l && m === null) f[a[p]] = null;
        else continue;
      else
        f[a[p]] = l && (v.t !== "n" || v.t === "n" && o.rawNumbers !== !1) ? m : An(v, m, o);
      m != null && (d = !1);
    }
  }
  return { row: f, isempty: d };
}
function Wc(e, t) {
  if (e == null || e["!ref"] == null) return [];
  var r = { t: "n", v: 0 }, n = 0, i = 1, a = [], s = 0, o = "", c = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, u = t || {}, l = u.range != null ? u.range : e["!ref"];
  switch (u.header === 1 ? n = 1 : u.header === "A" ? n = 2 : Array.isArray(u.header) ? n = 3 : u.header == null && (n = 0), typeof l) {
    case "string":
      c = At(l);
      break;
    case "number":
      c = At(e["!ref"]), c.s.r = l;
      break;
    default:
      c = l;
  }
  n > 0 && (i = 0);
  var d = Kt(c.s.r), f = [], p = [], v = 0, m = 0, h = Array.isArray(e), _ = c.s.r, g = 0, y = {};
  h && !e[_] && (e[_] = []);
  var x = u.skipHidden && e["!cols"] || [], S = u.skipHidden && e["!rows"] || [];
  for (g = c.s.c; g <= c.e.c; ++g)
    if (!(x[g] || {}).hidden)
      switch (f[g] = ar(g), r = h ? e[_][g] : e[f[g] + d], n) {
        case 1:
          a[g] = g - c.s.c;
          break;
        case 2:
          a[g] = f[g];
          break;
        case 3:
          a[g] = u.header[g - c.s.c];
          break;
        default:
          if (r == null && (r = { w: "__EMPTY", t: "s" }), o = s = An(r, null, u), m = y[s] || 0, !m) y[s] = 1;
          else {
            do
              o = s + "_" + m++;
            while (y[o]);
            y[s] = m, y[o] = 1;
          }
          a[g] = o;
      }
  for (_ = c.s.r + i; _ <= c.e.r; ++_)
    if (!(S[_] || {}).hidden) {
      var w = c4(e, c, _, f, n, a, h, u);
      (w.isempty === !1 || (n === 1 ? u.blankrows !== !1 : u.blankrows)) && (p[v++] = w.row);
    }
  return p.length = v, p;
}
var Xy = /"/g;
function l4(e, t, r, n, i, a, s, o) {
  for (var c = !0, u = [], l = "", d = Kt(r), f = t.s.c; f <= t.e.c; ++f)
    if (n[f]) {
      var p = o.dense ? (e[r] || [])[f] : e[n[f] + d];
      if (p == null) l = "";
      else if (p.v != null) {
        c = !1, l = "" + (o.rawNumbers && p.t == "n" ? p.v : An(p, null, o));
        for (var v = 0, m = 0; v !== l.length; ++v) if ((m = l.charCodeAt(v)) === i || m === a || m === 34 || o.forceQuotes) {
          l = '"' + l.replace(Xy, '""') + '"';
          break;
        }
        l == "ID" && (l = '"ID"');
      } else p.f != null && !p.F ? (c = !1, l = "=" + p.f, l.indexOf(",") >= 0 && (l = '"' + l.replace(Xy, '""') + '"')) : l = "";
      u.push(l);
    }
  return o.blankrows === !1 && c ? null : u.join(s);
}
function lh(e, t) {
  var r = [], n = t ?? {};
  if (e == null || e["!ref"] == null) return "";
  var i = At(e["!ref"]), a = n.FS !== void 0 ? n.FS : ",", s = a.charCodeAt(0), o = n.RS !== void 0 ? n.RS : `
`, c = o.charCodeAt(0), u = new RegExp((a == "|" ? "\\|" : a) + "+$"), l = "", d = [];
  n.dense = Array.isArray(e);
  for (var f = n.skipHidden && e["!cols"] || [], p = n.skipHidden && e["!rows"] || [], v = i.s.c; v <= i.e.c; ++v) (f[v] || {}).hidden || (d[v] = ar(v));
  for (var m = 0, h = i.s.r; h <= i.e.r; ++h)
    (p[h] || {}).hidden || (l = l4(e, i, h, d, s, c, a, n), l != null && (n.strip && (l = l.replace(u, "")), (l || n.blankrows !== !1) && r.push((m++ ? o : "") + l)));
  return delete n.dense, r.join("");
}
function kx(e, t) {
  t || (t = {}), t.FS = "	", t.RS = `
`;
  var r = lh(e, t);
  return r;
}
function u4(e) {
  var t = "", r, n = "";
  if (e == null || e["!ref"] == null) return [];
  var i = At(e["!ref"]), a = "", s = [], o, c = [], u = Array.isArray(e);
  for (o = i.s.c; o <= i.e.c; ++o) s[o] = ar(o);
  for (var l = i.s.r; l <= i.e.r; ++l)
    for (a = Kt(l), o = i.s.c; o <= i.e.c; ++o)
      if (t = s[o] + a, r = u ? (e[l] || [])[o] : e[t], n = "", r !== void 0) {
        if (r.F != null) {
          if (t = r.F, !r.f) continue;
          n = r.f, t.indexOf(":") == -1 && (t = t + ":" + t);
        }
        if (r.f != null) n = r.f;
        else {
          if (r.t == "z") continue;
          if (r.t == "n" && r.v != null) n = "" + r.v;
          else if (r.t == "b") n = r.v ? "TRUE" : "FALSE";
          else if (r.w !== void 0) n = "'" + r.w;
          else {
            if (r.v === void 0) continue;
            r.t == "s" ? n = "'" + r.v : n = "" + r.v;
          }
        }
        c[c.length] = t + "=" + n;
      }
  return c;
}
function Lx(e, t, r) {
  var n = r || {}, i = +!n.skipHeader, a = e || {}, s = 0, o = 0;
  if (a && n.origin != null)
    if (typeof n.origin == "number") s = n.origin;
    else {
      var c = typeof n.origin == "string" ? qt(n.origin) : n.origin;
      s = c.r, o = c.c;
    }
  var u, l = { s: { c: 0, r: 0 }, e: { c: o, r: s + t.length - 1 + i } };
  if (a["!ref"]) {
    var d = At(a["!ref"]);
    l.e.c = Math.max(l.e.c, d.e.c), l.e.r = Math.max(l.e.r, d.e.r), s == -1 && (s = d.e.r + 1, l.e.r = s + t.length - 1 + i);
  } else
    s == -1 && (s = 0, l.e.r = t.length - 1 + i);
  var f = n.header || [], p = 0;
  t.forEach(function(m, h) {
    Yt(m).forEach(function(_) {
      (p = f.indexOf(_)) == -1 && (f[p = f.length] = _);
      var g = m[_], y = "z", x = "", S = _t({ c: o + p, r: s + h + i });
      u = Za(a, S), g && typeof g == "object" && !(g instanceof Date) ? a[S] = g : (typeof g == "number" ? y = "n" : typeof g == "boolean" ? y = "b" : typeof g == "string" ? y = "s" : g instanceof Date ? (y = "d", n.cellDates || (y = "n", g = _r(g)), x = n.dateNF || It[14]) : g === null && n.nullError && (y = "e", g = 0), u ? (u.t = y, u.v = g, delete u.w, delete u.R, x && (u.z = x)) : a[S] = u = { t: y, v: g }, x && (u.z = x));
    });
  }), l.e.c = Math.max(l.e.c, o + f.length - 1);
  var v = Kt(s);
  if (i) for (p = 0; p < f.length; ++p) a[ar(p + o) + v] = { t: "s", v: f[p] };
  return a["!ref"] = Ft(l), a;
}
function f4(e, t) {
  return Lx(null, e, t);
}
function Za(e, t, r) {
  if (typeof t == "string") {
    if (Array.isArray(e)) {
      var n = qt(t);
      return e[n.r] || (e[n.r] = []), e[n.r][n.c] || (e[n.r][n.c] = { t: "z" });
    }
    return e[t] || (e[t] = { t: "z" });
  }
  return typeof t != "number" ? Za(e, _t(t)) : Za(e, _t({ r: t, c: r || 0 }));
}
function d4(e, t) {
  if (typeof t == "number") {
    if (t >= 0 && e.SheetNames.length > t) return t;
    throw new Error("Cannot find sheet # " + t);
  } else if (typeof t == "string") {
    var r = e.SheetNames.indexOf(t);
    if (r > -1) return r;
    throw new Error("Cannot find sheet name |" + t + "|");
  } else throw new Error("Cannot find sheet |" + t + "|");
}
function h4() {
  return { SheetNames: [], Sheets: {} };
}
function p4(e, t, r, n) {
  var i = 1;
  if (!r) for (; i <= 65535 && e.SheetNames.indexOf(r = "Sheet" + i) != -1; ++i, r = void 0) ;
  if (!r || e.SheetNames.length >= 65535) throw new Error("Too many worksheets");
  if (n && e.SheetNames.indexOf(r) >= 0) {
    var a = r.match(/(^.*?)(\d+)$/);
    i = a && +a[2] || 0;
    var s = a && a[1] || r;
    for (++i; i <= 65535 && e.SheetNames.indexOf(r = s + i) != -1; ++i) ;
  }
  if (Rx(r), e.SheetNames.indexOf(r) >= 0) throw new Error("Worksheet with name |" + r + "| already exists!");
  return e.SheetNames.push(r), e.Sheets[r] = t, r;
}
function m4(e, t, r) {
  e.Workbook || (e.Workbook = {}), e.Workbook.Sheets || (e.Workbook.Sheets = []);
  var n = d4(e, t);
  switch (e.Workbook.Sheets[n] || (e.Workbook.Sheets[n] = {}), r) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + r);
  }
  e.Workbook.Sheets[n].Hidden = r;
}
function g4(e, t) {
  return e.z = t, e;
}
function Mx(e, t, r) {
  return t ? (e.l = { Target: t }, r && (e.l.Tooltip = r)) : delete e.l, e;
}
function v4(e, t, r) {
  return Mx(e, "#" + t, r);
}
function _4(e, t, r) {
  e.c || (e.c = []), e.c.push({ t, a: r || "SheetJS" });
}
function y4(e, t, r, n) {
  for (var i = typeof t != "string" ? t : At(t), a = typeof t == "string" ? t : Ft(t), s = i.s.r; s <= i.e.r; ++s) for (var o = i.s.c; o <= i.e.c; ++o) {
    var c = Za(e, s, o);
    c.t = "n", c.F = a, delete c.v, s == i.s.r && o == i.s.c && (c.f = r, n && (c.D = !0));
  }
  return e;
}
var r0 = {
  encode_col: ar,
  encode_row: Kt,
  encode_cell: _t,
  encode_range: Ft,
  decode_col: Q0,
  decode_row: J0,
  split_cell: DN,
  decode_cell: qt,
  decode_range: Pr,
  format_cell: An,
  sheet_add_aoa: Mw,
  sheet_add_json: Lx,
  sheet_add_dom: Cx,
  aoa_to_sheet: na,
  json_to_sheet: f4,
  table_to_sheet: Ix,
  table_to_book: HD,
  sheet_to_csv: lh,
  sheet_to_txt: kx,
  sheet_to_json: Wc,
  sheet_to_html: Px,
  sheet_to_formulae: u4,
  sheet_to_row_object_array: Wc,
  sheet_get_cell: Za,
  book_new: h4,
  book_append_sheet: p4,
  book_set_sheet_visibility: m4,
  cell_set_number_format: g4,
  cell_set_hyperlink: Mx,
  cell_set_internal_link: v4,
  cell_add_comment: _4,
  sheet_set_array_formula: y4,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
};
let u0, Ye = null, Oc;
async function E4() {
  u0 || (u0 = (await import("better-sqlite3")).default, Oc = vt.join(sn.getPath("userData"), "gravio.db"));
}
async function w4() {
  try {
    await E4();
    const e = vt.dirname(Oc);
    return Kr.existsSync(e) || Kr.mkdirSync(e, { recursive: !0 }), Ye = new u0(Oc, { verbose: console.log }), Ye.pragma("journal_mode = WAL"), x4(), console.log(" Base de datos SQLite inicializada en:", Oc), Ye;
  } catch (e) {
    throw console.error(" Error al inicializar base de datos:", e), e;
  }
}
function x4() {
  if (Ye) {
    Ye.pragma("foreign_keys = OFF"), Ye.exec(`
    CREATE TABLE IF NOT EXISTS roles (
      id TEXT PRIMARY KEY,
      nombre TEXT UNIQUE NOT NULL,
      created_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS empresa (
      id TEXT PRIMARY KEY,
      empresa TEXT NOT NULL,
      clave_empresa INTEGER UNIQUE,
      prefijo TEXT NOT NULL
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS rutas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      ruta TEXT NOT NULL,
      clave_ruta INTEGER UNIQUE,
      clave_empresa INTEGER
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS operadores (
      id TEXT PRIMARY KEY,
      operador TEXT NOT NULL,
      clave_operador INTEGER UNIQUE NOT NULL,
      created_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS usuarios (
      id TEXT PRIMARY KEY,
      nombre TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      telefono TEXT,
      rol_id TEXT,
      activo INTEGER DEFAULT 1,
      password TEXT,
      password_hash TEXT,
      pin TEXT,
      pin_expires_at INTEGER,
      created_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS vehiculos (
      id TEXT PRIMARY KEY,
      no_economico TEXT NOT NULL,
      placas TEXT NOT NULL,
      clave_empresa INTEGER,
      created_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS conceptos (
      id TEXT PRIMARY KEY,
      nombre TEXT UNIQUE NOT NULL,
      clave_concepto INTEGER,
      activo INTEGER DEFAULT 1,
      created_at INTEGER DEFAULT (strftime('%s', 'now')),
      updated_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS registros (
      id TEXT PRIMARY KEY,
      clave_ruta INTEGER,
      placa_vehiculo TEXT NOT NULL,
      numero_economico TEXT,
      clave_operador INTEGER,
      operador TEXT,
      ruta TEXT,
      peso REAL,
      peso_entrada REAL,
      peso_salida REAL,
      fecha_entrada INTEGER,
      fecha_salida INTEGER,
      fecha_registro INTEGER DEFAULT (strftime('%s', 'now')),
      tipo_pesaje TEXT DEFAULT 'entrada',
      folio TEXT,
      clave_concepto INTEGER,
      concepto_id TEXT,
      clave_empresa INTEGER,
      observaciones TEXT,
      sincronizado INTEGER DEFAULT 0,
      created_at INTEGER DEFAULT (strftime('%s', 'now')),
      updated_at INTEGER DEFAULT (strftime('%s', 'now')),
      registrado_por TEXT
    )
  `);
    try {
      Ye.pragma("table_info(registros)").some((r) => r.name === "registrado_por") || (Ye.exec("ALTER TABLE registros ADD COLUMN registrado_por TEXT"), console.log(" Columna registrado_por agregada a tabla registros"));
    } catch (e) {
      console.warn(" Error al verificar/agregar columna registrado_por:", e);
    }
    Ye.exec(`
    CREATE TABLE IF NOT EXISTS operadores_empresas (
      operador_id TEXT NOT NULL,
      clave_empresa INTEGER NOT NULL,
      PRIMARY KEY (operador_id, clave_empresa)
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS conceptos_empresas (
      concepto_id TEXT NOT NULL,
      clave_empresa INTEGER NOT NULL,
      PRIMARY KEY (concepto_id, clave_empresa)
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS sync_queue (
      id TEXT PRIMARY KEY,
      table_name TEXT NOT NULL,
      operation TEXT NOT NULL,
      data TEXT NOT NULL,
      attempts INTEGER DEFAULT 0,
      last_attempt INTEGER,
      created_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS sync_metadata (
      key TEXT PRIMARY KEY,
      value TEXT,
      updated_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `), Ye.exec(`
    CREATE TABLE IF NOT EXISTS folio_sequences (
      id TEXT PRIMARY KEY,
      clave_empresa INTEGER UNIQUE NOT NULL,
      prefijo_empresa TEXT NOT NULL,
      ultimo_numero INTEGER NOT NULL DEFAULT 0,
      sincronizado INTEGER DEFAULT 0,
      updated_at TEXT NOT NULL
    )
  `), Ye.exec(`
    CREATE INDEX IF NOT EXISTS idx_registros_sincronizado ON registros(sincronizado);
    CREATE INDEX IF NOT EXISTS idx_registros_fecha ON registros(fecha_registro);
    CREATE INDEX IF NOT EXISTS idx_registros_placa ON registros(placa_vehiculo);
    CREATE INDEX IF NOT EXISTS idx_registros_id ON registros(id);
    CREATE INDEX IF NOT EXISTS idx_registros_fecha_entrada ON registros(fecha_entrada);
    CREATE INDEX IF NOT EXISTS idx_registros_pending ON registros(peso_salida) WHERE peso_salida IS NULL;
    CREATE INDEX IF NOT EXISTS idx_registros_unsynced ON registros(sincronizado, updated_at) WHERE sincronizado = 0;
    CREATE INDEX IF NOT EXISTS idx_registros_empresa_folio ON registros(clave_empresa, folio DESC) WHERE folio IS NOT NULL;
    CREATE INDEX IF NOT EXISTS idx_registros_folio_lookup ON registros(folio) WHERE folio IS NOT NULL;
    -- Unique constraint on folio per empresa (prevents duplicates)
    CREATE UNIQUE INDEX IF NOT EXISTS idx_registros_unique_folio ON registros(clave_empresa, folio) WHERE folio IS NOT NULL;
    CREATE INDEX IF NOT EXISTS idx_sync_queue_table ON sync_queue(table_name);
    CREATE INDEX IF NOT EXISTS idx_usuarios_email ON usuarios(email);
    CREATE INDEX IF NOT EXISTS idx_vehiculos_placas ON vehiculos(placas);
    CREATE INDEX IF NOT EXISTS idx_operadores_clave ON operadores(clave_operador);
    CREATE INDEX IF NOT EXISTS idx_rutas_clave ON rutas(clave_ruta);
    CREATE INDEX IF NOT EXISTS idx_empresa_clave ON empresa(clave_empresa);
    CREATE INDEX IF NOT EXISTS idx_conceptos_id ON conceptos(id);
    CREATE INDEX IF NOT EXISTS idx_folio_sequences_empresa ON folio_sequences(clave_empresa);
  `), Ye.pragma("foreign_keys = OFF"), console.log(" Tablas de base de datos creadas (estructura compatible con Supabase)"), console.log("  Foreign keys deshabilitadas para operacin offline-first");
  }
}
function Ux(e) {
  return e.map((t) => t === void 0 || t === null ? null : typeof t == "number" || typeof t == "string" || typeof t == "bigint" || Buffer.isBuffer(t) ? t : typeof t == "boolean" ? t ? 1 : 0 : typeof t == "object" ? (console.warn(" Convirtiendo objeto a JSON string:", t), JSON.stringify(t)) : String(t));
}
function T4(e, t = []) {
  if (!Ye)
    throw new Error("Base de datos no inicializada");
  try {
    const r = Ux(t), n = Ye.prepare(e);
    if (e.trim().toUpperCase().startsWith("SELECT"))
      return n.all(...r);
    {
      const i = n.run(...r);
      return [{ changes: i.changes, lastInsertRowid: i.lastInsertRowid }];
    }
  } catch (r) {
    throw console.error(" Error en query:", r), console.error("   SQL:", e), console.error("   Params:", t), r;
  }
}
function S4(e) {
  if (!Ye)
    throw new Error("Base de datos no inicializada");
  try {
    Ye.exec(e);
  } catch (t) {
    throw console.error(" Error en comando SQL:", t), t;
  }
}
function A4(e) {
  if (!Ye)
    throw new Error("Base de datos no inicializada");
  const t = Ye.transaction((r) => {
    for (const n of r) {
      const i = Ye.prepare(n.sql), a = Ux(n.params || []);
      i.run(...a);
    }
  });
  try {
    t(e);
  } catch (r) {
    throw console.error(" Error en transaccin:", r), r;
  }
}
function R4(e, t) {
  if (!Ye)
    throw new Error("Base de datos no inicializada");
  return Ye.transaction(() => {
    const n = Ye.prepare(
      "SELECT * FROM folio_sequences WHERE clave_empresa = ?"
    ).get(e);
    let i;
    if (n) {
      i = n.ultimo_numero + 1;
      const s = (/* @__PURE__ */ new Date()).toISOString();
      Ye.prepare(`
        UPDATE folio_sequences
        SET ultimo_numero = ?, sincronizado = 0, updated_at = ?
        WHERE clave_empresa = ?
      `).run(i, s, e), console.log(` Secuencia incrementada para empresa ${e}: ${n.ultimo_numero}  ${i}`);
    } else {
      i = 1;
      const s = `seq-${e}`, o = (/* @__PURE__ */ new Date()).toISOString();
      Ye.prepare(`
        INSERT INTO folio_sequences
        (id, clave_empresa, prefijo_empresa, ultimo_numero, sincronizado, updated_at)
        VALUES (?, ?, ?, ?, ?, ?)
      `).run(s, e, t, i, 0, o), console.log(` Nueva secuencia inicializada para empresa ${e}: ${i}`);
    }
    return { folio: `${t}-${i.toString().padStart(7, "0")}`, ultimoNumero: i };
  }).immediate();
}
function $4(e, t = []) {
  if (!Ye) throw new Error("Database not initialized");
  try {
    return Ye.prepare(e).get(...t);
  } catch (r) {
    throw console.error(" Error en getOne:", r), r;
  }
}
function Ky(e, t = []) {
  if (!Ye) throw new Error("Database not initialized");
  try {
    return Ye.prepare(e).all(...t);
  } catch (r) {
    throw console.error(" Error en getAll:", r), r;
  }
}
function O4(e, t = []) {
  if (!Ye) throw new Error("Database not initialized");
  try {
    return Ye.prepare(e).run(...t);
  } catch (r) {
    throw console.error(" Error en runCommand:", r), r;
  }
}
function N4() {
  Ye && (Ye.close(), Ye = null, console.log(" Base de datos cerrada"));
}
const P4 = hT(pT);
let Xc, qx;
async function Bx() {
  Xc || (Xc = (await import("serialport")).SerialPort, qx = (await import("@serialport/parser-readline")).ReadlineParser);
}
let fr = null, f0 = null, uh = "";
const Ac = {
  baudRate: 2400,
  dataBits: 8,
  stopBits: 1,
  parity: "none",
  autoOpen: !1
};
async function C4() {
  try {
    await Bx();
    const e = await Xc.list();
    if (console.log(" Puertos raw encontrados (node-serialport):", e), process.platform === "win32")
      try {
        const { stdout: r } = await P4('powershell -command "[System.IO.Ports.SerialPort]::GetPortNames()"'), n = r.trim().split(/\r?\n/).filter((i) => i && i.trim().length > 0);
        console.log(" Puertos encontrados va PowerShell:", n), n.forEach((i) => {
          const a = i.trim();
          e.find((s) => s.path === a) || e.push({
            path: a,
            manufacturer: "Puerto Virtual (Detectado por OS)",
            serialNumber: void 0,
            vendorId: void 0,
            productId: void 0
          });
        });
      } catch (r) {
        console.warn(" Error al listar puertos con PowerShell:", r);
      }
    return { success: !0, ports: e.map((r) => ({
      path: r.path,
      manufacturer: r.manufacturer
    })) };
  } catch (e) {
    const t = e instanceof Error ? e.message : String(e);
    return console.error(" Error al listar puertos:", t), { success: !1, error: t };
  }
}
function I4(e) {
  try {
    const t = e.trim(), r = /\)0\s+(\d+)\s+(\d+)/, n = t.match(r);
    if (n) {
      const [, c, u] = n;
      return parseFloat(`${c}.${u}`);
    }
    const i = /[)>+\-SD]\s*(\d+)\s+(\d+)\s+(\d+)/, a = t.match(i);
    if (a) {
      const [, , c, u] = a;
      return parseFloat(`${c}.${u}`);
    }
    const s = /(\d+\.?\d*)/, o = t.match(s);
    return o ? parseFloat(o[1]) : null;
  } catch (t) {
    return console.error(" Error al parsear peso:", t), null;
  }
}
async function b4(e, t = Ac.baudRate, r) {
  try {
    return await Bx(), fr && fr.isOpen && await fh(), fr = new Xc({
      path: e,
      baudRate: t,
      dataBits: Ac.dataBits,
      stopBits: Ac.stopBits,
      parity: Ac.parity,
      autoOpen: !1
    }), f0 = fr.pipe(new qx({ delimiter: "\r" })), f0.on("data", (n) => {
      const i = n.trim();
      if (!i) return;
      console.log(` RAW: ${JSON.stringify(i)}`);
      const a = I4(i);
      a !== null && (uh = a.toString(), console.log(" Peso parseado:", a, "kg"), r && r(a));
    }), fr.on("error", (n) => {
      console.error(" Error en puerto serial:", n);
    }), fr.on("close", () => {
      console.log(" Puerto serial cerrado");
    }), await new Promise((n, i) => {
      fr.open((a) => {
        a ? i(a) : (console.log(` Puerto serial ${e} abierto a ${t} baud`), n());
      });
    }), { success: !0 };
  } catch (n) {
    const i = n instanceof Error ? n.message : String(n);
    return console.error(" Error al abrir puerto serial:", i), { success: !1, error: i };
  }
}
async function fh() {
  try {
    return fr && fr.isOpen && await new Promise((e, t) => {
      fr.close((r) => {
        r ? (console.error(" Error al cerrar puerto:", r), t(r)) : (fr = null, f0 = null, uh = "", e());
      });
    }), { success: !0 };
  } catch (e) {
    return { success: !1, error: e instanceof Error ? e.message : String(e) };
  }
}
function F4() {
  return uh;
}
function D4() {
  return fr ? {
    path: fr.path,
    baudRate: fr.baudRate,
    isOpen: fr.isOpen
  } : null;
}
function k4(e) {
  const t = (a) => a.toLocaleDateString("es-MX", {
    day: "2-digit",
    month: "2-digit",
    year: "numeric"
  }), r = (a) => a.toLocaleTimeString("es-MX", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: !1
  }), n = (a) => a ? (a / 1e3).toFixed(3) : "0.000", i = () => {
    if (!e.fechaEntrada || !e.fechaSalida) return "0";
    const a = e.fechaSalida.getTime() - e.fechaEntrada.getTime();
    return Math.floor(a / (1e3 * 60)).toString();
  };
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    @page {
      size: 80mm auto;
      margin: 0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
      font-size: 11px;
      font-weight: bold;
      line-height: 1.4;
      width: 80mm;
      padding: 2mm 5mm;
      background: white;
      color: #000;
      -webkit-print-color-adjust: exact;
      print-color-adjust: exact;
    }

    .logo-container {
      text-align: center;
      margin-bottom: 4px;
    }

    .logo {
      max-width: 65mm;
      max-height: 18mm;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 6px;
    }

    .company-name {
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 1px;
      line-height: 1.2;
    }

    .company-address {
      font-size: 10px;
      font-weight: bold;
      margin-bottom: 4px;
    }

    .separator {
      border-bottom: 1px dashed #000;
      margin: 3px 0;
    }

    .folio {
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 2px;
    }

    .field {
      font-size: 10px;
      font-weight: bold;
      margin-bottom: 1.5px;
      line-height: 1.3;
    }

    .field-label {
      display: inline-block;
      min-width: 50px;
    }

    .section-title {
      font-size: 11px;
      font-weight: bold;
      margin-top: 4px;
      margin-bottom: 2px;
      text-decoration: underline;
    }

    .pesos-section {
      margin-top: 5px;
      padding-top: 3px;
      border-top: 1px solid #000;
    }

    .peso-field {
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 1px;
      display: flex;
      justify-content: space-between;
    }

    .footer {
      margin-top: 5px;
      padding-top: 3px;
      border-top: 1px dashed #000;
      font-size: 10px;
      font-weight: bold;
    }

    @media print {
      body {
        width: 80mm;
      }
    }
  </style>
</head>
<body>
  ${e.companyLogo ? `
  <div class="logo-container">
    <img src="${e.companyLogo}" alt="Logo" class="logo">
  </div>
  ` : ""}

  <div class="header">
    ${e.companyName ? `<div class="company-name">${e.companyName}</div>` : ""}
    ${e.companyAddress ? `<div class="company-address">${e.companyAddress}</div>` : ""}
  </div>

  <div class="folio">Folio: ${e.folio}</div>
  <div class="field">Entrada: ${e.fechaEntrada ? `${t(e.fechaEntrada)} ${r(e.fechaEntrada)}` : "N/A"}</div>
  <div class="field">Salida: ${e.fechaSalida ? `${t(e.fechaSalida)} ${r(e.fechaSalida)}` : "N/A"}</div>
  <div class="field">Placas: ${e.vehiculo.placas}</div>

  <div class="separator"></div>

  <div class="field">Concepto: ${e.conceptoClave} - ${e.conceptoNombre}</div>
  <div class="field">Empresa: ${e.empresaClave} - ${e.empresaNombre}</div>
  <div class="field">Operador: ${e.operadorClave} - ${e.operadorNombre}</div>
  <div class="field">Ruta: ${e.rutaClave} - ${e.rutaNombre}</div>
  <div class="field">Vehiculo (No. economico): ${e.vehiculo.numeroEconomico}</div>

  <div class="pesos-section">
    <div class="peso-field">
      <span>Peso Bruto:</span>
      <span>${n(e.pesos.entrada)} t</span>
    </div>
    <div class="peso-field">
      <span>Peso Tara:</span>
      <span>${n(e.pesos.salida)} t</span>
    </div>
    <div class="peso-field">
      <span>Peso Neto:</span>
      <span>${n(e.pesos.neto)} t</span>
    </div>
    <div class="peso-field">
      <span>Tiempo:</span>
      <span>${i()} min</span>
    </div>
  </div>

  <div class="footer">
    ${e.observaciones ? `<div>Obs: ${e.observaciones}</div>` : ""}
    ${e.usuario ? `<div>Usuario: ${e.usuario}</div>` : ""}
  </div>
</body>
</html>
  `.trim();
}
async function L4(e) {
  console.log(" listPrinters() llamada - mainWindow:", e ? "disponible" : "NULL");
  try {
    if (!e)
      return console.warn(" No hay ventana principal disponible"), [];
    console.log(" Obteniendo impresoras del sistema...");
    const t = await e.webContents.getPrintersAsync();
    console.log(" Impresoras raw del sistema:", JSON.stringify(t, null, 2));
    const r = t.map((n) => ({
      name: n.name,
      displayName: n.displayName || n.name,
      description: n.description || "",
      status: n.status || 0,
      isDefault: n.isDefault || !1,
      options: n.options || {}
    }));
    return console.log(" Impresoras detectadas:", r.length), console.log(" Impresoras formateadas:", JSON.stringify(r, null, 2)), r;
  } catch (t) {
    return console.error(" Error al listar impresoras:", t), console.error(" Stack trace:", t.stack), [];
  }
}
async function M4(e, t) {
  try {
    if (console.log(" Preparando impresin trmica:", t), !t.printerName)
      return console.error(" No se especific nombre de impresora"), !1;
    const r = new d0({
      show: !1,
      width: 302,
      // 80mm  302px @ 96 DPI
      height: 600,
      webPreferences: {
        nodeIntegration: !1,
        contextIsolation: !0
      }
    }), n = k4({
      folio: t.folio || "PENDIENTE",
      fecha: t.fecha ? new Date(t.fecha) : /* @__PURE__ */ new Date(),
      companyName: t.companyName,
      companyAddress: t.companyAddress,
      companyLogo: t.companyLogo,
      empresaClave: t.empresaClave || "",
      empresaNombre: t.empresaNombre || "Sin empresa",
      conceptoClave: t.conceptoClave || "",
      conceptoNombre: t.conceptoNombre || "Sin concepto",
      vehiculo: {
        placas: t.vehiculo?.placas || "",
        numeroEconomico: t.vehiculo?.numeroEconomico || "N/A"
      },
      operadorClave: t.operadorClave || "",
      operadorNombre: t.operadorNombre || "Sin operador",
      rutaClave: t.rutaClave || "",
      rutaNombre: t.rutaNombre || "Sin ruta",
      pesos: {
        entrada: t.pesos?.entrada,
        salida: t.pesos?.salida,
        neto: t.pesos?.neto
      },
      fechaEntrada: t.fechaEntrada ? new Date(t.fechaEntrada) : void 0,
      fechaSalida: t.fechaSalida ? new Date(t.fechaSalida) : void 0,
      observaciones: t.observaciones,
      usuario: t.usuario
    });
    return await r.loadURL("data:text/html;charset=utf-8," + encodeURIComponent(n)), await new Promise((i) => setTimeout(i, 500)), new Promise((i) => {
      r.webContents.print({
        silent: !0,
        printBackground: !0,
        deviceName: t.printerName,
        pageSize: {
          width: 8e4,
          // 80mm en micrones
          height: 297e3
          // Largo variable, usar altura estndar
        },
        margins: {
          marginType: "none"
        }
      }, (a, s) => {
        a ? (console.log(" Impresin enviada exitosamente"), i(!0)) : (console.error(" Error de impresin:", s), i(!1)), setTimeout(() => {
          try {
            r.close();
          } catch {
            console.warn("Ventana ya cerrada");
          }
        }, 1e3);
      });
    });
  } catch (r) {
    return console.error(" Error al imprimir:", r), !1;
  }
}
const n0 = vt.dirname(mT(import.meta.url));
let Ct = null;
const Rc = new IO(), i0 = /* @__PURE__ */ new Map();
async function U4(e, t) {
  const r = i0.get(e);
  r && await r.catch(() => {
  });
  let n;
  const i = new Promise((a) => {
    n = a;
  });
  i0.set(e, i);
  try {
    return await t();
  } finally {
    n(), i0.delete(e);
  }
}
const hi = process.env.NODE_ENV === "development";
function Yy() {
  Ct = new d0({
    width: 1280,
    height: 800,
    minWidth: 1024,
    minHeight: 768,
    webPreferences: {
      preload: vt.join(n0, "preload.cjs"),
      nodeIntegration: !1,
      contextIsolation: !0,
      sandbox: !1
      // Necesario para serialport y sqlite
    },
    title: "Gravio - Sistema de Relleno Sanitario",
    icon: vt.join(n0, "../public/icon.png"),
    autoHideMenuBar: !hi
  }), Ct.webContents.session.webRequest.onHeadersReceived((e, t) => {
    t({
      responseHeaders: {
        ...e.responseHeaders,
        "Content-Security-Policy": [
          hi ? "default-src 'self'; script-src 'self' 'unsafe-inline' http://localhost:*; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://*.supabase.co wss://*.supabase.co http://localhost:* ws://localhost:*; font-src 'self' data:;" : "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://*.supabase.co wss://*.supabase.co; font-src 'self' data:;"
        ]
      }
    });
  }), hi ? (Ct.loadURL("http://localhost:5173"), Ct.webContents.openDevTools()) : Ct.loadFile(vt.join(n0, "../dist/index.html")), Ct.on("closed", () => {
    Ct = null;
  });
}
kr.autoUpdater.autoDownload = !0;
kr.autoUpdater.autoInstallOnAppQuit = !0;
kr.autoUpdater.on("checking-for-update", () => {
  console.log(" Verificando actualizaciones...");
});
kr.autoUpdater.on("update-available", (e) => {
  console.log(" Actualizacin disponible:", e.version), console.log(" Descargando actualizacin en segundo plano..."), Ct && Ct.webContents.send("update-available", e);
});
kr.autoUpdater.on("update-not-available", () => {
  console.log(" La aplicacin est actualizada");
});
kr.autoUpdater.on("download-progress", (e) => {
  Ct && Ct.webContents.send("update-download-progress", e);
});
kr.autoUpdater.on("update-downloaded", (e) => {
  console.log(" Actualizacin descargada:", e.version), Ct && Ct.webContents.send("update-downloaded", e);
});
kr.autoUpdater.on("error", (e) => {
  console.error(" Error en auto-updater:", e);
});
sn.whenReady().then(async () => {
  await w4(), Yy(), q4(), hi || setTimeout(() => {
    kr.autoUpdater.checkForUpdates();
  }, 5e3), sn.on("activate", () => {
    d0.getAllWindows().length === 0 && Yy();
  });
});
sn.on("window-all-closed", () => {
  process.platform !== "darwin" && sn.quit();
});
sn.on("before-quit", async () => {
  await fh(), N4();
});
function q4() {
  wt.handle("app:getVersion", () => sn.getVersion()), wt.handle("app:getPlatform", () => process.platform), wt.handle("serial:list", C4), wt.handle("serial:open", async (e, t, r) => await b4(t, r, (i) => {
    Ct && Ct.webContents.send("serial:data", i.toString());
  })), wt.handle("serial:close", fh), wt.handle("serial:read", F4), wt.handle("serial:getPortInfo", D4), wt.handle("db:query", (e, t, r) => T4(t, r)), wt.handle("db:exec", (e, t) => S4(t)), wt.handle("db:transaction", (e, t) => A4(t)), wt.handle("db:get", (e, t, r) => $4(t, r)), wt.handle("db:run", (e, t, r) => {
    O4(t, r);
  }), wt.handle("db:all", (e, t, r) => Ky(t, r)), wt.handle("db:atomicIncrementFolio", async (e, t, r) => U4(t, async () => R4(t, r))), wt.handle("printer:list", () => L4(Ct)), wt.handle("printer:print", (e, t) => M4(Ct, t)), wt.handle("sync:start", async () => {
    console.log(" Iniciando sincronizacin...");
  }), wt.handle("sync:stop", async () => {
    console.log(" Deteniendo sincronizacin...");
  }), wt.handle("sync:getStatus", async () => ({
    isOnline: !0,
    lastSync: null,
    pendingItems: 0
  })), wt.handle("storage:get", (e, t) => Rc.get(t)), wt.handle("storage:set", (e, t, r) => {
    Rc.set(t, r);
  }), wt.handle("storage:delete", (e, t) => {
    Rc.delete(t);
  }), wt.handle("storage:clear", () => {
    Rc.clear();
  }), wt.handle("updater:check", async () => hi ? null : await kr.autoUpdater.checkForUpdates()), wt.handle("updater:download", async () => hi ? null : await kr.autoUpdater.downloadUpdate()), wt.handle("updater:installAndRestart", () => {
    hi || kr.autoUpdater.quitAndInstall(!1, !0);
  }), wt.handle("updater:openExternal", async (e, t) => {
    await uT.openExternal(t);
  }), wt.handle("export:toExcel", async (e, t) => {
    try {
      const r = await fT.showSaveDialog(Ct, {
        title: "Exportar base de datos a Excel",
        defaultPath: `gravio-export-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.xlsx`,
        filters: [
          { name: "Excel Files", extensions: ["xlsx"] },
          { name: "All Files", extensions: ["*"] }
        ]
      });
      if (r.canceled || !r.filePath)
        return { success: !1, message: "Exportacin cancelada" };
      const n = r0.book_new(), i = t ? [t] : ["registros", "vehiculos", "operadores", "rutas", "empresa", "conceptos", "usuarios"];
      for (const s of i)
        try {
          const o = await Ky(`SELECT * FROM ${s}`, []);
          if (o && o.length > 0) {
            const c = o.map((l) => {
              const d = { ...l };
              return ["created_at", "updated_at", "fecha_entrada", "fecha_salida", "fecha_registro", "pin_expires_at", "last_attempt", "created"].forEach((p) => {
                d[p] && typeof d[p] == "number" && (d[p] = new Date(d[p] * 1e3).toLocaleString("es-MX"));
              }), Object.keys(d).forEach((p) => {
                (d[p] === 0 || d[p] === 1) && (p === "sincronizado" || p === "activo") && (d[p] = d[p] === 1 ? "S" : "No");
              }), d;
            }), u = r0.json_to_sheet(c);
            r0.book_append_sheet(n, u, s);
          }
        } catch (o) {
          console.warn(` No se pudo exportar la tabla ${s}:`, o);
        }
      const a = Dx(n, { type: "buffer", bookType: "xlsx" });
      return Kr.writeFileSync(r.filePath, a), {
        success: !0,
        message: "Base de datos exportada exitosamente",
        filePath: r.filePath
      };
    } catch (r) {
      return console.error(" Error al exportar a Excel:", r), {
        success: !1,
        message: `Error al exportar: ${r.message}`
      };
    }
  });
}
const B4 = sn.requestSingleInstanceLock();
B4 ? sn.on("second-instance", () => {
  Ct && (Ct.isMinimized() && Ct.restore(), Ct.focus());
}) : sn.quit();
